<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Cache Control: Force browsers to always fetch the latest version -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Admin Panel - Google Sheets</title>
    <!-- Google Identity Services -->
    <script>
        // Prevents Google auto-initialization before our code runs
        // Google's script looks for g_id_onload function or element
        // We'll prevent it from auto-initializing by not providing either until ready
        window.g_id_onload = null;
    </script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <!-- Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDysf1CQM7-kZd_mhDcBIhp92o7Tb6SmAQ&libraries=places&callback=initMap" async defer></script>
    <!-- Local Stylesheet for Admin Panel -->
    <style>
/* =================================           CENTRALIZED SVG ICON LIBRARY
           All icons defined here, used everywhere
           Update once, changes apply globally
        ======================================== */
        
        :root {
            /* =================================               LIGHT MODE COLOR SYSTEM
               All colors organized in one place
            ======================================== */
            
            /* Background Colors */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-hover: #f1f3f5;
            --card-bg: #ffffff;
            
            /* Text Colors */
            --text-primary: #212529;
            --text-secondary: #6c757d;
            
            /* Border & Shadow */
            --border-color: #dee2e6;
            --shadow: rgba(0, 0, 0, 0.1);
            
            /* Icon Colors - LIGHT MODE */
            --icon-primary: %23212529;        /* Dark gray for primary icons */
            --icon-secondary: %236c757d;      /* Medium gray for secondary icons */
            --icon-on-badge: %23007AFF;       /* Type badge icon color */
            --icon-location: %23D65052;       /* Location/area icon color */
            --icon-hover-light: %23ffffff;    /* White for hover states on colored backgrounds */
            
            /* Badge Colors */
            --badge-type-bg: rgba(0, 122, 255, 0.1);
            --badge-type-color: #007AFF;
            --badge-area-bg: rgba(214, 80, 82, 0.1);
            --badge-area-color: #D65052;
            --badge-featured-bg: rgba(214, 80, 82, 0.9);
            --badge-featured-color: #ffffff;
            
            /* SVG Icon Definitions - All icons with stroke='currentColor' */
            --icon-wine: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M8 22h8'/%3E%3Cpath d='M7 10h10'/%3E%3Cpath d='M12 15v7'/%3E%3Cpath d='M12 15a5 5 0 0 0 5-5c0-2-.5-4-2-8H9c-1.5 4-2 6-2 8a5 5 0 0 0 5 5z'/%3E%3C/svg%3E");
            --icon-beer: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M17 11h1a3 3 0 0 1 0 6h-1'/%3E%3Cpath d='M9 12v6'/%3E%3Cpath d='M13 12v6'/%3E%3Cpath d='M14 7.5c-1 0-1.44.5-3 .5s-2-.5-3-.5-1.72.5-2.5.5a2.5 2.5 0 0 1 0-5c.78 0 1.5.5 2.5.5s2.22-.5 3.5-.5 2.5.5 3.5.5a2.5 2.5 0 0 1 0 5c-.78 0-1.5-.5-2.5-.5z'/%3E%3Cpath d='M5 8v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V8'/%3E%3C/svg%3E");
            --icon-spirits: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M8 2h8l.5 3h-9z'/%3E%3Cpath d='M7.5 5h9l1 12a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2z'/%3E%3Cpath d='M10 22v-3'/%3E%3Cpath d='M14 22v-3'/%3E%3C/svg%3E");
            --icon-cocktail: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 3l9 9v9'/%3E%3Cpath d='M21 3l-9 9'/%3E%3Cpath d='M3 3h18'/%3E%3Cpath d='M9 21h6'/%3E%3C/svg%3E");
            --icon-coffee: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M18 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z'/%3E%3Cpath d='M6 1v3'/%3E%3Cpath d='M10 1v3'/%3E%3Cpath d='M14 1v3'/%3E%3C/svg%3E");
            --icon-tea: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M18 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z'/%3E%3Cpath d='M6 1v2'/%3E%3Cpath d='M10 1v2'/%3E%3Cpath d='M14 1v2'/%3E%3Cpath d='M6 4v1'/%3E%3Cpath d='M10 4v1'/%3E%3Cpath d='M14 4v1'/%3E%3C/svg%3E");
            --icon-restaurant: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 2v7c0 1.1.9 2 2 2h0a2 2 0 0 0 2-2V2'/%3E%3Cpath d='M7 2v20'/%3E%3Cpath d='M21 15V2a5 5 0 0 0-5 5v8'/%3E%3Cpath d='M21 15v7'/%3E%3C/svg%3E");
            --icon-bakery: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M20 10c0-4.4-3.6-8-8-8s-8 3.6-8 8c0 .9.1 1.7.4 2.5L6 21h12l1.6-8.5c.3-.8.4-1.6.4-2.5z'/%3E%3Cpath d='M6 10h12'/%3E%3C/svg%3E");
            --icon-cheese: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m2 16 10 6V12L2 6z'/%3E%3Cpath d='m12 22 10-6V6l-10 6'/%3E%3Cpath d='M2 16V6l10-6 10 6v10'/%3E%3Ccircle cx='7' cy='13' r='1'/%3E%3Ccircle cx='17' cy='13' r='1'/%3E%3C/svg%3E");
            --icon-chocolate: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='3' rx='2'/%3E%3Cpath d='M3 9h18'/%3E%3Cpath d='M3 15h18'/%3E%3Cpath d='M9 3v18'/%3E%3Cpath d='M15 3v18'/%3E%3C/svg%3E");
            --icon-museum: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m3 21 18 0'/%3E%3Cpath d='M3 7v1a3 3 0 0 0 6 0V7'/%3E%3Cpath d='M9 21v-9'/%3E%3Cpath d='M15 7v1a3 3 0 0 0 6 0V7'/%3E%3Cpath d='M21 21v-9'/%3E%3Cpath d='M3 7h18L12 3z'/%3E%3C/svg%3E");
            --icon-art: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4'/%3E%3Cpolyline points='7 10 12 15 17 10'/%3E%3Cline x1='12' x2='12' y1='15' y2='3'/%3E%3C/svg%3E");
            --icon-gallery: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='3' rx='2' ry='2'/%3E%3Ccircle cx='9' cy='9' r='2'/%3E%3Cpath d='m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21'/%3E%3C/svg%3E");
            --icon-hiking: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='Ccircle cx='10' cy='4' r='2'/%3E%3Cpath d='M7 22V12l-2 3'/%3E%3Cpath d='M7 8v4l6 2 1 6'/%3E%3Cpath d='M14 22v-8'/%3E%3Cpath d='M19 12l-3-6'/%3E%3Cpath d='M19 22V9'/%3E%3C/svg%3E");
            --icon-cycling: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='5.5' cy='17.5' r='3.5'/%3E%3Ccircle cx='18.5' cy='17.5' r='3.5'/%3E%3Cpath d='M15 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2z'/%3E%3Cpath d='m12 17.5-3.5-5.5L15 6'/%3E%3Cpath d='m12 6 3 5.5'/%3E%3C/svg%3E");
            --icon-activity: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='5.5' cy='17.5' r='3.5'/%3E%3Ccircle cx='18.5' cy='17.5' r='3.5'/%3E%3Cpath d='M15 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2z'/%3E%3Cpath d='m12 17.5-3.5-5.5L15 6'/%3E%3Cpath d='m12 6 3 5.5'/%3E%3C/svg%3E");
            --icon-kayaking: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 19v-3'/%3E%3Cpath d='M10 19v-3'/%3E%3Cpath d='M14 19v-3'/%3E%3Cpath d='M18 19v-3'/%3E%3Cpath d='M8 11V9'/%3E%3Cpath d='M16 11V9'/%3E%3Cpath d='M12 11V9'/%3E%3Cpath d='M2 15h20'/%3E%3Cpath d='M2 7a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v1.1c0 .2 0 .3-.1.5L20.4 13H3.6L2.1 8.6c-.1-.2-.1-.3-.1-.5z'/%3E%3C/svg%3E");
            --icon-spa: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 3a7 7 0 0 0-9 10h18a7 7 0 0 0-9-10z'/%3E%3Cpath d='M12 3v18'/%3E%3C/svg%3E");
            --icon-wellness: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.29 1.51 4.04 3 5.5l7 7z'/%3E%3C/svg%3E");
            --icon-shopping: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z'/%3E%3Cline x1='3' x2='21' y1='6' y2='6'/%3E%3Cpath d='M16 10a4 4 0 0 1-8 0'/%3E%3C/svg%3E");
            --icon-market: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 9 12 2l9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpolyline points='9 22 9 12 15 12 15 22'/%3E%3C/svg%3E");
            --icon-concert: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M9 18V5l12-2v13'/%3E%3Ccircle cx='6' cy='18' r='3'/%3E%3Ccircle cx='18' cy='16' r='3'/%3E%3C/svg%3E");
            --icon-theater: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 12a5 5 0 0 0 5 5 8 8 0 0 1 5 2 8 8 0 0 1 5-2 5 5 0 0 0 5-5V7h-5a8 8 0 0 0-5 2 8 8 0 0 0-5-2H2z'/%3E%3Cpath d='M6 11c1.5 0 3 .5 3 2-2 0-3 0-3-2z'/%3E%3Cpath d='M18 11c-1.5 0-3 .5-3 2 2 0 3 0 3-2z'/%3E%3C/svg%3E");
            --icon-cinema: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='3' rx='2'/%3E%3Cpath d='m16 10-4 4-4-4'/%3E%3C/svg%3E");
            --icon-festival: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M4 22h16'/%3E%3Cpath d='M6 18v-7'/%3E%3Cpath d='M10 18v-7'/%3E%3Cpath d='M14 18v-7'/%3E%3Cpath d='M18 18v-7'/%3E%3Cpath d='m4 11 2-2 2 2 2-2 2 2 2-2 2 2 2-2 2 2'/%3E%3Cpath d='M8 7V4c0-1.1.9-2 2-2h4a2 2 0 0 1 2 2v3'/%3E%3C/svg%3E");
            --icon-hotel: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 10h18V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2z'/%3E%3Cpath d='M21 14v8'/%3E%3Cpath d='M3 14v8'/%3E%3Cpath d='M3 14h18'/%3E%3C/svg%3E");
            --icon-lodging: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpolyline points='9 22 9 12 15 12 15 22'/%3E%3C/svg%3E");
            --icon-transport: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M19 17h2l.64-2.54c.24-.959.24-1.962 0-2.92l-1.07-4.27A3 3 0 0 0 17.66 5H4a2 2 0 0 0-2 2v10h2'/%3E%3Ccircle cx='6.5' cy='17.5' r='2.5'/%3E%3Ccircle cx='16.5' cy='17.5' r='2.5'/%3E%3C/svg%3E");
            --icon-train: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='16' height='16' x='4' y='3' rx='2'/%3E%3Cpath d='M4 11h16'/%3E%3Cpath d='M12 3v8'/%3E%3Cpath d='m8 19-2 3'/%3E%3Cpath d='m16 19 2 3'/%3E%3C/svg%3E");
            --icon-boat: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 21c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1 .6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1'/%3E%3Cpolyline points='7 4 2 9 7 14'/%3E%3Cpath d='M22 9 7 9 7 2 12 2z'/%3E%3C/svg%3E");
            --icon-scenic: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m8 2 1.88 1.88'/%3E%3Cpath d='M14.12 3.88 16 2'/%3E%3Cpath d='M9 7.13v-1a3.003 3.003 0 1 1 6 0v1'/%3E%3Cpath d='M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6'/%3E%3Cpath d='M12 20v-9'/%3E%3Cpath d='M6.53 9C4.6 8.8 3 7.1 3 5'/%3E%3Cpath d='M6 13H2'/%3E%3Cpath d='M3 21c0-2.1 1.7-3.9 3.8-4'/%3E%3Cpath d='M20.97 5c0 2.1-1.6 3.8-3.5 4'/%3E%3Cpath d='M22 13h-4'/%3E%3Cpath d='M17.2 17c2.1.1 3.8 1.9 3.8 4'/%3E%3C/svg%3E");
            --icon-viewpoint: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z'/%3E%3Ccircle cx='12' cy='12' r='3'/%3E%3C/svg%3E");
            --icon-park: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 22v-8.5'/%3E%3Cpath d='M7 12 3 8c-.6-.6-.9-1.3-.9-2 0-1.7 1.3-3 3-3 .7 0 1.4.3 2 .9l4 4 4-4c.6-.6 1.3-.9 2-.9 1.7 0 3 1.3 3 3 0 .7-.3 1.4-.9 2l-4 4'/%3E%3C/svg%3E");
            --icon-garden: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 22c-4.97 0-9-4.03-9-9 0-2.5 1-4.75 2.63-6.41 1.32.87 3.14.7 4.24-.4a3 3 0 0 1 4.24 0c1.1 1.1 2.92 1.27 4.24.4C19.97 8.25 21 10.5 21 13c0 4.97-4.03 9-9 9z'/%3E%3Cpath d='M12 2v7'/%3E%3C/svg%3E");
            --icon-beach: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M17.28 9.05a5.5 5.5 0 1 0-10.56 0A5.5 5.5 0 1 0 12 17.66a5.5 5.5 0 1 0 5.28-8.6z'/%3E%3Cpath d='M12 17.66 12 22'/%3E%3C/svg%3E");
            --icon-history: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpolyline points='12 6 12 12 16 14'/%3E%3C/svg%3E");
            --icon-culture: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M22 20v-9H2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2z'/%3E%3Cpath d='M18 11V4H6v7'/%3E%3Cpath d='m9 9 1.5-1.5'/%3E%3Cpath d='m15 9-1.5-1.5'/%3E%3C/svg%3E");
            --icon-architecture: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 21h18'/%3E%3Cpath d='M6 21V7'/%3E%3Cpath d='M10 21V7'/%3E%3Cpath d='M14 21V7'/%3E%3Cpath d='M18 21V7'/%3E%3Cpath d='M3 7h18L12 2 3 7z'/%3E%3C/svg%3E");
            --icon-local: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0z'/%3E%3Ccircle cx='12' cy='10' r='3'/%3E%3C/svg%3E");
            --icon-tour: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20'/%3E%3Cpath d='M2 12h20'/%3E%3C/svg%3E");
            --icon-workshop: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z'/%3E%3C/svg%3E");
            --icon-class: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20'/%3E%3C/svg%3E");
            --icon-food: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M18 8h1a4 4 0 0 1 0 8h-1'/%3E%3Cpath d='M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z'/%3E%3Cline x1='6' x2='6' y1='1' y2='4'/%3E%3Cline x1='10' x2='10' y1='1' y2='4'/%3E%3Cline x1='14' x2='14' y1='1' y2='4'/%3E%3C/svg%3E");
            --icon-cidery: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2C8.134 2 5 5.134 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.866-3.134-7-7-7z'/%3E%3Cpath d='M12 9v6'/%3E%3Ccircle cx='12' cy='9' r='1.5'/%3E%3C/svg%3E");
            --icon-indoor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpath d='M9 22V12h6v10'/%3E%3Ccircle cx='9' cy='9' r='1'/%3E%3Ccircle cx='15' cy='9' r='1'/%3E%3C/svg%3E");
            --icon-attraction: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolygon points='12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2'/%3E%3C/svg%3E");
            --icon-farm: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2v20'/%3E%3Cpath d='M12 2c-3 0-5 2-5 5s2 5 5 5 5-2 5-5-2-5-5-5z'/%3E%3Cpath d='M12 12c-2 0-4 1.5-4 3.5s2 3.5 4 3.5 4-1.5 4-3.5-2-3.5-4-3.5z'/%3E%3Cpath d='M12 18c-1.5 0-2.5 1-2.5 2s1 2 2.5 2 2.5-1 2.5-2-1-2-2.5-2z'/%3E%3C/svg%3E");
            --icon-outdoor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2v20'/%3E%3Cpath d='M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6'/%3E%3C/svg%3E");
            --icon-default: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 8v4'/%3E%3Cpath d='M12 16h.01'/%3E%3C/svg%3E");
        }
        
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* SVG Icon Library */
        .icon-wine { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M8 2h8M12 2v20M7 2c0 4 1.5 8 5 10M17 2c0 4-1.5 8-5 10M12 12v0'/%3E%3Cellipse cx='12' cy='19' rx='3' ry='2'/%3E%3C/svg%3E"); }
        .icon-beer { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M17 11h1a3 3 0 0 1 0 6h-1M18 11V8a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v11a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-8'/%3E%3Cline x1='9' y1='11' x2='9' y2='17'/%3E%3Cline x1='13' y1='11' x2='13' y2='17'/%3E%3C/svg%3E"); }
        .icon-spirits { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M9 2h6l1 10a4 4 0 0 1-8 0L9 2z'/%3E%3Cline x1='12' y1='12' x2='12' y2='22'/%3E%3Cpath d='M8 22h8'/%3E%3C/svg%3E"); }
        .icon-cocktail { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M5 5l7 7v8M19 5l-7 7M5 5h14'/%3E%3Ccircle cx='12' cy='20' r='2'/%3E%3Cline x1='3' y1='3' x2='7' y2='7'/%3E%3C/svg%3E"); }
        .icon-coffee { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M17 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V8z'/%3E%3Cline x1='6' y1='1' x2='6' y2='4'/%3E%3Cline x1='10' y1='1' x2='10' y2='4'/%3E%3Cline x1='14' y1='1' x2='14' y2='4'/%3E%3C/svg%3E"); }
        .icon-tea { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M17 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V8z'/%3E%3Cpath d='M6 1v3M10 1v3M14 1v3' stroke-dasharray='1,2'/%3E%3C/svg%3E"); }
        .icon-restaurant { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 2v7c0 1.1.9 2 2 2h0a2 2 0 0 0 2-2V2M7 2v20M21 15V2v0a5 5 0 0 0-5 5v8'/%3E%3Cline x1='21' y1='15' x2='21' y2='22'/%3E%3C/svg%3E"); }
        .icon-bakery { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cellipse cx='12' cy='11' rx='7' ry='4'/%3E%3Cpath d='M12 7c-3.5 0-6 1.5-6 4v8c0 1 1.5 2 6 2s6-1 6-2v-8c0-2.5-2.5-4-6-4z'/%3E%3Cline x1='8' y1='14' x2='8' y2='14.01'/%3E%3Cline x1='12' y1='14' x2='12' y2='14.01'/%3E%3Cline x1='16' y1='14' x2='16' y2='14.01'/%3E%3C/svg%3E"); }
        .icon-cheese { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M2.4 10L12 3l9.6 7v8H2.4v-8z'/%3E%3Ccircle cx='8' cy='14' r='1.5'/%3E%3Ccircle cx='14' cy='13' r='1'/%3E%3Ccircle cx='11' cy='16' r='1'/%3E%3C/svg%3E"); }
        .icon-chocolate { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='4' y='4' width='16' height='16' rx='2'/%3E%3Cline x1='4' y1='12' x2='20' y2='12'/%3E%3Cline x1='12' y1='4' x2='12' y2='20'/%3E%3Cline x1='8' y1='4' x2='8' y2='12'/%3E%3Cline x1='16' y1='4' x2='16' y2='12'/%3E%3Cline x1='8' y1='12' x2='8' y2='20'/%3E%3Cline x1='16' y1='12' x2='16' y2='20'/%3E%3C/svg%3E"); }
        .icon-museum { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 21h18M4 21V10l8-7 8 7v11'/%3E%3Cline x1='8' y1='10' x2='8' y2='21'/%3E%3Cline x1='12' y1='10' x2='12' y2='21'/%3E%3Cline x1='16' y1='10' x2='16' y2='21'/%3E%3C/svg%3E"); }
        .icon-art { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='3' y='3' width='18' height='18' rx='2'/%3E%3Ccircle cx='8.5' cy='8.5' r='1.5'/%3E%3Cpath d='M21 15l-5-5L5 21'/%3E%3C/svg%3E"); }
        .icon-gallery { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='2' y='6' width='20' height='14' rx='2'/%3E%3Cpath d='M2 12h20M7 6V4a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2'/%3E%3Ccircle cx='9' cy='14' r='1'/%3E%3Cpath d='M2 20l4-4 4 4 4-6 6 6'/%3E%3C/svg%3E"); }
        .icon-hiking { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='Ccircle cx='10' cy='4' r='2'/%3E%3Cpath d='M7 22V12l-2 3'/%3E%3Cpath d='M7 8v4l6 2 1 6'/%3E%3Cpath d='M14 22v-8'/%3E%3Cpath d='M19 12l-3-6'/%3E%3Cpath d='M19 22V9'/%3E%3C/svg%3E"); }
        .icon-cycling { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='5.5' cy='17.5' r='3.5'/%3E%3Ccircle cx='18.5' cy='17.5' r='3.5'/%3E%3Cpath d='M12 5l3 7m-3-7l-3 7m3-7v0'/%3E%3Cpath d='M9 12L5.5 17.5M15 12l3.5 5.5'/%3E%3Ccircle cx='13' cy='4' r='1'/%3E%3C/svg%3E"); }
        .icon-activity { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='5.5' cy='17.5' r='3.5'/%3E%3Ccircle cx='18.5' cy='17.5' r='3.5'/%3E%3Cpath d='M12 5l3 7m-3-7l-3 7m3-7v0'/%3E%3Cpath d='M9 12L5.5 17.5M15 12l3.5 5.5'/%3E%3Ccircle cx='13' cy='4' r='1'/%3E%3C/svg%3E"); }
        .icon-kayaking { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 18h18'/%3E%3Cpath d='M2 12l1.5 6h17l1.5-6-10-6-10 6z'/%3E%3Ccircle cx='12' cy='7' r='1.5'/%3E%3C/svg%3E"); }
        .icon-spa { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 2C6.5 8 3 12 3 17a9 9 0 0 0 18 0c0-5-3.5-9-9-15z'/%3E%3Cpath d='M12 2v20'/%3E%3C/svg%3E"); }
        .icon-wellness { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z'/%3E%3C/svg%3E"); }
        .icon-shopping { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z'/%3E%3Cline x1='3' y1='6' x2='21' y2='6'/%3E%3Cpath d='M16 10a4 4 0 0 1-8 0'/%3E%3C/svg%3E"); }
        .icon-market { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpolyline points='9 22 9 12 15 12 15 22'/%3E%3C/svg%3E"); }
        .icon-concert { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M9 18V5l12-2v13'/%3E%3Ccircle cx='6' cy='18' r='3'/%3E%3Ccircle cx='18' cy='16' r='3'/%3E%3C/svg%3E"); }
        .icon-theater { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M7 2v20M17 2v20M2 12h20M2 7h5M2 17h5M17 7h5M17 17h5'/%3E%3C/svg%3E"); }
        .icon-cinema { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='2' y='7' width='20' height='15' rx='2'/%3E%3Cpolyline points='7 2 12 7 17 2 22 7'/%3E%3C/svg%3E"); }
        .icon-festival { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M4 12l8-8 8 8M4 22l8-8 8 8M12 4v16'/%3E%3Ccircle cx='12' cy='2' r='1'/%3E%3C/svg%3E"); }
        .icon-hotel { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='3' y='4' width='18' height='18' rx='2'/%3E%3Cpath d='M7 4v18M17 4v18M3 10h4M17 10h4M3 14h4M17 14h4M3 18h4M17 18h4'/%3E%3C/svg%3E"); }
        .icon-lodging { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpath d='M9 22V12h6v10'/%3E%3C/svg%3E"); }
        .icon-transport { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='1' y='3' width='15' height='13' rx='2'/%3E%3Cpath d='M16 8h5l3 3v5h-2.5'/%3E%3Ccircle cx='5.5' cy='18.5' r='2.5'/%3E%3Ccircle cx='18.5' cy='18.5' r='2.5'/%3E%3C/svg%3E"); }
        .icon-train { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='4' y='4' width='16' height='16' rx='2'/%3E%3Cpath d='M4 11h16M9 15h6M9 19l-2 2M15 19l2 2M12 4v3'/%3E%3C/svg%3E"); }
        .icon-boat { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M2 20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v0M2 20l8-8v-6h4v6l8 8M12 2v4'/%3E%3C/svg%3E"); }
        .icon-scenic { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 18l5-5 4 4 5-7 4 5v3H3v-0z'/%3E%3Ccircle cx='18' cy='8' r='2'/%3E%3Cpath d='M21 18H3'/%3E%3C/svg%3E"); }
        .icon-viewpoint { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Ccircle cx='12' cy='12' r='4'/%3E%3Cline x1='21.17' y1='8' x2='12' y2='12'/%3E%3Cline x1='3.95' y1='6.06' x2='12' y2='12'/%3E%3Cline x1='10.88' y1='21.94' x2='12' y2='12'/%3E%3C/svg%3E"); }
        .icon-park { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 2L7 12h10L12 2z'/%3E%3Cpath d='M5 14L2 22h20l-3-8H5z'/%3E%3Cline x1='12' y1='22' x2='12' y2='12'/%3E%3C/svg%3E"); }
        .icon-garden { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 22v-8m0 0c-3-2-7-2-7-8 0 0 3 0 7 4m0 4c3-2 7-2 7-8 0 0-3 0-7 4'/%3E%3Ccircle cx='12' cy='2' r='1'/%3E%3C/svg%3E"); }
        .icon-beach { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 3L7 12h10L12 3z'/%3E%3Cpath d='M7 12L2 22h20l-5-10'/%3E%3Cline x1='12' y1='3' x2='12' y2='12'/%3E%3C/svg%3E"); }
        .icon-history { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpolyline points='12 6 12 12 16 14'/%3E%3C/svg%3E"); }
        .icon-culture { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M2 3h20v18H2z'/%3E%3Cpath d='M2 9h20M2 15h20M9 3v18M15 3v18'/%3E%3C/svg%3E"); }
        .icon-architecture { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 21h18M6 21V7l6-4 6 4v14'/%3E%3Cline x1='9' y1='9' x2='9' y2='21'/%3E%3Cline x1='15' y1='9' x2='15' y2='21'/%3E%3C/svg%3E"); }
        .icon-local { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z'/%3E%3Ccircle cx='12' cy='10' r='3'/%3E%3C/svg%3E"); }
        .icon-tour { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20'/%3E%3Cpath d='M2 12h20'/%3E%3C/svg%3E"); }
        .icon-workshop { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z'/%3E%3C/svg%3E"); }
        .icon-class { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M4 19.5A2.5 2.5 0 0 1 6.5 17H20'/%3E%3Cpath d='M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z'/%3E%3C/svg%3E"); }
        .icon-default { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cline x1='12' y1='8' x2='12' y2='12'/%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'/%3E%3C/svg%3E"); }

        /* Badge Styles */
        .icon-default { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cline x1='12' y1='8' x2='12' y2='12'/%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'/%3E%3C/svg%3E"); }
        
        /* =================================           ICON COLOR SYSTEM
           Icons adapt automatically to theme
        ======================================== */
        
        /* Light Mode - Make badge type icons match the badge color (blue) */
        .badge-type::before {
            /* Convert black SVG icons to blue (#007AFF) */
            filter: brightness(0) saturate(100%) invert(38%) sepia(15%) saturate(879%) hue-rotate(94deg) brightness(95%) contrast(89%);
        }
        
        /* Light Mode - Filter buttons should also have blue icons */
        /* Light Mode - Hover state for badges turns icons white */
        .badge-type:hover::before {
            filter: brightness(0) invert(1); /* White icons on colored background */
        }
        
        
        
        /* Nav items in dark mode */
        
        /* Card info icons */
        
        .header { background: #ffffff; color: #212529; padding: 0 20px 0 20px; transition: all 0.3s; width: 100%; }
        .main-container { max-width: 1600px; margin: 0 auto; width: 100%; }
        .header-content { max-width: 1600px; margin: 0 auto; padding: 30px 20px 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 20px; }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .header p { opacity: 0.9; font-size: 16px; }
        .header-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .unsaved-changes-badge {
            display: none;
            font-size: 12px;
            font-weight: 500;
            color: #ffffff;
            background: #34a853;
            border: none;
            border-radius: 0;
            padding: 0;
            height: 30px;
            align-items: center;
            justify-content: center;
            gap: 6px;
            line-height: 1;
            white-space: nowrap;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            margin: 0;
            z-index: 1000;
            box-shadow: none;
        }
        .unsaved-changes-badge:focus {
            outline: none;
        }
        .unsaved-changes-badge:active {
            opacity: 0.9;
        }
        .unsaved-changes-badge svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }
        .unsaved-changes-badge.visible {
            display: flex;
        }
        
        .tabs { max-width: 1600px; margin: 0 auto 0 auto; padding: 8px 20px; display: flex; gap: 0; background: #ffffff; border: 1px solid #e0e0e0; border-radius: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .tab-btn { background: transparent; border: none; color: rgba(33,37,41,0.7); padding: 12px 24px; cursor: pointer; font-size: 14px; font-weight: 600; border-radius: 18px; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; position: relative; margin: 0 2px; }
        .tab-btn:not(:last-child)::after { content: ''; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 1px; height: 60%; background: #e0e0e0; }
        .tab-btn svg { stroke: rgba(33,37,41,0.7); transition: stroke 0.3s; }
        .tab-btn:hover { color: #ffffff; background: #007AFF; }
        .tab-btn:hover svg { stroke: #ffffff; }
        .tab-btn:hover::after { display: none; }
        .tab-btn.active { color: #ffffff; background: #007AFF; }
        .tab-btn.active svg { stroke: #ffffff; }
        .tab-btn.active::after { display: none; }
        
        .btn { padding: 12px 24px; border: none; border-radius: 18px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .btn-success { background: #28a745; color: white; font-weight: 600; }
        .btn-success:hover { background: #218838; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3); }
        .btn-primary { background: #007AFF; color: white; font-weight: 600; }
        .btn-primary:hover { background: #0051D5; box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3); }
        .btn-secondary { background: #6b7280; color: white; font-weight: 600; }
        .btn-secondary:hover { background: #4b5563; box-shadow: 0 4px 8px rgba(107, 114, 128, 0.3); }
        .btn-danger { background: #dc3545; color: white; font-weight: 600; }
        .btn-danger:hover { background: #c82333; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3); }
        .btn-warning { background: #ffc107; color: #212529; font-weight: 600; }
        .btn-warning:hover { background: #e0a800; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(255, 193, 7, 0.3); }
        .btn-info { background: #17a2b8; color: white; font-weight: 600; }
        .btn-info:hover { background: #138496; box-shadow: 0 4px 8px rgba(23, 162, 184, 0.3); }
        
        .stats { width: 100%; margin: 30px 0; padding: 0; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; }
        .stat-card { background: var(--card-bg); padding: 25px; border-radius: 12px; box-shadow: 0 2px 8px var(--shadow); border-left: 4px solid #007AFF; }
        .stat-card h3 { font-size: 14px; color: var(--text-secondary); margin-bottom: 10px; }
        .stat-card p { font-size: 32px; font-weight: 700; color: #007AFF; }
        
        .container { width: 100%; margin: 0; padding: 30px 20px; }
        .section-title { font-size: 24px; margin-bottom: 25px; color: var(--text-primary); }
        
        .filter-bar { background: var(--card-bg); padding: 20px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 2px 8px var(--shadow); }
        .filter-bar input { width: 100%; padding: 12px 16px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; }
        .filter-bar input:focus { outline: none; border-color: #007AFF; }
        
        .listings-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
        .listing-card { background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; overflow: hidden; transition: all 0.3s ease; position: relative; box-shadow: 0 2px 8px var(--shadow); display: flex; flex-direction: column; }
        .listing-card:hover { box-shadow: 0 8px 20px var(--shadow); transform: translateY(-4px); }
        
        .listing-image { width: 100%; height: 180px; object-fit: cover; }
        .listing-content { padding: 20px; display: flex; flex-direction: column; flex: 1; }
        .listing-content h3 { font-size: 18px; margin-bottom: 8px; color: var(--text-primary); }
        
        .listing-meta { display: flex; gap: 10px; margin-bottom: 12px; flex-wrap: wrap; }
        .badge { 
            padding: 2px 10px; 
            border-radius: 6px; 
            font-size: 11px; 
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            height: 18px;
            line-height: 1;
            box-sizing: border-box;
        }
        .badge-type { 
            background: var(--badge-type-bg); 
            color: var(--badge-type-color);
            padding-left: 10px;
        }
        .badge-area { 
            background: var(--badge-area-bg); 
            color: var(--badge-area-color);
            padding-left: 22px;
        }
        
        .listing-desc { 
            font-size: 14px; 
            color: var(--text-secondary); 
            line-height: 1.5; 
            margin-bottom: 12px; 
            display: -webkit-box;
            -webkit-line-clamp: 5;
            line-clamp: 5;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .listing-amenities { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 6px; 
            margin-bottom: 12px; 
            align-items: center;
        }
        .amenity { 
            height: 16px;
            padding: 2px 10px; 
            background: var(--bg-hover); 
            border-radius: 6px; 
            font-size: 10px; 
            color: var(--text-secondary); 
            border: 1px solid var(--border-color); 
            display: inline-flex;
            align-items: center;
            line-height: 1.2;
            white-space: nowrap;
            box-sizing: border-box;
        }
        
        .listing-contact { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; }
        .listing-actions { 
            display: flex; 
            gap: 10px; 
            padding: 8px 20px 20px 20px; 
            margin-top: auto;
            margin-left: -20px;
            margin-right: -20px;
            margin-bottom: 0;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }
        .btn-edit { background: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 18px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; }
        .btn-edit:hover { background: #218838; }
        .btn-duplicate { background: #007AFF; color: white; padding: 8px 16px; border: none; border-radius: 18px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; }
        .btn-duplicate:hover { background: #0056b3; }
        .btn-delete { background: #E3795C; color: white; padding: 8px 16px; border: none; border-radius: 18px; font-size: 12px; font-weight: 600; cursor: pointer; }
        .btn-delete:hover { background: #D65052; }
        
        .featured-badge { position: absolute; top: 10px; right: 10px; background: var(--badge-featured-bg); color: var(--badge-featured-color); padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 700; z-index: 10; }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(62,53,53,0.5); z-index: 1000; overflow-y: auto; }
        .modal.active { display: flex; align-items: center; justify-content: center; padding: 20px; }
        .modal-content { background: var(--card-bg); border-radius: 12px; padding: 30px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px var(--shadow); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; }
        .modal-header h2 { font-size: 24px; color: var(--text-primary); }
        .close-modal { background: none; border: none; font-size: 28px; cursor: pointer; color: var(--text-secondary); padding: 0; width: 32px; height: 32px; }
        .close-modal:hover { color: var(--text-primary); }
        
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary); font-size: 14px; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; font-family: inherit; transition: border-color 0.3s ease, background-color 0.3s ease; background: var(--bg-primary); color: var(--text-primary); }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: #007AFF; }
        .form-group textarea { resize: vertical; min-height: 100px; }
        .image-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .image-input-group input {
            flex: 1;
        }
        .btn-upload-image {
            white-space: nowrap;
        }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        
        .checkbox-group { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 10px; 
            margin-top: 8px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
        }
        
        @media (max-width: 768px) {
            .checkbox-group {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 480px) {
            .checkbox-group {
                grid-template-columns: 1fr;
            }
        }
        .checkbox-item { display: flex; align-items: center; gap: 6px; }
        .checkbox-item input[type="checkbox"] { width: auto; }
        
        .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 30px; }
        
        /* Dialog Modal for confirm/alert replacements */
        .dialog-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .dialog-modal.active {
            display: flex;
        }
        .dialog-modal-content {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 0;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: dialogSlideIn 0.2s ease-out;
        }
        @keyframes dialogSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .dialog-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-color);
        }
        .dialog-modal-header h3 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        .dialog-modal-close {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
        }
        .dialog-modal-close:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .dialog-modal-body {
            padding: 24px;
        }
        .dialog-modal-body p {
            margin: 0;
            color: var(--text-primary);
            line-height: 1.6;
            white-space: pre-line;
        }
        .dialog-modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            padding: 16px 24px;
            border-top: 1px solid var(--border-color);
        }
        .dialog-modal-footer .btn {
            min-width: 120px;
            padding: 12px 24px;
            font-size: 15px;
            font-weight: 600;
        }
        
        .tab-content { display: none; width: 100%; padding: 0 20px; }
        .tab-content.active { display: block; }
        
        .badge-type::before {
            display: none;
        }
        .badge-type:hover {
            background-color: #007AFF;
            color: white;
            transform: scale(1.05);
        }
        .badge-area {
            background: #fef5f3;
            color: #D65052;
            padding: 3px 6px 3px 22px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 600;
            position: relative;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23D65052' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 5px center;
            background-size: 12px 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .badge-area:hover {
            background-color: #D65052;
            color: white;
            transform: scale(1.05);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23ffffff' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E");
        }
        
        .custom-html-preview {
            margin-bottom: 15px;
        }
        .custom-html-preview-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .custom-html-preview-content,
        .custom-html-render {
            background: var(--bg-secondary);
            border: 1px dashed var(--border-color);
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            color: var(--text-secondary);
            max-height: 180px;
            overflow: auto;
        }
        .custom-html-render * {
            font-family: inherit;
            color: inherit;
        }
        
        .back-to-top {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            background: rgba(0, 122, 255, 0.9);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
            z-index: 999;
            transition: opacity 0.3s ease, transform 0.3s ease, background 0.3s ease;
        }

        .back-to-top:hover {
            background: rgba(0, 122, 255, 1);
            transform: translateY(-2px);
        }

        .back-to-top.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }
        
        /* Card Info Icons */
        .card-info-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 10px;
            transition: all 0.2s;
            text-decoration: none;
            color: inherit;
        }
        a.card-info-item {
            text-decoration: none;
            color: inherit;
        }
        a.card-info-item:hover {
            opacity: 0.8;
        }
        a.card-info-item:hover .card-info-icon svg {
            stroke: #6b7280;
            opacity: 0.7;
        }
        .card-info-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .card-info-icon svg {
            width: 18px;
            height: 18px;
            stroke: #6b7280;
            transition: all 0.3s;
        }
        .card-info-text {
            flex: 1;
            font-size: 13px;
            line-height: 1.2;
            padding-top: 2px;
            color: var(--text-secondary);
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            min-width: 0;
            text-wrap: balance;
            -webkit-hyphens: auto;
            -moz-hyphens: auto;
            hyphens: auto;
        }
        a.card-info-item .card-info-text {
            color: var(--text-secondary);
            text-decoration: none;
        }
        a.card-info-item:hover .card-info-text {
            text-decoration: none;
            color: var(--text-secondary);
        }
        
        .filter-content { flex: 1; overflow-y: auto; padding: 0; min-height: 0; }
        .filter-content::-webkit-scrollbar { width: 6px; }
        .filter-content::-webkit-scrollbar-track { background: transparent; }
        .filter-content::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        .filter-content::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        
        .preview-container { width: 100%; margin: 0; padding: 0; }
        .preview-content-wrapper { display: flex; gap: 0; align-items: stretch; }
        .preview-sidebar { width: 280px; flex-shrink: 0; position: sticky; top: 50px; height: calc(100vh - 50px); align-self: flex-start; background: #ffffff; }
        .preview-filters { background: #ffffff; padding: 0; border-radius: 0; box-shadow: none; height: 100%; display: flex; flex-direction: column; }
        .preview-filters h3 { font-size: 18px; color: var(--text-primary); margin-bottom: 0; padding: 20px 20px 15px; background: #ffffff; flex-shrink: 0; }
        .preview-main { flex: 1; min-width: 0; padding: 0 30px 30px 30px; }
        
        .preview-search { margin-bottom: 20px; }
        .preview-search label { display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; }
        .preview-search input { width: 100%; padding: 12px 16px; border: 1px solid var(--border-color); border-radius: 18px; font-size: 14px; transition: border-color 0.2s; background: var(--bg-hover); }
        .preview-search input:focus { outline: none; border-color: #007AFF; background: var(--card-bg); }
        
        .preview-filter-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px; }
        .preview-filter-group label { font-size: 12px; font-weight: 600; color: var(--text-secondary); }
        .preview-filter-group select { width: 100%; padding: 9px 12px; border: 1px solid var(--border-color); border-radius: 18px; font-size: 13px; background: var(--bg-hover); cursor: pointer; transition: all 0.2s; color: var(--text-primary); appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px; }
        .preview-filter-group select:hover { border-color: #cbd5e1; background: var(--card-bg); }
        .preview-filter-group select:focus { outline: none; border-color: #007AFF; background: var(--card-bg); }
        
        /* Type dropdown - remove icon override to use default dropdown arrow only */
        #adminTypeFilter,
        #adminTypeFilter:hover,
        #adminTypeFilter:focus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 12px 12px;
            padding-left: 12px;
            padding-right: 32px;
        }
        
        .preview-filters .btn { width: 100%; padding: 9px 16px; white-space: nowrap; font-size: 13px; margin-top: 8px; }
        
        @media (max-width: 968px) {
            .preview-content-wrapper { flex-direction: column; }
            .preview-sidebar { width: 100%; position: static; }
        }
        
        .type-quick-filters { display: flex; flex-direction: column; gap: 6px; margin-bottom: 20px; }
        .type-filter-btn { 
            width: 100%;
            padding: 10px 14px 10px 8px; 
            border: 1px solid var(--border-color); 
            border-radius: 18px; 
            background: var(--card-bg); 
            color: var(--text-secondary); 
            font-size: 13px; 
            font-weight: 500;
            cursor: pointer; 
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            text-align: left;
        }
        .type-filter-btn svg {
            display: none; /* Hide inline SVGs */
        }
        .type-filter-btn:hover { 
            background: var(--bg-hover); 
            border-color: #007AFF;
            color: var(--text-primary);
        }
        .type-filter-btn.active { 
            background: #007AFF; 
            border-color: #007AFF; 
            color: white; 
        }
        .category-filter-btn {
            padding: 12px 14px;
        }
        .category-filter-btn .category-emoji {
            font-size: 18px;
            line-height: 1;
            margin-right: 2px;
        }
        .category-filter-btn .category-name {
            flex: 1;
            font-weight: 500;
        }
        .type-filters-expanded {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .type-filter-see-more-btn {
            width: 100%;
            padding: 14px 18px;
            border: none;
            border-radius: 0;
            background: var(--card-bg);
            color: var(--text-secondary);
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
            box-shadow: none;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            margin-top: 6px;
        }
        .type-filter-see-more-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: scale(0.98);
            border-radius: 8px;
        }
        
        .data-container { width: 100%; margin: 0; padding: 30px 20px; }
        .data-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; flex-wrap: wrap; gap: 15px; }
        .data-header h2 { font-size: 24px; color: var(--text-primary); }
        .data-actions { display: flex; gap: 10px; }
        .table-wrapper { background: var(--card-bg); border-radius: 12px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.08); overflow-x: auto; max-height: calc(100vh - 200px); overflow-y: auto; }
        .data-table { width: 100%; border-collapse: collapse; }
        .data-table thead { background: #1a1a1a; color: white; }
        .data-table thead tr:first-child th { position: sticky; top: 0; z-index: 10; background: #1a1a1a; }
        .data-table th { padding: 14px 12px; text-align: left; font-size: 13px; font-weight: 600; white-space: nowrap; position: relative; cursor: pointer; user-select: none; }
        .data-table th:hover { background: #2a2a2a; }
        .data-table thead tr:first-child th:hover { background: #2a2a2a; }
        .data-table th.sortable::after { content: ' '; opacity: 0.5; margin-left: 5px; }
        .data-table th.sort-asc::after { content: ' '; opacity: 1; }
        .data-table th.sort-desc::after { content: ' '; opacity: 1; }
        .data-table thead tr.filter-row { background: #2a2a2a; }
        .data-table thead tr.filter-row th { position: sticky; top: 48px; z-index: 10; padding: 8px 12px; background: #2a2a2a; cursor: default; }
        .data-table thead tr.filter-row th:hover { background: #2a2a2a; }
        .data-table .filter-input { width: 100%; padding: 4px 6px; border: 1px solid #444; border-radius: 4px; font-size: 12px; background: #333; color: white; }
        .data-table .filter-input:focus { outline: none; border-color: #007AFF; background: #3a3a3a; }
        .data-table .filter-select { width: 100%; padding: 4px 6px; border: 1px solid #444; border-radius: 18px; font-size: 12px; background: #333; color: white; cursor: pointer; }
        .data-table .filter-select:focus { outline: none; border-color: #007AFF; }
        .data-table tbody tr { border-bottom: 1px solid var(--border-color); transition: background 0.2s; }
        .data-table tbody tr:hover { background: var(--bg-hover); }
        .data-table td { padding: 12px; font-size: 13px; color: var(--text-primary); }
        .data-table td input, .data-table td textarea { width: 100%; padding: 6px 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 13px; background: var(--bg-primary); color: var(--text-primary); }
        .data-table td input:focus, .data-table td textarea:focus { outline: none; border-color: #007AFF; }
        .data-table td textarea { min-height: 60px; resize: vertical; }
        .data-table .cell-image-desc { min-width: 200px; max-width: 300px; }
        .data-table .cell-image-desc textarea { min-height: 50px; font-size: 12px; }
        .data-table .cell-id { color: var(--text-secondary); font-weight: 600; }
        .data-table .cell-name { font-weight: 600; min-width: 150px; }
        .data-table .cell-slug { min-width: 180px; }
        .data-table .cell-type, .data-table .cell-area, .data-table .cell-category { min-width: 120px; }
        .data-table .cell-description { min-width: 250px; max-width: 350px; }
        .data-table .cell-description-detailed { min-width: 300px; max-width: 400px; }
        .data-table .cell-description-detailed textarea { min-height: 120px; white-space: pre-wrap; }
        .data-table .cell-image { min-width: 200px; }
        .data-table .cell-image input { font-size: 11px; }
        .data-table .cell-website { min-width: 250px; }
        .data-table .cell-phone { min-width: 140px; }
        .data-table .cell-address { min-width: 250px; }
        .data-table .cell-amenities { min-width: 200px; max-width: 300px; font-size: 12px; }
        .data-table .cell-amenities textarea { min-height: 50px; }
        .data-table .cell-featured { text-align: center; }
        .data-table .cell-actions { white-space: nowrap; }
        .data-table .btn-table-save { background: #007AFF; color: white; padding: 6px 12px; border: none; border-radius: 18px; font-size: 12px; cursor: pointer; margin-right: 5px; }
        .data-table .btn-table-save:hover { background: #0051D5; }
        .data-table .btn-table-delete { background: #E3795C; color: white; padding: 6px 12px; border: none; border-radius: 18px; font-size: 12px; cursor: pointer; }
        .data-table .btn-table-delete:hover { background: #D65052; }
        
        
        .code-container { width: 100%; margin: 0; padding: 30px 20px; }
        .code-section { background: var(--card-bg); border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .code-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .code-header h3 { font-size: 18px; color: var(--text-primary); }
        .btn-copy { padding: 8px 16px; font-size: 12px; }
        .code-section textarea { width: 100%; min-height: 200px; max-height: 400px; padding: 15px; border: 2px solid var(--border-color); border-radius: 8px; font-family: 'Courier New', monospace; font-size: 12px; resize: vertical; background: var(--bg-hover); color: var(--text-primary); }
        
        /* Flip Card Styles */
        .listings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            padding: 20px 0;
            align-items: stretch;
        }
        
        .flip-card {
            cursor: pointer;
            position: relative;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .flip-card-front,
        .flip-card-back {
            width: 100%;
            border-radius: 12px;
            transition: opacity 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            background: var(--card-bg);
            transform-origin: center center;
        }
        
        .flip-card:hover .flip-card-front,
        .flip-card:hover .flip-card-back {
            transform: scale(0.98);
        }
        
        .flip-card-front {
            position: relative;
            opacity: 1;
            transform: scale(1);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 100%;
        }
        
        .flip-card-back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            opacity: 0;
            transform: scale(0.96);
            pointer-events: none;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            box-sizing: border-box;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .flip-card-back::-webkit-scrollbar {
            width: 6px;
        }
        
        .flip-card-back::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .flip-card-back::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }
        
        .flip-card-back::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }
        
        .flip-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            transition: all 0.2s;
        }
        
        .flip-close-btn:hover {
            background: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }
        
        .flip-back-images {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .flip-back-image {
            flex: 1;
            height: 200px;
            border-radius: 8px;
            object-fit: cover;
        }
        
        .flip-tags-container {
            margin: 15px 0;
            padding: 15px 0;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }
        
        .flip-tags-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .flip-tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .flip-card.flipped {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .flip-card.flipped .flip-card-front {
            opacity: 0;
            transform: scale(0.96);
            pointer-events: none;
        }
        
        .flip-card.flipped .flip-card-back {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            border-radius: 12px;
        }
        
        /* Scrollable image container for card front */
        .card-front-image-scroll {
            position: relative;
            height: 240px !important;
            width: 100%;
            overflow-x: auto !important;
            overflow-y: hidden !important;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            flex-shrink: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
            border-radius: 12px 12px 0 0;
            clip-path: inset(0 round 12px 12px 0 0);
        }
        
        .card-front-image-scroll::-webkit-scrollbar {
            display: none;
        }
        
        .card-front-image-scroll > div {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            display: flex;
            width: auto;
        }
        
        .card-front-image-scroll img {
            position: relative;
            border-radius: 12px !important;
            width: 100%;
            min-width: 100%;
            height: 100% !important;
            aspect-ratio: 1 / 1 !important;
            object-fit: cover !important;
            object-position: center !important;
            display: block !important;
            flex-shrink: 0;
            scroll-snap-align: start;
        }
        
        /* Scroll arrows */
        .scroll-arrow {
            position: absolute;
            width: 30px !important;
            height: 30px !important;
            min-width: 30px !important;
            max-width: 30px !important;
            min-height: 30px !important;
            max-height: 30px !important;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            background-size: 16px 16px !important;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 1 !important;
            transition: background-color 0.3s ease;
            z-index: 10;
            cursor: pointer;
            pointer-events: auto !important;
            flex-shrink: 0 !important;
            box-sizing: border-box !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            margin-top: 0 !important;
        }
        
        .scroll-arrow-right {
            right: 13px !important;
            left: auto !important;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23000' stroke-width='3'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5l7 7-7 7'/%3E%3C/svg%3E");
        }
        
        .scroll-arrow-left {
            left: 10px !important;
            right: auto !important;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23000' stroke-width='3'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5l7 7-7 7'/%3E%3C/svg%3E");
        }
        
        .flip-card-front:hover .scroll-arrow,
        .flip-card-front:hover .card-front-image-scroll .scroll-arrow {
            opacity: 1 !important;
        }
        
        /* Keep arrow always visible and clickable */
        .card-front-image-scroll .scroll-arrow {
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .scroll-arrow:hover {
            background-color: rgba(255, 255, 255, 0.9);
            transform: translateY(-50%) scale(1.1) !important;
        }
        
        @media (max-width: 768px) {
            .form-row { grid-template-columns: 1fr; }
            .header-content { flex-direction: column; align-items: flex-start; }
            .tabs { overflow-x: auto; }
            .listings-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Map Styles */
        .map-container {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 0;
            margin-top: 25px;
            margin-bottom: 30px;
            box-shadow: none;
            transition: all 0.3s;
            position: relative;
        }
        .map-container.map-collapsed {
            background: transparent !important;
        }
        
        @media (max-width: 968px) {
            .map-container {
                box-shadow: none !important;
                padding: 0 !important;
                margin: 16px !important;
                margin-top: 30px !important;
                position: relative;
            }
            .map-header {
                position: absolute;
                top: 10px;
                left: 10px;
                z-index: 1000;
                margin: 0 !important;
                justify-content: flex-start;
            }
            .map-collapsed .map-header {
                left: 50%;
                top: 1px;
                transform: translateX(-50%);
                justify-content: center;
            }
            .map-header h2 {
                display: none !important;
            }
            .map-toggle-btn {
                width: 36px;
                height: 36px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;
                gap: 6px;
            }
            .map-collapsed .map-toggle-btn {
                width: auto !important;
                padding: 10px 14px !important;
                transform: translateY(-30px) !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08) !important;
            }
            .map-toggle-text {
                font-size: 12px;
            }
            #map {
                border-radius: 20px;
                height: 33.333vh !important;
            }
        }
        .map-collapsed {
            padding: 0;
            margin-top: 0;
            margin-bottom: -20px;
            background: transparent !important;
        }
        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            transition: all 0.3s;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            margin: 0;
            justify-content: flex-start;
        }
        .map-collapsed .map-header {
            justify-content: center;
            gap: 12px;
            margin-bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;
            top: 23px;
        }
        .map-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            transition: all 0.3s;
        }
        .map-collapsed .map-header h2 {
            font-size: 16px;
        }
        .map-toggle-btn {
            background: white;
            color: var(--text-primary);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            transition: all 0.3s;
            padding: 0;
            gap: 8px;
        }
        .map-toggle-text {
            display: inline;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }
        .map-collapsed .map-toggle-btn {
            width: auto;
            border-radius: 12px;
            padding: 10px 24px 10px 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            height: auto;
        }
        .map-toggle-btn {
            width: auto;
            border-radius: 12px;
            padding: 10px 24px 10px 16px;
            height: auto;
        }
        .map-toggle-btn:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }
        .map-toggle-btn svg {
            display: block;
        }
        .map-collapsed .map-toggle-btn svg {
            stroke: #22c55e;
            color: #22c55e;
        }
        #map {
            height: 500px;
            width: 100%;
            border-radius: 24px;
            overflow: hidden;
        }
        .map-collapsed #map {
            display: none;
        }
        
        /* Hide Google Maps attribution, copyright, and footer links at the bottom */
        .gm-style-cc {
            display: none !important;
        }
        .gm-style-cc a,
        .gm-style-cc button,
        .gm-style-cc span,
        .gm-style-cc div {
            display: none !important;
        }
        
        /* Hide keyboard shortcuts notice (specific button) */
        .gm-style button[title*="keyboard" i],
        .gm-style button[title*="Keyboard" i],
        .gm-style button[aria-label*="keyboard" i],
        .gm-style button[aria-label*="Keyboard" i] {
            display: none !important;
        }
        
        /* Hide specific attribution links - be very specific */
        .gm-style a[href*="terms"],
        .gm-style a[href*="Report a map error"],
        .gm-style a[href*="report"] {
            display: none !important;
        }
        
        /* Clean up map appearance - but don't hide the map itself */
        .gm-style {
            font-family: inherit !important;
        }
        
        /* Ensure map controls are styled nicely */
        .gm-style-iw-t::after {
            background: transparent !important;
        }
    </style>
    
    <!-- Quick check: If auth is disabled, hide login immediately -->
    <script>
        // Set skipAuth flag immediately (since admin.js has ENABLE_GOOGLE_AUTH = false)
        // This will be cleared by admin.js if auth is re-enabled
        localStorage.setItem('skipAuth', 'true');
        
        // Hide login overlay immediately
        function hideLoginOverlay() {
            const overlay = document.getElementById('loginOverlay');
            if (overlay) {
                overlay.style.display = 'none';
                document.body.classList.add('logged-in');
            }
        }
        
        // Try immediately
        if (document.body) {
            hideLoginOverlay();
        }
        
        // Also try when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', hideLoginOverlay);
        } else {
            hideLoginOverlay();
        }
        
        // Use MutationObserver as backup
        const observer = new MutationObserver(function(mutations) {
            hideLoginOverlay();
            observer.disconnect();
        });
        if (document.body) {
            observer.observe(document.body, { childList: true, subtree: true });
        }
    </script>
    
    <!-- Critical CSS for login page and initial UI -->
    <style>
        /* Basic reset and body styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #ffffff; 
            color: #212529;
        }
        
        /* Login Overlay - Critical for initial page load */
        #loginOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4E6B52 0%, #3a5240 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        #loginOverlay .login-container {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            max-width: 400px;
            width: 90%;
        }
        
        #loginOverlay h2 {
            color: #4E6B52;
            margin: 0 0 10px 0;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        #loginOverlay p {
            color: #6c757d;
            margin: 0;
            font-size: 14px;
        }
        
        #loginOverlay .login-footer {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
            text-align: center;
        }
        
        #loginOverlay .login-footer p {
            font-size: 12px;
        }
        
        #g_id_onload {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            min-height: 50px;
            align-items: center;
        }
        
        #fallbackButtonContainer {
            display: none;
            margin-bottom: 20px;
        }
        
        #fallbackButtonContainer button {
            width: 100%;
            background: #4285f4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: background 0.2s;
        }
        
        #fallbackButtonContainer button:hover {
            background: #357ae8;
        }
        
        #loadingMessage {
            color: #6c757d;
            padding: 20px;
            text-align: center;
        }
        
        #loginError {
            display: none;
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px; 
            text-align: center;
            margin-bottom: 20px;
        }
        
        /* Hide login overlay when logged in */
        body.logged-in #loginOverlay {
            display: none;
        }
        
        /* Ensure content is hidden until logged in */
        body:not(.logged-in) .header,
        body:not(.logged-in) .tabs,
        body:not(.logged-in) .tab-content {
            display: none;
        }
        
        body.error-console-open {
            background: #ffffff !important;
        }
    </style>

</head>
<body>
    <!-- Google OAuth Login Overlay -->
    <div id="loginOverlay">
        <div class="login-container">
            <div style="text-align: center; margin-bottom: 30px;">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Nelson County
                </h2>
                <p>Sign in with your Google account to access the admin panel</p>
            </div>
            
            <div id="googleSignInContainer"></div>
            
            <!-- Fallback manual button if Google's button doesn't load -->
            <div id="fallbackButtonContainer">
                <button onclick="triggerGoogleSignIn()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                    </svg>
                    Sign in with Google
                </button>
                </div>
                
            <div id="loadingMessage">Loading sign-in button...</div>
                
            <div id="loginError">
                <span id="loginErrorText"></span>
            </div>
            
            <div class="login-footer">
                <p>Only authorized Google accounts can access this panel.</p>
            </div>
        </div>
    </div>
    
    <div class="header">
        <div class="header-content">
            <div>
                <h1>Adventure Directory Admin</h1>
                <p>Manage listings with full CRUD operations</p>
            </div>
            <div class="header-buttons">
                <button class="btn btn-secondary" onclick="logout()" style="background: #dc3545; border-color: #dc3545;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16 17 21 12 16 7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                    Logout
                </button>
                <button class="btn btn-success" onclick="openAddModal()">+ Add New Listing</button>
                <input type="file" id="csvUploadMain" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)">
                <button class="btn btn-primary" onclick="document.getElementById('csvUploadMain').click()">
                    Upload CSV
                </button>
                <span id="unsavedChangesBadge" class="unsaved-changes-badge" aria-live="polite" onclick="saveAllToSheets()" style="cursor: pointer;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
                        <line x1="12" y1="9" x2="12" y2="13"></line>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    Unsaved changes - Save to Google Sheets now
                </span>
            </div>
        </div>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('admin')">Admin</button>
            <button class="tab-btn" onclick="switchTab('data')">Data Table</button>
            <button class="tab-btn" onclick="switchTab('settings')">Settings</button>
        </div>
    </div>
    
    <div class="main-container">
    <div id="adminTab" class="tab-content active">
        <div class="stats">
            <div class="stat-card">
                <h3>Total Listings</h3>
                <p id="totalListings">15</p>
            </div>
            <div class="stat-card">
                <h3>Featured</h3>
                <p id="featuredCount">5</p>
            </div>
            <div class="stat-card">
                <h3>Areas Covered</h3>
                <p id="areasCount">6</p>
            </div>
            <div class="stat-card">
                <h3>Types</h3>
                <p id="typesCount">8</p>
            </div>
        </div>
        
        <!-- Google Sheets Status Section -->
        <div class="google-sheets-status-section" style="width: 100%; margin: 30px 0; padding: 20px; background: #fff; border-radius: 8px; border-left: 4px solid #34a853; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                <div>
                    <h3 style="margin: 0 0 5px 0; color: #34a853; display: flex; align-items: center; gap: 8px;">
                        Google Sheets Integration
                    </h3>
                    <p style="margin: 0; color: #666; font-size: 14px;">All changes sync to your Google Sheet. Make sure your Apps Script is configured to accept JSON POST requests.</p>
                </div>
                <div id="sheetsStatusBadge" style="padding: 6px 12px; background: #9aa0a6; color: white; border-radius: 20px; font-size: 12px; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                    <span id="sheetsStatusIcon"></span>
                    <span id="sheetsStatusText">Connecting...</span>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; background: white; padding: 15px; border-radius: 6px;">
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #333;">Apps Script URL:</label>
                    <input type="text" id="sheetsScriptUrl" value="https://script.google.com/macros/s/AKfycbwNH8P5P8iorzRTTx3FpVbYPFNBo1qUWIU630v7ymLJWypvJpSEfPZC5nfxJpjjwjF-Jg/exec" readonly
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 11px; background: #f8f9fa; cursor: text;"
                           onclick="this.select();">
                    <small style="color: #666;">Click to copy</small>
                </div>
                
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #333;">Last Sync:</label>
                    <div id="lastSyncTime" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #f8f9fa; color: #666;">
                        Loading...
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                <button onclick="reloadFromSheets()" 
                        style="background: #4285f4; color: white; border: none; padding: 10px 20px; border-radius: 18px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <polyline points="1 20 1 14 7 14"></polyline>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                    </svg>
                    Reload from Google Sheets
                </button>
                <button onclick="saveAllToSheets()"
                        style="background: #34a853; color: white; border: none; padding: 10px 20px; border-radius: 18px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    Save All to Google Sheets
                </button>
                <button onclick="downloadCSV()"
                        style="background: #4E6B52; color: white; border: none; padding: 10px 20px; border-radius: 18px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Download CSV Backup
                </button>
                <button onclick="showErrorConsole()"
                        style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 18px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
                        <line x1="12" y1="9" x2="12" y2="13"></line>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    Check for Errors
                </button>
                <div id="sheetsActionStatus" style="margin-left: auto; font-weight: 600; color: #34a853;"></div>
            </div>
        </div>
        
        <!-- Error Console Section -->
        <div id="errorConsoleSection" class="error-console-section" style="width: 100%; margin: 30px 0; padding: 20px; background: linear-gradient(135deg, #fff5f5 0%, #ffe5e5 100%); border-radius: 8px; border-left: 4px solid #dc3545; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                <div>
                    <h3 style="margin: 0 0 5px 0; color: #dc3545; display: flex; align-items: center; gap: 8px;">
                        <span></span> <span id="errorConsoleTitle">Framer Import Error Console</span>
                    </h3>
                    <p style="margin: 0; color: #666; font-size: 14px;">Issues that may prevent successful Framer Google Sheets import. Click on an error to navigate to the problematic listing.</p>
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button onclick="validateListings()" 
                            style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 18px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <polyline points="1 20 1 14 7 14"></polyline>
                            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                        </svg>
                        Re-validate
                    </button>
                    <button onclick="hideErrorConsole()" 
                            style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 18px; cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div id="errorConsoleContent" style="background: white; border-radius: 6px; padding: 15px; max-height: 500px; overflow-y: auto;">
                <div style="text-align: center; padding: 40px; color: #999;">
                    <p>Click "Re-validate" to check for errors</p>
                </div>
            </div>
        </div>
        
        <div class="preview-container">
            <div class="preview-content-wrapper">
                <aside class="preview-sidebar">
                    <div class="preview-filters">
                        <div class="filter-content">
                            <div class="filter-section search-section">
                                <div class="preview-search">
                                    <label>Search Listings</label>
                                    <input type="text" id="adminSearchInput" placeholder="Search all fields (name, description, tags, amenities, contact info...)" onkeyup="filterListings()" />
                                </div>
                            </div>
                            
                            <div class="filter-section">
                                <div class="type-quick-filters">
                                    <button class="type-filter-btn category-filter-btn active" data-type="" id="adminAllTypesBtn">
                                        <span class="category-emoji"></span>
                                        <span class="category-name">All Types</span>
                                    </button>
                                    <!-- Type filter buttons will be dynamically generated here based on data usage -->
                                </div>
                            </div>
                            
                            <div class="filter-section">
                                <div class="preview-filter-group">
                                    <select id="adminTypeFilter" onchange="handleAdminTypeFilter()">
                                        <option value="">All Types</option>
                                    </select>
                                </div>
                                
                                <div class="preview-filter-group">
                                    <select id="adminAreaFilter" onchange="filterListings()">
                                        <option value="">All Areas</option>
                                    </select>
                                </div>
                                
                                <div class="preview-filter-group">
                                    <select id="adminAmenityFilter" onchange="filterListings()">
                                        <option value="">All Amenities</option>
                                    </select>
                                </div>
                                
                                <button class="btn btn-secondary" onclick="clearAdminFilters()" style="display: none;">Clear Filters</button>
                            </div>
                        </div>
                    </div>
                </aside>
                
                <main class="preview-main">
                    <div class="map-container" id="mapContainer">
                        <div class="map-header">
                            <h2 style="display: none;">Map View</h2>
                            <button class="map-toggle-btn" onclick="toggleMap()">
                                <svg id="mapToggleIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                                <span class="map-toggle-text">Close Map</span>
                            </button>
                        </div>
                        <div id="map"></div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div id="listingsCount" style="font-size: 14px; color: var(--text-secondary); font-weight: 500;"></div>
                        <select id="adminSortDropdown" onchange="sortAdminListings()" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 18px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px; cursor: pointer; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                            <option value="name-asc" selected style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">Name (A-Z)</option>
                            <option value="name-desc" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">Name (Z-A)</option>
                            <option value="area-asc" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">Area (A-Z)</option>
                            <option value="type-asc" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">Type (A-Z)</option>
                        </select>
                    </div>
                    <div id="listingsGrid" class="listings-grid"></div>
                </main>
            </div>
        </div>
    </div>
    
    <div id="dataTab" class="tab-content">
        <div class="data-container">
            <div class="data-header">
                <h2>Data Table</h2>
                <div class="data-actions">
                    <input type="file" id="csvUpload" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)" />
                    <button class="btn btn-primary" onclick="document.getElementById('csvUpload').click()">Upload CSV</button>
                    <button class="btn btn-success" onclick="downloadCSV()">Download CSV</button>
                    <button class="btn btn-success" onclick="saveTableChanges()" style="background: #4E6B52;">Update Table</button>
                    <button class="btn btn-secondary" onclick="clearTableFilters()" style="background: #6c757d; margin-left: 10px;">Clear Filters</button>
                </div>
            </div>
            <div class="table-wrapper">
                <table id="dataTable" class="data-table">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="id" data-column-key="id">ID</th>
                            <th class="sortable" data-sort="name" data-column-key="name">Name</th>
                            <th class="sortable" data-sort="slug" data-column-key="slug">Slug</th>
                            <th class="sortable" data-sort="type" data-column-key="type">Type</th>
                            <th class="sortable" data-sort="category" data-column-key="category">Category</th>
                            <th class="sortable" data-sort="area" data-column-key="area">Area</th>
                            <th data-column-key="description">Description</th>
                            <th data-column-key="detailedDescription">Detailed Description</th>
                            <th data-column-key="customHtml">Custom HTML</th>
                            <th data-column-key="image1">Image 1</th>
                            <th data-column-key="image1Desc">Image 1 Desc</th>
                            <th data-column-key="image2">Image 2</th>
                            <th data-column-key="image2Desc">Image 2 Desc</th>
                            <th data-column-key="image3">Image 3</th>
                            <th data-column-key="image3Desc">Image 3 Desc</th>
                            <th data-column-key="website">Website</th>
                            <th data-column-key="phone">Phone</th>
                            <th data-column-key="address">Address</th>
                            <th class="sortable" data-sort="authorName" data-column-key="authorName">Author Name</th>
                            <th class="sortable" data-sort="publishedDate" data-column-key="publishedDate">Published Date</th>
                            <th class="sortable" data-sort="modifiedDate" data-column-key="modifiedDate">Modified Date</th>
                            <th data-column-key="directionsLink">Directions Link</th>
                            <th data-column-key="amenities">Amenities</th>
                            <th class="sortable" data-sort="featured" data-column-key="featured">Featured</th>
                            <th data-column-key="actions">Actions</th>
                        </tr>
                        <tr class="filter-row">
                            <th><input type="text" class="filter-input" data-filter="id" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="name" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="slug" placeholder="Filter..." /></th>
                            <th><select class="filter-select" data-filter="type"><option value="">All</option></select></th>
                            <th><select class="filter-select" data-filter="category"><option value="">All</option></select></th>
                            <th><select class="filter-select" data-filter="area"><option value="">All</option></select></th>
                            <th><input type="text" class="filter-input" data-filter="description" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="detailedDescription" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="customHtml" placeholder="Filter... (type 'has' for non-empty)" /></th>
                            <th><input type="text" class="filter-input" data-filter="image1" placeholder="Filter... (type 'has' for non-empty)" /></th>
                            <th><input type="text" class="filter-input" data-filter="image1Desc" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="image2" placeholder="Filter... (type 'has' for non-empty)" /></th>
                            <th><input type="text" class="filter-input" data-filter="image2Desc" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="image3" placeholder="Filter... (type 'has' for non-empty)" /></th>
                            <th><input type="text" class="filter-input" data-filter="image3Desc" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="website" placeholder="Filter... (type 'has' for non-empty)" /></th>
                            <th><input type="text" class="filter-input" data-filter="phone" placeholder="Filter... (type 'has' for non-empty)" /></th>
                            <th><input type="text" class="filter-input" data-filter="address" placeholder="Filter... (type 'has' for non-empty)" /></th>
                            <th><input type="text" class="filter-input" data-filter="authorName" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="publishedDate" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="modifiedDate" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="directionsLink" placeholder="Filter..." /></th>
                            <th><input type="text" class="filter-input" data-filter="amenities" placeholder="Filter..." /></th>
                            <th><select class="filter-select" data-filter="featured"><option value="">All</option><option value="true">Yes</option><option value="false">No</option></select></th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <button type="button" id="backToTopBtn" class="back-to-top hidden" aria-label="Back to top"></button>
    
    <div id="settingsTab" class="tab-content">
        <div class="settings-container" style="width: 100%; margin: 0; padding: 20px;">
            <div style="margin-bottom: 30px;">
                <h2 style="margin: 0 0 10px 0; color: #212529;">Field Configuration</h2>
                <p style="color: #6c757d; margin: 0;">Manage the options available in the Add/Edit listing form. Changes are saved automatically.</p>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                <!-- Types Section -->
                <div class="settings-card" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px;">
                    <h3 style="margin: 0 0 15px 0; color: #212529; font-size: 18px;">Types</h3>
                    <p style="color: #6c757d; font-size: 14px; margin: 0 0 15px 0;">Options for the "Type" dropdown in the listing form</p>
                    <div id="typesList" style="margin-bottom: 15px; max-height: 300px; overflow-y: auto;">
                        <!-- Types will be rendered here -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newTypeInput" placeholder="Add new type..." style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;" onkeypress="if(event.key==='Enter') addType()" />
                        <button onclick="addType()" class="btn btn-success" style="padding: 8px 16px;">Add</button>
                    </div>
                </div>
                
                <!-- Areas Section -->
                <div class="settings-card" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px;">
                    <h3 style="margin: 0 0 15px 0; color: #212529; font-size: 18px;">Areas</h3>
                    <p style="color: #6c757d; font-size: 14px; margin: 0 0 15px 0;">Options for the "Area" dropdown in the listing form</p>
                    <div id="areasList" style="margin-bottom: 15px; max-height: 300px; overflow-y: auto;">
                        <!-- Areas will be rendered here -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newAreaInput" placeholder="Add new area..." style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;" onkeypress="if(event.key==='Enter') addArea()" />
                        <button onclick="addArea()" class="btn btn-success" style="padding: 8px 16px;">Add</button>
                    </div>
                </div>
                
                <!-- Categories Section -->
                <div class="settings-card" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px;">
                    <h3 style="margin: 0 0 15px 0; color: #212529; font-size: 18px;">Categories</h3>
                    <p style="color: #6c757d; font-size: 14px; margin: 0 0 15px 0;">Broad category filters that group listings by type</p>
                    <div id="categoriesList" style="margin-bottom: 15px; max-height: 300px; overflow-y: auto;">
                        <!-- Categories will be rendered here -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newCategoryInput" placeholder="Add new category name..." style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;" onkeypress="if(event.key==='Enter') addCategory()" />
                        <button onclick="addCategory()" class="btn btn-success" style="padding: 8px 16px;">Add</button>
                    </div>
                </div>
                
                <!-- Amenities Section -->
                <div class="settings-card" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; grid-column: 1 / -1;">
                    <h3 style="margin: 0 0 15px 0; color: #212529; font-size: 18px;">Amenities</h3>
                    <p style="color: #6c757d; font-size: 14px; margin: 0 0 15px 0;">Options for the "Amenities" checkboxes in the listing form</p>
                    <div id="amenitiesList" style="margin-bottom: 15px; max-height: 300px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                        <!-- Amenities will be rendered here -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newAmenityInput" placeholder="Add new amenity..." style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;" onkeypress="if(event.key==='Enter') addAmenity()" />
                        <button onclick="addAmenity()" class="btn btn-success" style="padding: 8px 16px;">Add</button>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #4E6B52;">
                <p style="margin: 0; color: #6c757d;">
                    <strong>Note:</strong> Changes are saved automatically. The form dropdowns and checkboxes will update immediately after you add or remove items.
                </p>
            </div>
        </div>
    </div>
    
    <div id="listingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Add New Listing</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            
            <form id="listingForm" onsubmit="saveListing(event)">
                <input type="hidden" id="editingId" />
                
                <div class="form-group">
                    <label>Listing Name *</label>
                    <input type="text" id="listingName" required />
                </div>
                
                <div class="form-group">
                    <label>Slug</label>
                    <input type="text" id="listingSlug" placeholder="Leave blank to auto-generate" />
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Type *</label>
                        <select id="listingType" required>
                            <option value="">Select Type</option>
                            <!-- Options will be populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Category *</label>
                        <select id="listingCategory" required>
                            <option value="">Select Category</option>
                            <!-- Options will be populated dynamically from TYPE_CATEGORIES -->
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Area *</label>
                        <select id="listingArea" required>
                            <option value="">Select Area</option>
                            <!-- Options will be populated dynamically -->
                        </select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Description *</label>
                    <textarea id="listingDescription" required></textarea>
                </div>
                
                <div class="form-group">
                    <label>Detailed Description</label>
                    <textarea id="listingDetailedDescription" placeholder="Long-form copy for brochures, long reads, etc. Line breaks and paragraphs will be preserved." style="min-height: 150px;"></textarea>
                    <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">Use line breaks (Enter) for new lines and double line breaks for paragraph spacing. This text appears on the back of cards when flipped.</small>
                </div>

                <div class="form-group">
                    <label>Custom HTML (Framer Only)</label>
                    <textarea id="listingCustomHtml" placeholder="<section>Custom content for Framer CMS pages</section>" style="min-height: 120px; font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"></textarea>
                    <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">Optional raw HTML that syncs to Google Sheets / Framer CMS. Not rendered inside this admin or the discovery grid.</small>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Image URL 1 *</label>
                        <div class="image-input-group">
                            <input type="text" id="listingImage1" required placeholder="https:// or data:image..." />
                            <button type="button" class="btn btn-secondary btn-upload-image" data-target="listingImage1">Upload</button>
                        </div>
                        <div style="position: relative; margin-top: 8px;">
                            <textarea id="listingImage1Desc" placeholder="Image description (optional)" rows="2" style="width: 100%; padding: 6px 70px 6px 6px; font-family: inherit; font-size: 13px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                            <button type="button" class="btn-generate-desc" data-image="listingImage1" data-desc="listingImage1Desc" title="Generate AI Description" aria-label="Generate AI Description" style="position: absolute; top: 6px; right: 6px; font-size: 11px; background: #007AFF; color: white; border: none; border-radius: 18px; cursor: pointer; display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; line-height: 1;">
                                <span aria-hidden="true" style="display: inline-flex; align-items: center;">
                                    <svg width="16" height="12" viewBox="0 0 16 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6.5 1l.7 1.6 1.8.26-1.3 1.28.32 1.86L6.5 4.97l-1.52.99.32-1.86L4 2.86l1.8-.26L6.5 1z" fill="#FFE599"/>
                                        <path d="M3 4.5l.55 1.2 1.34.2-.97.94.24 1.34L3 7.3l-1.16.68.24-1.34-.97-.94 1.34-.2L3 4.5z" fill="#FFD966"/>
                                        <path d="M11.3 3l.5 1.1 1.23.17-.89.85.22 1.22-1.06-.6-1.06.6.22-1.22-.89-.85 1.23-.17.5-1.1z" fill="#FFF2B6"/>
                                    </svg>
                                </span>
                                <span style="font-weight: 600;">Generate AI Text</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Image URL 2</label>
                        <div class="image-input-group">
                            <input type="text" id="listingImage2" placeholder="https:// or data:image..." />
                            <button type="button" class="btn btn-secondary btn-upload-image" data-target="listingImage2">Upload</button>
                        </div>
                        <div style="position: relative; margin-top: 8px;">
                            <textarea id="listingImage2Desc" placeholder="Image description (optional)" rows="2" style="width: 100%; padding: 6px 70px 6px 6px; font-family: inherit; font-size: 13px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                            <button type="button" class="btn-generate-desc" data-image="listingImage2" data-desc="listingImage2Desc" title="Generate AI Description" aria-label="Generate AI Description" style="position: absolute; top: 6px; right: 6px; font-size: 11px; background: #007AFF; color: white; border: none; border-radius: 18px; cursor: pointer; display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; line-height: 1;">
                                <span aria-hidden="true" style="display: inline-flex; align-items: center;">
                                    <svg width="16" height="12" viewBox="0 0 16 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6.5 1l.7 1.6 1.8.26-1.3 1.28.32 1.86L6.5 4.97l-1.52.99.32-1.86L4 2.86l1.8-.26L6.5 1z" fill="#FFE599"/>
                                        <path d="M3 4.5l.55 1.2 1.34.2-.97.94.24 1.34L3 7.3l-1.16.68.24-1.34-.97-.94 1.34-.2L3 4.5z" fill="#FFD966"/>
                                        <path d="M11.3 3l.5 1.1 1.23.17-.89.85.22 1.22-1.06-.6-1.06.6.22-1.22-.89-.85 1.23-.17.5-1.1z" fill="#FFF2B6"/>
                                    </svg>
                                </span>
                                <span style="font-weight: 600;">Generate AI Text</span>
                            </button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Image URL 3</label>
                        <div class="image-input-group">
                            <input type="text" id="listingImage3" placeholder="https:// or data:image..." />
                            <button type="button" class="btn btn-secondary btn-upload-image" data-target="listingImage3">Upload</button>
                        </div>
                        <div style="position: relative; margin-top: 8px;">
                            <textarea id="listingImage3Desc" placeholder="Image description (optional)" rows="2" style="width: 100%; padding: 6px 70px 6px 6px; font-family: inherit; font-size: 13px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                            <button type="button" class="btn-generate-desc" data-image="listingImage3" data-desc="listingImage3Desc" title="Generate AI Description" aria-label="Generate AI Description" style="position: absolute; top: 6px; right: 6px; font-size: 11px; background: #007AFF; color: white; border: none; border-radius: 18px; cursor: pointer; display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; line-height: 1;">
                                <span aria-hidden="true" style="display: inline-flex; align-items: center;">
                                    <svg width="16" height="12" viewBox="0 0 16 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6.5 1l.7 1.6 1.8.26-1.3 1.28.32 1.86L6.5 4.97l-1.52.99.32-1.86L4 2.86l1.8-.26L6.5 1z" fill="#FFE599"/>
                                        <path d="M3 4.5l.55 1.2 1.34.2-.97.94.24 1.34L3 7.3l-1.16.68.24-1.34-.97-.94 1.34-.2L3 4.5z" fill="#FFD966"/>
                                        <path d="M11.3 3l.5 1.1 1.23.17-.89.85.22 1.22-1.06-.6-1.06.6.22-1.22-.89-.85 1.23-.17.5-1.1z" fill="#FFF2B6"/>
                                    </svg>
                                </span>
                                <span style="font-weight: 600;">Generate AI Text</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Website</label>
                        <input type="text" id="listingWebsite" placeholder="www.example.com or https://..." />
                    </div>
                    
                    <div class="form-group">
                        <label>Phone</label>
                        <input type="tel" id="listingPhone" placeholder="(434) 123-4567" />
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Address *</label>
                    <input type="text" id="listingAddress" required />
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Author Name</label>
                        <input type="text" id="listingAuthorName" placeholder="e.g., Ernest Darrow" />
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Published Date</label>
                        <input type="date" id="listingPublishedDate" />
                    </div>
                    <div class="form-group">
                        <label>Modified Date</label>
                        <input type="date" id="listingModifiedDate" />
                    </div>
                </div>

                <div class="form-group">
                    <label>Directions Link</label>
                    <input type="url" id="listingDirectionsLink" placeholder="https://www.google.com/maps/..." />
                </div>
                
                <div class="form-group">
                    <label>Amenities</label>
                    <div class="checkbox-group" id="amenitiesCheckboxes"></div>
                </div>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="listingFeatured" style="width: auto;" />
                        Mark as Featured
                    </label>
                </div>
                
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                    <button type="submit" class="btn btn-success">Save Listing</button>
                </div>
            </form>
        </div>
    </div>
    
    <script>
        // Test if functions are available
        window.addEventListener('load', function() {
            setTimeout(function() {
                console.log('Testing functions:', {
                    reloadFromSheets: typeof window.reloadFromSheets,
                    saveAllToSheets: typeof window.saveAllToSheets,
                    downloadCSV: typeof window.downloadCSV,
                    openAddModal: typeof window.openAddModal,
                    logout: typeof window.logout,
                    switchTab: typeof window.switchTab,
                    filterAdminByType: typeof window.filterAdminByType,
                    closeModal: typeof window.closeModal
                });
            }, 1000);
        });
    </script>
    <script>
const initialData = 
{
  "listings": [
    {
      "id": "1",
      "name": "Devil's Backbone Brewing Company",
      "type": "Brewery",
      "area": "Wintergreen",
      "description": "Award-winning craft brewery nestled at the base of the Blue Ridge Mountains. Enjoy locally-brewed beers, live music, and mountain views from the outdoor beer garden.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://dbbrewingcompany.com",
      "phone": "(434) 361-1001",
      "address": "200 Mosbys Run, Roseland, VA 22967",
      "amenities": ["Pet-Friendly", "Outdoor Seating", "Live Music", "Food Available"],
      "featured": true
    },
    {
      "id": "2",
      "name": "Crabtree Falls Trail",
      "type": "Hiking",
      "area": "Montebello",
      "description": "Virginia's highest vertical-drop cascading waterfall. This moderate 3-mile round trip hike features stunning overlooks and is especially beautiful in fall foliage season.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.fs.usda.gov/recarea/gwj/recarea/?recid=73957",
      "phone": "(540) 291-2188",
      "address": "Crabtree Falls Hwy, Montebello, VA 24464",
      "amenities": ["Free", "Kid-Friendly", "Scenic Views", "Photography"],
      "featured": true
    },
    {
      "id": "3",
      "name": "Wintergreen Resort",
      "type": "Outdoor",
      "area": "Wintergreen",
      "description": "Four-season mountain resort offering skiing, snowboarding, mountain biking, hiking, golf, and spa services. Stunning Blue Ridge Mountain views year-round.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wintergreenresort.com",
      "phone": "(434) 325-2200",
      "address": "39 Mountain Inn Loop, Wintergreen, VA 22958",
      "amenities": ["Kid-Friendly", "Seasonal", "Wheelchair Accessible", "Lessons Available"],
      "featured": true
    },
    {
      "id": "4",
      "name": "Blue Mountain Brewery",
      "type": "Brewery",
      "area": "Afton",
      "description": "Farm brewery and taproom with an on-site hop yard. Full restaurant menu featuring locally-sourced ingredients and spectacular mountain views from multiple decks.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.bluemountainbrewery.com",
      "phone": "(540) 456-8020",
      "address": "9519 Critzers Shop Rd, Afton, VA 22920",
      "amenities": ["Pet-Friendly", "Outdoor Seating", "Food Available", "Live Music"],
      "featured": false
    },
    {
      "id": "5",
      "name": "The Plunge at Wintergreen",
      "type": "Outdoor",
      "area": "Wintergreen",
      "description": "Outdoor aquatic complex featuring water slides, lazy river, zero-entry pool, and lap pool. Perfect family summer destination with mountain views.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wintergreenresort.com/play/the-plunge",
      "phone": "(434) 325-8169",
      "address": "Wintergreen Dr, Wintergreen, VA 22958",
      "amenities": ["Kid-Friendly", "Seasonal", "Wheelchair Accessible", "Lifeguards"],
      "featured": false
    },
    {
      "id": "6",
      "name": "Rockfish Valley Trail",
      "type": "Hiking",
      "area": "Nellysford",
      "description": "Easy 2-mile paved trail perfect for walking, jogging, or biking. Follows Rockfish River with mountain views and connects to local breweries and shops.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.nelsoncounty-va.gov/facilities/facility/details/Rockfish-Valley-Trail-25",
      "phone": "(434) 263-7015",
      "address": "Rockfish Valley Hwy, Nellysford, VA 22958",
      "amenities": ["Free", "Kid-Friendly", "Pet-Friendly", "Wheelchair Accessible", "Biking"],
      "featured": false
    },
    {
      "id": "7",
      "name": "Wild Wolf Brewing Company",
      "type": "Brewery",
      "area": "Nellysford",
      "description": "Craft brewery with full kitchen, outdoor patio, and kid-friendly atmosphere. Known for creative seasonal beers and live music on weekends.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wildwolfbeer.com",
      "phone": "(434) 361-0088",
      "address": "2773 Rockfish Valley Hwy, Nellysford, VA 22958",
      "amenities": ["Kid-Friendly", "Pet-Friendly", "Outdoor Seating", "Food Available", "Live Music"],
      "featured": false
    },
    {
      "id": "8",
      "name": "Stoney Creek Golf Course",
      "type": "Outdoor",
      "area": "Wintergreen",
      "description": "Championship 18-hole golf course designed by Rees Jones. Features dramatic elevation changes, mountain views, and challenging play for all skill levels.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wintergreenresort.com/play/golf",
      "phone": "(434) 325-8250",
      "address": "Wintergreen Dr, Wintergreen, VA 22958",
      "amenities": ["Seasonal", "Pro Shop", "Lessons Available", "Cart Rental"],
      "featured": false
    },
    {
      "id": "9",
      "name": "Humpback Rocks Trail",
      "type": "Hiking",
      "area": "Afton",
      "description": "Challenging 2-mile hike to stunning 360-degree Blue Ridge views. Part of the Appalachian Trail with rocky terrain and rewarding summit panoramas.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.nps.gov/blri/planyourvisit/humpback-rocks.htm",
      "phone": "(540) 943-5187",
      "address": "Milepost 5.8, Blue Ridge Parkway, Afton, VA 22920",
      "amenities": ["Free", "Scenic Views", "Photography", "Appalachian Trail"],
      "featured": true
    },
    {
      "id": "10",
      "name": "Veritas Vineyards",
      "type": "Winery",
      "area": "Afton",
      "description": "Award-winning winery with stunning views of the Blue Ridge foothills. Offers tastings, tours, and a beautiful outdoor pavilion for events.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.veritaswines.com",
      "phone": "(540) 456-8000",
      "address": "151 Veritas Ln, Afton, VA 22920",
      "amenities": ["Pet-Friendly", "Outdoor Seating", "Tours Available", "Events"],
      "featured": false
    },
    {
      "id": "11",
      "name": "Bold Rock Hard Cider",
      "type": "Cidery",
      "area": "Nellysford",
      "description": "Virginia's first cidery and taproom featuring handcrafted hard ciders made from fresh-pressed Virginia apples. Enjoy live music on the outdoor stage with mountain views, lawn games, and seasonal cider releases. The expansive grounds include a tasting room, outdoor pavilion, and food trucks.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.boldrock.com",
      "phone": "(434) 361-1030",
      "address": "1020 Rockfish Valley Hwy, Nellysford, VA 22958",
      "amenities": ["Pet-Friendly", "Outdoor Seating", "Live Music", "Kid-Friendly", "Tours Available", "Food Available"],
      "featured": true
    },
    {
      "id": "12",
      "name": "Spy Rock",
      "type": "Hiking",
      "area": "Montebello",
      "description": "A moderately challenging 3.7-mile out-and-back trail leading to stunning 360-degree views from a rocky outcrop. Popular spot for sunrise and sunset photography. The trail passes through beautiful hardwood forest and offers glimpses of wildlife. Best visited in spring for wildflowers or fall for foliage.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.hikingupward.com/GWNF/SpyRock",
      "phone": "(540) 291-2188",
      "address": "Spy Rock Rd, Montebello, VA 24464",
      "amenities": ["Free", "Scenic Views", "Photography", "Kid-Friendly"],
      "featured": false
    },
    {
      "id": "13",
      "name": "Pharsalia",
      "type": "Farm & Orchard",
      "area": "Lovingston",
      "description": "Working farm and educational center offering farm tours, workshops, and seasonal events. Visit the farm store for locally-raised grass-fed beef, pastured pork, and farm-fresh eggs. Popular destination for school field trips and agritourism. Beautiful historic property with walking trails and picnic areas.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.pharsalia.org",
      "phone": "(434) 277-5050",
      "address": "3735 Variety Mills Rd, Lovingston, VA 22949",
      "amenities": ["Kid-Friendly", "Tours Available", "Events", "Seasonal", "Free"],
      "featured": false
    },
    {
      "id": "14",
      "name": "Swannanoa Palace",
      "type": "Attraction",
      "area": "Afton",
      "description": "Historic Italian Renaissance-style marble mansion built in 1912 atop Afton Mountain. Offers guided tours showcasing Tiffany stained glass windows, marble columns, and panoramic mountain views. Rich history includes its time as a country club and art school. Perfect for architecture enthusiasts and history buffs.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.swannanoavalley.org",
      "phone": "(434) 325-5539",
      "address": "3051 Swannanoa Dr, Afton, VA 22920",
      "amenities": ["Tours Available", "Photography", "Scenic Views", "Wheelchair Accessible"],
      "featured": false
    },
    {
      "id": "15",
      "name": "Tye River Gap Trail",
      "type": "Hiking",
      "area": "Roseland",
      "description": "Moderate 2.4-mile trail following the historic Tye River through scenic forest. Features multiple creek crossings, swimming holes, and remnants of old railroad grade. Great for families and dogs. Less crowded than other area trails. Best visited in summer for swimming and wading opportunities.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.nelsoncounty-va.gov/trails",
      "phone": "(434) 263-7015",
      "address": "Tye River Gap, VA-56, Roseland, VA 22967",
      "amenities": ["Free", "Pet-Friendly", "Kid-Friendly", "Scenic Views", "Seasonal"],
      "featured": false
    }
  ],
  "filterOptions": {
    "types": ["Brewery", "Winery", "Cidery", "Hiking", "Outdoor", "Indoor Activity", "Attraction", "Farm & Orchard"],
    "areas": ["Afton", "Wintergreen", "Lovingston", "Nellysford", "Montebello", "Arrington", "Roseland"],
    "amenities": ["Kid-Friendly", "Pet-Friendly", "Wheelchair Accessible", "Free", "Seasonal", "Outdoor Seating", "Food Available", "Live Music", "Tours Available", "Events", "Photography", "Scenic Views", "Biking", "Appalachian Trail", "Pro Shop", "Lessons Available", "Cart Rental", "Lifeguards"]
  }
}
;

const REMOVED_LISTING_FIELDS = [
    'imageGallery',
    'amenitiesTags',
    'wordpressUrl',
    'authorEmail',
    'authorUsername',
    'authorId',
    'status',
    'commentStatus',
    'pingStatus',
    'originalCategories',
    'originalAttributes',
    'dataConfidence',
    'notes',
    'descriptionSource',
    'amenitiesGuessed',
    'missingFields'
];

const ADMIN_IMAGE_TRANSFORM_WIDTH = 400;

function getAdminImageUrl(url) {
    if (!url || typeof url !== 'string') return url;
    let finalUrl = url.trim();
    if (!finalUrl) return finalUrl;
    const isImageKit = finalUrl.startsWith('https://ik.imagekit.io/');
    const isDataUrl = finalUrl.startsWith('data:');
    if (!isImageKit || isDataUrl) {
        return finalUrl;
    }
    const transformParam = 'tr=w-' + ADMIN_IMAGE_TRANSFORM_WIDTH + ',f-auto,q-85';
    const parts = finalUrl.split('?');
    const base = parts[0];
    const query = parts[1] ? parts[1].split('&').filter(function(param) {
        return param && !param.startsWith('tr=');
    }) : [];
    query.push(transformParam);
    return base + '?' + query.join('&');
}

function sanitizeListing(listing) {
    if (!listing || typeof listing !== 'object') return listing;
    
    const galleryImage = listing.imageGallery;
    if (!listing.image3 && galleryImage) {
        listing.image3 = galleryImage;
    }
    
    // Normalize dates if they exist
    if (listing.publishedDate && typeof listing.publishedDate === 'string') {
        listing.publishedDate = normalizeDate(listing.publishedDate);
    }
    if (listing.modifiedDate && typeof listing.modifiedDate === 'string') {
        listing.modifiedDate = normalizeDate(listing.modifiedDate);
    }
    
    REMOVED_LISTING_FIELDS.forEach(function(field) {
        if (field in listing) {
            delete listing[field];
        }
    });
    delete listing.imageGallery;
    
    return listing;
}

function escapeHtml(value) {
    if (value === undefined || value === null) return '';
    return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function sanitizeCustomHtml(html) {
    if (!html) return '';
    const template = document.createElement('template');
    template.innerHTML = html;
    template.content.querySelectorAll('script, iframe, object, embed, link, meta, style').forEach(el => el.remove());
    template.content.querySelectorAll('*').forEach(el => {
        Array.from(el.attributes).forEach(attr => {
            const name = attr.name.toLowerCase();
            if (name.startsWith('on') || name === 'srcdoc') {
                el.removeAttribute(attr.name);
            }
        });
    });
    return template.innerHTML;
}

function normalizeFilterValue(value) {
    if (typeof value !== 'string') return '';
    const trimmed = value.trim();
    return trimmed;
}

// Normalize date strings to YYYY-MM-DD format
function normalizeDate(dateStr) {
    if (!dateStr || typeof dateStr !== 'string') {
        return dateStr;
    }
    const trimmed = dateStr.trim();
    if (!trimmed) {
        return '';
    }
    // If already in YYYY-MM-DD format, return as-is
    if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
        return trimmed;
    }
    // Try to parse as Date object (handles Google Sheets date format)
    const date = new Date(trimmed);
    if (!isNaN(date.getTime())) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return year + '-' + month + '-' + day;
    }
    // If can't parse, return original (validation will catch it)
    return trimmed;
}

// Load categories from localStorage (synced between admin and front page)
function loadCategoriesFromStorage() {
    try {
        // Check if localStorage is available
        if (typeof localStorage === 'undefined' || !localStorage) {
            console.error(' localStorage is not available');
            return null;
        }
        
        // Debug: Check all localStorage keys
        const allKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            allKeys.push(key);
        }
        console.log(' All localStorage keys:', allKeys);
        
        const stored = localStorage.getItem('nelsonCounty_categories');
        if (stored) {
            const parsed = JSON.parse(stored);
            if (parsed && typeof parsed === 'object') {
                const categoryKeys = Object.keys(parsed);
                console.log(' loadCategoriesFromStorage: Found', categoryKeys.length, 'categories in localStorage');
                console.log(' Category keys:', categoryKeys);
                console.log(' Category names:', categoryKeys.map(function(k) {
                    return parsed[k].name || k;
                }).join(', '));
                return parsed;
            } else {
                console.warn(' loadCategoriesFromStorage: Stored value is not an object:', typeof parsed);
                console.warn(' Raw stored value:', stored);
            }
        } else {
            console.log(' loadCategoriesFromStorage: No categories found in localStorage');
            console.log(' Checking if key exists with different value...');
            // Double-check by trying to access it directly
            try {
                const directAccess = localStorage['nelsonCounty_categories'];
                if (directAccess) {
                    console.log(' Found value via direct access:', directAccess);
        }
    } catch (e) {
                console.log(' Direct access also failed:', e);
            }
        }
    } catch (e) {
        console.error(' Error loading categories from storage:', e);
        console.error(' Error details:', e.message, e.stack);
    }
    return null;
}

// Save categories to localStorage (synced between admin and front page)
function saveCategoriesToStorage(categories) {
    try {
        // Check if localStorage is available
        if (typeof localStorage === 'undefined' || !localStorage) {
            console.error(' localStorage is not available for saving');
            return false;
        }
        
        const categoryKeys = Object.keys(categories);
        const customKeys = categoryKeys.filter(function(key) {
            return !DEFAULT_TYPE_CATEGORIES.hasOwnProperty(key);
        });
        console.log(' saveCategoriesToStorage: Saving', categoryKeys.length, 'categories to localStorage');
        if (customKeys.length > 0) {
            console.log(' Custom categories being saved:', customKeys.map(function(k) {
                return categories[k].name || k;
            }).join(', '));
        }
        
        const jsonString = JSON.stringify(categories);
        localStorage.setItem('nelsonCounty_categories', jsonString);
        
        // Verify the save worked by reading it back
        const verification = localStorage.getItem('nelsonCounty_categories');
        if (verification === jsonString) {
            console.log(' Categories saved successfully and verified');
            console.log(' Verification: Found', Object.keys(JSON.parse(verification)).length, 'categories after save');
        } else {
            console.warn(' Warning: Save verification failed! Categories may not have been saved correctly.');
            console.warn(' Expected length:', jsonString.length, 'Got length:', verification ? verification.length : 0);
        }
        
        return true;
    } catch (e) {
        console.error(' Error saving categories to storage:', e);
        console.error(' Error details:', e.message, e.stack);
        return false;
    }
}

// ===========================================
// ICON MAPPING MANAGEMENT (synced between admin and front page)
// ===========================================
function loadIconMappingsFromStorage() {
    try {
        const stored = localStorage.getItem('nelsonCounty_iconMappings');
        if (stored) {
            const parsed = JSON.parse(stored);
            if (parsed && typeof parsed === 'object') {
                return parsed;
            }
        }
    } catch (e) {
        console.error('Error loading icon mappings from storage:', e);
    }
    return null;
}

function saveIconMappingsToStorage(iconMappings) {
    try {
        localStorage.setItem('nelsonCounty_iconMappings', JSON.stringify(iconMappings));
        return true;
    } catch (e) {
        console.error('Error saving icon mappings to storage:', e);
        return false;
    }
}

// Default icon mappings - comprehensive list (merged from admin and front page)
const DEFAULT_ICON_MAPPINGS = {
    'Wine': 'icon-wine',
    'Winery': 'icon-wine',
    'Beer': 'icon-beer',
    'Brewery': 'icon-beer',
    'Spirits': 'icon-spirits',
    'Distillery': 'icon-spirits',
    'Cocktails': 'icon-cocktail',
    'Cocktail Bar': 'icon-cocktail',
    'Coffee': 'icon-coffee',
    'Coffee Shop': 'icon-coffee',
    'Caf': 'icon-coffee',
    'Tea': 'icon-tea',
    'Tea Room': 'icon-tea',
    'Restaurant': 'icon-restaurant',
    'Dining': 'icon-restaurant',
    'Bakery': 'icon-bakery',
    'Patisserie': 'icon-bakery',
    'Cheese': 'icon-cheese',
    'Fromagerie': 'icon-cheese',
    'Chocolate': 'icon-chocolate',
    'Chocolatier': 'icon-chocolate',
    'Museum': 'icon-museum',
    'Art': 'icon-art',
    'Art Gallery': 'icon-gallery',
    'Gallery': 'icon-gallery',
    'Hiking': 'icon-hiking',
    'Hike': 'icon-hiking',
    'Trail': 'icon-hiking',
    'Cycling': 'icon-cycling',
    'Bike': 'icon-cycling',
    'Activity': 'icon-activity',
    'Activities': 'icon-activity',
    'Outdoor': 'icon-outdoor',
    'Outdoor Activity': 'icon-outdoor',
    'Kayaking': 'icon-kayaking',
    'Kayak': 'icon-kayaking',
    'Spa': 'icon-spa',
    'Wellness': 'icon-wellness',
    'Health': 'icon-wellness',
    'Shopping': 'icon-shopping',
    'Shop': 'icon-shopping',
    'Market': 'icon-market',
    'Farmers Market': 'icon-market',
    'Concert': 'icon-concert',
    'Music': 'icon-concert',
    'Theater': 'icon-theater',
    'Theatre': 'icon-theater',
    'Cinema': 'icon-cinema',
    'Movie': 'icon-cinema',
    'Film': 'icon-cinema',
    'Festival': 'icon-festival',
    'Event': 'icon-festival',
    'Hotel': 'icon-lodging',
    'Lodging': 'icon-lodging',
    'B&B': 'icon-lodging',
    'BnB': 'icon-lodging',
    'Inn': 'icon-lodging',
    'Cabin': 'icon-lodging',
    'Camping': 'icon-lodging',
    'Transport': 'icon-transport',
    'Transportation': 'icon-transport',
    'Train': 'icon-train',
    'Railway': 'icon-train',
    'Boat': 'icon-boat',
    'Ferry': 'icon-boat',
    'Scenic': 'icon-scenic',
    'Viewpoint': 'icon-viewpoint',
    'Lookout': 'icon-viewpoint',
    'Park': 'icon-park',
    'Garden': 'icon-garden',
    'Beach': 'icon-beach',
    'History': 'icon-history',
    'Historical': 'icon-history',
    'Heritage': 'icon-history',
    'Culture': 'icon-culture',
    'Cultural': 'icon-culture',
    'Architecture': 'icon-architecture',
    'Building': 'icon-architecture',
    'Local': 'icon-local',
    'Tour': 'icon-tour',
    'Guided Tour': 'icon-tour',
    'Workshop': 'icon-workshop',
    'Class': 'icon-class',
    'Course': 'icon-class',
    'Food': 'icon-food',
    'Cuisine': 'icon-food',
    'Cidery': 'icon-cidery',
    'Cider': 'icon-cidery',
    'Indoor Activity': 'icon-indoor',
    'Indoor': 'icon-indoor',
    'Attraction': 'icon-attraction',
    'Attractions': 'icon-attraction',
    'Farm & Orchard': 'icon-farm',
    'Farm': 'icon-farm',
    'Orchard': 'icon-farm'
};

// Initialize icon mappings from storage or defaults
let ICON_MAPPINGS = loadIconMappingsFromStorage();
if (!ICON_MAPPINGS || Object.keys(ICON_MAPPINGS).length === 0) {
    ICON_MAPPINGS = DEFAULT_ICON_MAPPINGS;
    saveIconMappingsToStorage(ICON_MAPPINGS);
}

// Default category definitions - comprehensive list based on user requirements
const DEFAULT_TYPE_CATEGORIES = {
    'taste': {
        emoji: '',
        name: 'Taste',
        description: 'Food and drink experiences of all kinds.',
        icon: 'icon-food',
        types: ['Restaurant', 'Caf', 'Coffee Shop', 'Bakery', 'Brewery', 'Winery', 'Cidery', 'Distillery', 'Bar', 'Cocktail Bar', 'Food Market', 'Farmers Market', 'Food Tour', 'Cooking Class', 'Local Specialty', 'Street Food', 'Fine Dining']
    },
    'stay': {
        emoji: '',
        name: 'Stay',
        description: 'Places to sleep or retreat.',
        icon: 'icon-lodging',
        types: ['Lodging', 'Hotel', 'Resort', 'B&B', 'BnB', 'Inn', 'Cabin', 'Camping', 'Glamping', 'Hostel', 'Boutique Stay', 'Treehouse', 'Unique Stay', 'Airbnb', 'Lodge', 'Boat', 'Entire House', 'House Stay', 'House Rental', 'Vacation Rental', 'Rental', 'Apartment', 'Condo', 'Cottage', 'Villa', 'Home', 'Property']
    },
    'outdoor': {
        emoji: '',
        name: 'Outdoor',
        description: 'Nature, adventure, and recreation outside.',
        icon: 'icon-outdoor',
        types: ['Hiking', 'Outdoor', 'Outdoor Activity', 'Park', 'Beach', 'Trail', 'Camping', 'Climbing', 'Water Sports', 'Skiing', 'Scenic Drive', 'Viewpoint', 'Nature Walk', 'Biking', 'Cycling', 'Kayaking', 'Kayak', 'Farm & Orchard', 'National Park', 'Hike']
    },
    'culture': {
        emoji: '',
        name: 'Culture',
        description: 'Art, heritage, people, and traditions.',
        icon: 'icon-culture',
        types: ['Museum', 'Gallery', 'Art Gallery', 'Art', 'Architecture', 'Landmark', 'Historical Site', 'Festival', 'Cultural Tour', 'Craft', 'Music', 'Theater', 'Theatre', 'Dance', 'Attraction', 'Attractions', 'Local Craft', 'Cultural Site']
    },
    'experience': {
        emoji: '',
        name: 'Experience',
        description: 'Fun, entertainment, and activities.',
        icon: 'icon-activity',
        types: ['Activity', 'Activities', 'Indoor Activity', 'Event', 'Nightlife', 'Club', 'Amusement Park', 'Arcade', 'Live Show', 'Interactive Experience', 'Workshop', 'Tour', 'Entertainment']
    },
    'community': {
        emoji: '',
        name: 'Community',
        description: 'Local people, causes, and collectives.',
        icon: 'icon-local',
        types: ['Community', 'Community Project', 'Volunteer Work', 'Local Profile', 'Maker', 'Story', 'Collective']
    }
};

// Initialize TYPE_CATEGORIES from localStorage or defaults
let loadedCategories = loadCategoriesFromStorage();
let TYPE_CATEGORIES;

if (loadedCategories && Object.keys(loadedCategories).length > 0) {
    // Identify custom categories FIRST (before any modifications)
    const customCategoryKeys = Object.keys(loadedCategories).filter(function(key) {
        return !DEFAULT_TYPE_CATEGORIES.hasOwnProperty(key);
    });
    
    // Preserve custom categories data BEFORE any merging
    const preservedCustomCategories = {};
    if (customCategoryKeys.length > 0) {
        console.log(' Found custom categories to preserve:', customCategoryKeys.map(function(k) {
            return loadedCategories[k].name || k;
        }).join(', '));
        customCategoryKeys.forEach(function(key) {
            preservedCustomCategories[key] = JSON.parse(JSON.stringify(loadedCategories[key]));
        });
    }
    
    // Start with loaded categories from localStorage (preserves custom categories)
    TYPE_CATEGORIES = JSON.parse(JSON.stringify(loadedCategories));
    console.log(' Loaded categories from localStorage. Total:', Object.keys(TYPE_CATEGORIES).length);
    console.log(' Categories:', Object.keys(TYPE_CATEGORIES).map(function(k) {
        return TYPE_CATEGORIES[k].name;
    }).join(', '));
    
    // Ensure all default categories have icons (but don't overwrite custom categories)
    let needsUpdate = false;
    for (const categoryKey in DEFAULT_TYPE_CATEGORIES) {
        if (TYPE_CATEGORIES[categoryKey]) {
            // If category exists but doesn't have an icon, set it from defaults
            if (!TYPE_CATEGORIES[categoryKey].icon && DEFAULT_TYPE_CATEGORIES[categoryKey].icon) {
                TYPE_CATEGORIES[categoryKey].icon = DEFAULT_TYPE_CATEGORIES[categoryKey].icon;
                needsUpdate = true;
            }
        } else {
            // If default category is missing, add it from defaults
            TYPE_CATEGORIES[categoryKey] = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES[categoryKey]));
            needsUpdate = true;
        }
    }
    
    // Explicitly re-add custom categories to ensure they're preserved after merge
    // This is a safety measure in case the merge somehow removed them
    for (const key in preservedCustomCategories) {
        TYPE_CATEGORIES[key] = preservedCustomCategories[key];
    }
    
    // Verify custom categories are still present
    const finalCustomKeys = Object.keys(TYPE_CATEGORIES).filter(function(key) {
        return !DEFAULT_TYPE_CATEGORIES.hasOwnProperty(key);
    });
    if (finalCustomKeys.length !== customCategoryKeys.length) {
        console.warn(' Warning: Custom category count changed during merge!', {
            before: customCategoryKeys.length,
            after: finalCustomKeys.length
        });
    }
    
    // Save updated categories if we made changes (preserves custom categories)
    if (needsUpdate || customCategoryKeys.length > 0) {
        saveCategoriesToStorage(TYPE_CATEGORIES);
        console.log(' Saved categories to localStorage. Total:', Object.keys(TYPE_CATEGORIES).length);
        if (customCategoryKeys.length > 0) {
            console.log(' Preserved custom categories:', customCategoryKeys.map(function(k) {
                return TYPE_CATEGORIES[k].name;
            }).join(', '));
        }
    }
} else {
    // No categories in localStorage, use defaults
    console.log(' No categories in localStorage, using defaults');
    TYPE_CATEGORIES = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES));
    saveCategoriesToStorage(TYPE_CATEGORIES);
}

function normalizeCategoryInput(value) {
    if (!value) return '';
    const trimmed = String(value).trim();
    if (!trimmed) return '';
    const lower = trimmed.toLowerCase();
    
    // First check if it's a direct key match
    if (TYPE_CATEGORIES[lower]) {
        return lower;
    }
    
    // Check if it matches a category name
    for (const categoryKey in TYPE_CATEGORIES) {
        const category = TYPE_CATEGORIES[categoryKey];
        if (!category) continue;
        if (category.name && category.name.toLowerCase() === lower) {
            return categoryKey;
        }
        if (category.emoji && category.emoji === trimmed) {
            return categoryKey;
        }
    }
    
    // Check if it matches a slugified version
    const slugified = lower.replace(/\s+/g, '-');
    if (TYPE_CATEGORIES[slugified]) {
        return slugified;
    }
    
    // If no match found, return the original trimmed value
    // This preserves custom categories that aren't in TYPE_CATEGORIES yet
    console.log(' normalizeCategoryInput: Category "' + trimmed + '" not found in TYPE_CATEGORIES, preserving original value');
    return trimmed;
}

// Keyword mappings for automatic category assignment based on type content
// Used when exact type match is not found in category types array
const TYPE_KEYWORD_MAPPINGS = {
    'taste': ['coffee', 'cafe', 'caf', 'restaurant', 'food', 'dining', 'bakery', 'brewery', 'winery', 'cidery', 'distillery', 'bar', 'cocktail', 'market', 'food', 'cuisine', 'cooking', 'chef', 'meal', 'eat', 'drink', 'beverage', 'wine', 'beer', 'spirit', 'liquor', 'tea', 'espresso', 'latte', 'pizza', 'burger', 'sandwich', 'deli', 'grocery', 'farmers market', 'food tour', 'culinary'],
    'stay': ['hotel', 'lodging', 'resort', 'inn', 'bed and breakfast', 'bnb', 'cabin', 'camping', 'glamping', 'hostel', 'boutique stay', 'treehouse', 'unique stay', 'airbnb', 'lodge', 'accommodation', 'room', 'suite', 'retreat', 'getaway', 'entire house', 'house stay', 'house rental', 'vacation rental', 'rental', 'apartment', 'condo', 'cottage', 'villa', 'home', 'property', 'entire', 'house', 'vacation', 'short term rental', 'str', 'vrbo', 'booking', 'reservation'],
    'outdoor': ['hiking', 'hike', 'trail', 'park', 'beach', 'outdoor', 'nature', 'camping', 'climbing', 'water sports', 'skiing', 'snow', 'scenic', 'viewpoint', 'lookout', 'nature walk', 'biking', 'cycling', 'bike', 'kayaking', 'kayak', 'canoe', 'paddle', 'fishing', 'hunting', 'wildlife', 'forest', 'mountain', 'river', 'lake', 'national park', 'state park', 'garden', 'botanical'],
    'culture': ['museum', 'gallery', 'art', 'architecture', 'landmark', 'historical', 'history', 'heritage', 'festival', 'cultural', 'craft', 'music', 'theater', 'theatre', 'dance', 'performance', 'concert', 'show', 'exhibit', 'exhibition', 'monument', 'memorial', 'site', 'attraction', 'local craft', 'cultural site', 'tradition'],
    'experience': ['activity', 'activities', 'indoor activity', 'indoor', 'event', 'nightlife', 'club', 'amusement', 'arcade', 'live show', 'interactive', 'entertainment', 'fun', 'play', 'game', 'adventure', 'experience', 'tour', 'excursion'],
    'community': ['community', 'volunteer', 'local profile', 'maker', 'story', 'collective', 'group', 'organization', 'nonprofit', 'non-profit', 'charity', 'cause', 'initiative', 'foundation', 'association', 'society', 'network', 'community project', 'volunteer work']
};

// Map individual types to categories (case-insensitive)
// Uses exact match first, then keyword matching, then default fallback
// Also checks for category override on listing
function getCategoryForType(type, listing) {
    // If listing has a category override, use it
    if (listing && listing.category) {
        return listing.category;
    }
    
    if (!type) return null;
    const normalizedType = normalizeFilterValue(type).toLowerCase();
    
    // Step 1: Try exact match (case-insensitive) against category types arrays
    for (const categoryKey in TYPE_CATEGORIES) {
        const category = TYPE_CATEGORIES[categoryKey];
        if (category.types.some(function(catType) {
            return catType.toLowerCase() === normalizedType;
        })) {
            return categoryKey;
        }
    }
    
    // Step 2: Try keyword-based matching if exact match failed
    // Check if the type contains keywords that suggest a category
    for (const categoryKey in TYPE_KEYWORD_MAPPINGS) {
        const keywords = TYPE_KEYWORD_MAPPINGS[categoryKey];
        if (keywords.some(function(keyword) {
            return normalizedType.indexOf(keyword.toLowerCase()) > -1;
        })) {
            return categoryKey;
        }
    }
    
        // Step 3: Default fallback for unmapped types
        return 'experience'; // Default to Experience
}

// Diagnostic function: Check which types don't have categories assigned
function checkUnassignedTypes() {
    if (!data || !data.listings) {
        console.log(' No data available to check types');
        return;
    }
    
    // Get all unique types from listings
    const allTypes = [];
    const typeCounts = {};
    data.listings.forEach(function(listing) {
        if (listing.type) {
            if (typeCounts[listing.type]) {
                typeCounts[listing.type]++;
            } else {
                typeCounts[listing.type] = 1;
                allTypes.push(listing.type);
            }
        }
    });
    
    // Check each type to see if it has a category assigned
    const unassignedTypes = [];
    const categoryAssignments = {};
    
    allTypes.forEach(function(type) {
        // Create a mock listing to test category assignment
        const mockListing = { type: type };
        const category = getCategoryForType(type, mockListing);
        
        if (!category) {
            unassignedTypes.push(type);
        } else {
            if (!categoryAssignments[category]) {
                categoryAssignments[category] = [];
            }
            categoryAssignments[category].push({
                type: type,
                count: typeCounts[type]
            });
        }
    });
    
    // Log results
    console.log(' Type Category Assignment Report:');
    console.log('');
    console.log('Total unique types:', allTypes.length);
    console.log('');
    
    // Show types by category
    console.log(' Types with categories assigned:');
    for (const categoryKey in categoryAssignments) {
        const category = TYPE_CATEGORIES[categoryKey];
        const categoryName = category ? category.name : categoryKey;
        console.log(`  ${categoryName} (${categoryKey}):`);
        categoryAssignments[categoryKey].forEach(function(item) {
            console.log(`    - ${item.type} (${item.count} listing${item.count !== 1 ? 's' : ''})`);
        });
    }
    console.log('');
    
    // Show unassigned types (should be none if everything is working)
    if (unassignedTypes.length > 0) {
        console.log(' Types without categories (falling back to default "experience"):');
        unassignedTypes.forEach(function(type) {
            console.log(`  - ${type} (${typeCounts[type]} listing${typeCounts[type] !== 1 ? 's' : ''})`);
        });
    } else {
        console.log(' All types have categories assigned!');
    }
    console.log('');
    
    // Also check types from filterOptions that might not be in listings yet
    if (data.filterOptions && data.filterOptions.types) {
        const filterTypes = data.filterOptions.types;
        const filterTypesNotInListings = filterTypes.filter(function(type) {
            return allTypes.indexOf(type) === -1;
        });
        
        if (filterTypesNotInListings.length > 0) {
            console.log('');
            console.log(' Types in filterOptions but not in current listings:');
            filterTypesNotInListings.forEach(function(type) {
                const category = getCategoryForType(type, { type: type });
                const categoryName = category && TYPE_CATEGORIES[category] ? TYPE_CATEGORIES[category].name : (category || 'experience (default)');
                console.log(`  - ${type}  ${categoryName}`);
            });
        }
    }
}

function collectUsedFilterOptions(listings) {
    const types = [];
    const areas = [];
    const amenities = [];
    
    const typeSet = new Set();
    const areaSet = new Set();
    const amenitySet = new Set();
    
    (Array.isArray(listings) ? listings : []).forEach(function(listing) {
        if (listing && typeof listing === 'object') {
            const type = normalizeFilterValue(listing.type);
            if (type && !typeSet.has(type)) {
                typeSet.add(type);
                types.push(type);
            }
            
            const area = normalizeFilterValue(listing.area);
            if (area && !areaSet.has(area)) {
                areaSet.add(area);
                areas.push(area);
            }
            
            let listingAmenities = [];
            if (Array.isArray(listing.amenities)) {
                listingAmenities = listing.amenities;
            } else if (typeof listing.amenities === 'string') {
                listingAmenities = listing.amenities.split(/[,;]+/).map(function(value) { return value.trim(); });
            }
            
            listingAmenities.forEach(function(rawAmenity) {
                const amenity = normalizeFilterValue(rawAmenity);
                if (amenity && !amenitySet.has(amenity)) {
                    amenitySet.add(amenity);
                    amenities.push(amenity);
                }
            });
        }
    });
    
    return { types: types, areas: areas, amenities: amenities };
}

function mergeOptionsPreservingOrder(existing, required) {
    const existingArray = Array.isArray(existing) ? existing.map(normalizeFilterValue) : [];
    const requiredArray = Array.isArray(required) ? required.map(normalizeFilterValue).filter(function(value) { return value.length > 0; }) : [];
    const requiredSet = new Set(requiredArray);
    
    const keptExisting = existingArray.filter(function(value) { return value && requiredSet.has(value); });
    const missing = requiredArray.filter(function(value) { return keptExisting.indexOf(value) === -1; });
    
    return keptExisting.concat(missing);
}

function sanitizeFilterOptions(existingOptions, listings) {
    const usage = collectUsedFilterOptions(listings);
    const options = existingOptions || {};
    
    return {
        types: mergeOptionsPreservingOrder(options.types, usage.types),
        areas: mergeOptionsPreservingOrder(options.areas, usage.areas),
        amenities: mergeOptionsPreservingOrder(options.amenities, usage.amenities)
    };
}

function haveDifferentValues(previous, next) {
    const prevArray = Array.isArray(previous) ? previous : [];
    const nextArray = Array.isArray(next) ? next : [];
    
    if (prevArray.length !== nextArray.length) return true;
    for (let i = 0; i < prevArray.length; i++) {
        if (prevArray[i] !== nextArray[i]) {
            return true;
        }
    }
    return false;
}

function refreshFilterSelect(selectId, values) {
    const select = document.getElementById(selectId);
    if (!select) return;
    
    const defaultOption = select.querySelector('option[value=""]');
    if (!select.dataset.placeholderText) {
        if (defaultOption) {
            select.dataset.placeholderText = defaultOption.textContent;
        } else if (select.getAttribute('data-placeholder')) {
            select.dataset.placeholderText = select.getAttribute('data-placeholder');
        } else {
            select.dataset.placeholderText = 'All';
        }
    }
    
    const placeholderText = select.dataset.placeholderText || 'All';
    const currentValue = select.value;
    const safeValues = Array.isArray(values) ? values : [];
    
    // Sort values alphabetically
    const sortedValues = safeValues.slice().sort(function(a, b) {
        return a.toLowerCase().localeCompare(b.toLowerCase());
    });
    
    select.innerHTML = '';
    
    const firstOption = document.createElement('option');
    firstOption.value = '';
    firstOption.textContent = placeholderText;
    select.appendChild(firstOption);
    
    sortedValues.forEach(function(value) {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = value;
        select.appendChild(option);
    });
    
    if (sortedValues.indexOf(currentValue) > -1) {
        select.value = currentValue;
    } else {
        select.value = '';
    }
}

function applyFilterOptionCleanup(existingOptions) {
    if (typeof data === 'undefined') return false;
    
    data.listings = (data.listings || []).map(function(listing) {
        return sanitizeListing(listing);
    });
    
    const sanitized = sanitizeFilterOptions(existingOptions || data.filterOptions, data.listings);
    const typesChanged = haveDifferentValues(data.filterOptions && data.filterOptions.types, sanitized.types);
    const areasChanged = haveDifferentValues(data.filterOptions && data.filterOptions.areas, sanitized.areas);
    const amenitiesChanged = haveDifferentValues(data.filterOptions && data.filterOptions.amenities, sanitized.amenities);
    
    const hasChanges = typesChanged || areasChanged || amenitiesChanged;
    
    data.filterOptions = sanitized;
    
    if (hasChanges) {
        saveFilterOptions();
    }
    
    updateTypeDropdown();
    updateAreaDropdown();
    renderAmenitiesCheckboxes();
    populateAdminFilters();
    populatePreviewFilters();
    
    if (hasChanges) {
        renderSettings();
    }
    
    return hasChanges;
}

initialData.filterOptions = sanitizeFilterOptions(initialData.filterOptions, initialData.listings);

const DEFAULT_TABLE_HEADERS = [
    'id',
    'name',
    'slug',
    'type',
    'category',
    'area',
    'description',
    'detailedDescription',
    'customHtml',
    'image1',
    'image1Desc',
    'image2',
    'image2Desc',
    'image3',
    'image3Desc',
    'website',
    'phone',
    'address',
    'authorName',
    'publishedDate',
    'modifiedDate',
    'directionsLink',
    'amenities',
    'featured'
];

initialData.sheetHeaders = DEFAULT_TABLE_HEADERS.slice();

function normalizeHeaderKey(header) {
    return (header || '')
        .toString()
        .trim()
        .toLowerCase();
}

const TABLE_HEADER_KEY_MAP = [
    { key: 'id', matches: ['id'] },
    { key: 'name', matches: ['name', 'title', 'listing name'] },
    { key: 'slug', matches: ['slug'] },
    { key: 'type', matches: ['type'] },
    { key: 'category', matches: ['category'] },
    { key: 'area', matches: ['area'] },
    { key: 'description', matches: ['description', 'desc'] },
    { key: 'detailedDescription', matches: ['detailed description', 'detaileddescription', 'long description'] },
    { key: 'customHtml', matches: ['custom html', 'customhtml', 'framer html'] },
    { key: 'image1', matches: ['image1', 'image 1', 'photo', 'photo 1'] },
    { key: 'image1Desc', matches: ['image1 desc', 'image 1 desc', 'photo 1 desc', 'image1 description'] },
    { key: 'image2', matches: ['image2', 'image 2', 'photo 2'] },
    { key: 'image2Desc', matches: ['image2 desc', 'image 2 desc', 'photo 2 desc', 'image2 description'] },
    { key: 'image3', matches: ['image3', 'image 3', 'photo 3'] },
    { key: 'image3Desc', matches: ['image3 desc', 'image 3 desc', 'photo 3 desc', 'image3 description'] },
    { key: 'website', matches: ['website', 'external website', 'url'] },
    { key: 'phone', matches: ['phone', 'phone number'] },
    { key: 'address', matches: ['address', 'street address'] },
    { key: 'authorName', matches: ['author', 'author name', 'contributor'] },
    { key: 'publishedDate', matches: ['published date', 'publish date', 'created date'] },
    { key: 'modifiedDate', matches: ['modified date', 'updated date', 'last updated'] },
    { key: 'directionsLink', matches: ['directions link', 'directions url', 'google maps url', 'maps url'] },
    { key: 'amenities', matches: ['amenities', 'amenity'] },
    { key: 'featured', matches: ['featured'] }
];

const TABLE_HEADER_LOOKUP = TABLE_HEADER_KEY_MAP.reduce((acc, item) => {
    item.matches.forEach(match => {
        acc[normalizeHeaderKey(match)] = item.key;
    });
    return acc;
}, {});

function sanitizeSheetHeaders(headers) {
    if (!Array.isArray(headers) || headers.length === 0) {
        return DEFAULT_TABLE_HEADERS.slice();
    }
    return headers
        .map(header => header === undefined || header === null ? '' : header.toString())
        .filter(header => header.trim() !== '');
}

function applySheetHeaders(headers) {
    const sanitized = sanitizeSheetHeaders(headers);
    if (typeof data !== 'undefined' && data) {
        data.sheetHeaders = sanitized;
    }
    updateTableHeaderLabelsFromSheet(sanitized);
}

function updateTableHeaderLabelsFromSheet(headersList) {
    if (!Array.isArray(headersList) || headersList.length === 0) return;
    
    headersList.forEach(header => {
        const normalized = normalizeHeaderKey(header);
        const columnKey = TABLE_HEADER_LOOKUP[normalized];
        if (!columnKey) return;
        
        document.querySelectorAll('th[data-column-key="' + columnKey + '"]').forEach(function(th) {
            th.textContent = header;
        });
    });
}

// =================================
// GOOGLE SHEETS CONFIGURATION
// =================================
        // Step 1: Get your Google Sheet's published CSV URL (optional - used as fallback)
        // File  Share  Publish to web  CSV  Copy URL
        const GOOGLE_SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/YOUR_SHEET_ID/pub?gid=0&single=true&output=csv';
        
        // Step 2: Your Google Apps Script Web App URL (REQUIRED for read/write)
        // This URL is already configured and working!
        const GOOGLE_APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzu1ukNVAwEPf_xWoerojDRDGWmsCYanERrc_yZsAq1XnUskOgq1usxY0JNx2c3EiKvGA/exec';
        const IMAGEKIT_PUBLIC_KEY = 'public_bEXbACd1Av+LMd7EASiu/x25f4o=';
        const IMAGEKIT_URL_ENDPOINT = 'https://ik.imagekit.io/OE';
        const IMAGEKIT_AUTH_ACTION = 'getImageKitUploadParams';
        
        // OpenAI API configuration for image description generation
        // Set your API key in the Google Apps Script or use environment variable
        const OPENAI_API_KEY = ''; // Leave empty to use server-side via Google Apps Script
        const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
        
        // Initialize data with initialData (will be updated from Google Sheets on load)
        let data = JSON.parse(JSON.stringify(initialData));
        data.listings = (data.listings || []).map(function(listing) {
            return sanitizeListing(listing);
        });
        
        // Load saved filterOptions from localStorage if available
        const savedFilterOptions = localStorage.getItem('nelsonCounty_filterOptions');
        if (savedFilterOptions) {
            try {
                const parsedFilterOptions = JSON.parse(savedFilterOptions);
                data.filterOptions = sanitizeFilterOptions(parsedFilterOptions, data.listings);
            } catch (e) {
                console.error('Error loading saved filterOptions:', e);
                data.filterOptions = sanitizeFilterOptions(data.filterOptions, data.listings);
            }
        } else {
            data.filterOptions = sanitizeFilterOptions(data.filterOptions, data.listings);
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            updateUnsavedChangesBadge();
        });
        
        document.addEventListener('input', function(event) {
            const target = event.target;
            if (!target) return;
            if (target.closest('#listingForm') || target.closest('#dataTable') || target.dataset.field) {
                showUnsavedChangesBadge();
            }
        });
        
        document.addEventListener('change', function(event) {
            const target = event.target;
            if (!target) return;
            if (target.closest('#listingForm') || target.closest('#dataTable') || target.dataset.field) {
                showUnsavedChangesBadge();
            }
        });
        
        updateTableHeaderLabelsFromSheet(data.sheetHeaders || DEFAULT_TABLE_HEADERS);
        
        let deleteConfirmId = null;
        let deleteConfirmTimeout = null;
        let unsavedChanges = false;
        
function showUnsavedChangesBadge() {
    unsavedChanges = true;
    updateUnsavedChangesBadge();
}

function resetUnsavedChanges() {
    unsavedChanges = false;
    updateUnsavedChangesBadge();
}

function updateUnsavedChangesBadge() {
    const badge = document.getElementById('unsavedChangesBadge');
    if (!badge) return;
    if (unsavedChanges) {
        badge.classList.add('visible');
    } else {
        badge.classList.remove('visible');
    }
}

        // Helper function to parse CSV text into array of objects
        function parseCSV(csvText) {
            if (!csvText) return { headers: [], dataRows: [] };
            
            const rows = [];
            let currentRow = '';
            let inQuotes = false;
            
            for (let i = 0; i < csvText.length; i++) {
                const char = csvText[i];
                const nextChar = csvText[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        currentRow += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                        currentRow += char;
                    }
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (char === '\r' && nextChar === '\n') i++;
                    if (currentRow.length > 0) rows.push(currentRow);
                    currentRow = '';
                } else {
                    currentRow += char;
                }
            }
            if (currentRow.length > 0) rows.push(currentRow);
            
            const filteredRows = rows.filter(row => row.trim().length > 0);
            if (filteredRows.length === 0) return { headers: [], dataRows: [] };
            
            const parseCSVLine = (line) => {
                const values = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = line[i + 1];
                    
                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        values.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current);
                
                return values.map(value => value.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));
            };
            
            const headers = parseCSVLine(filteredRows[0]).filter(Boolean);
            const dataRows = [];
            
            for (let i = 1; i < filteredRows.length; i++) {
                const values = parseCSVLine(filteredRows[i]);
                if (!values.some(v => v && v.trim())) continue;
                
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = (values[index] !== undefined) ? values[index] : '';
                });
                dataRows.push(row);
            }
            
            return { headers, dataRows };
        }
        
        // Map CSV row to listing object
        function slugify(value) {
            return (value || '')
                .toString()
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
        }
        
        function mapCSVRowToListing(row) {
            const normalizedRow = {};
            if (row && typeof row === 'object') {
                Object.keys(row).forEach(function(key) {
                    if (key === undefined || key === null) return;
                    const normalizedKey = String(key).trim().toLowerCase();
                    if (normalizedKey) {
                        normalizedRow[normalizedKey] = row[key];
                    }
                });
            }
            
            const getField = (fieldName, altNames = [], preserveEmpty = false) => {
                const names = [fieldName, ...altNames];
                for (const name of names) {
                    const normalizedName = String(name).trim().toLowerCase();
                    if (!normalizedName) continue;
                    if (Object.prototype.hasOwnProperty.call(normalizedRow, normalizedName)) {
                        const value = normalizedRow[normalizedName];
                        if (value !== undefined && value !== null) {
                            const trimmed = String(value).trim();
                            // For date fields, return undefined if empty (to preserve existing dates)
                            if (preserveEmpty && trimmed === '') {
                                return undefined;
                            }
                            return trimmed;
                        }
                    }
                }
                return preserveEmpty ? undefined : '';
            };
            
            const parseList = (value) => {
                if (!value) return [];
                return value.split(/[,;]/).map(a => a.trim()).filter(Boolean);
            };
            
            const featuredStr = getField('Featured', ['featured']);
            const detailedDescriptionValue = getField('Detailed Description', [
                'detaileddescription',
                'detailed description',
                'long description',
                'longdescription',
                'full description',
                'fulldescription',
                'detail description',
                'detaildescription',
                'extended description',
                'extendeddescription'
            ]);
            const customHtmlValue = getField('Custom HTML', [
                'custom html',
                'customhtml',
                'custom content',
                'customcontent',
                'custom_html',
                'framer html',
                'framer content'
            ]);
            const image3Value = getField('Image3', ['image3', 'Image 3', 'Photo 3', 'photo3', 'Photo3', 'Third Photo', 'Tertiary Photo']);
            const galleryValue = getField('imageGallery', ['ImageGallery', 'Image Gallery', 'gallery', 'Gallery']);
            
            const googleMapsUrlField = getField('Google Maps URL', ['Google Map URL', 'Google Maps Link', 'Maps URL', 'Map URL', 'Google Maps', 'googleMapsUrl', 'google_maps_url', 'map url', 'maps link']);
            const directionsLinkField = getField('directionsLink', ['Directions Link', 'Directions URL', 'Map Link', 'map directions', 'directions url']);
            
            // Handle category EXACTLY like type - simple and direct
            // Type: getField('Type', ['type']) - no normalization, no transformation
            // Category: getField('Category', ['category']) - same approach
            const categoryValue = getField('Category', ['category']);
            
            const listing = {
                id: getField('ID', ['id', 'Id']),
                name: getField('Title', ['Name', 'name', 'title']) || getField('name'),
                type: getField('Type', ['type']), // Simple, direct - no normalization
                category: categoryValue, // Simple, direct - same as type (no normalization)
                area: getField('Area', ['area']),
                description: getField('Description', ['description', 'Desc', 'desc']),
                detailedDescription: detailedDescriptionValue,
                customHtml: customHtmlValue,
                image1: getField('Photo', ['photo', 'Image', 'image', 'Image1', 'image1', 'Image 1']),
                image2: getField('Image2', ['image2', 'Image 2', 'Photo 2', 'photo2', 'Photo2', 'Second Photo', 'Secondary Photo']),
                image3: image3Value || galleryValue,
                image1Desc: getField('Image1 Desc', ['image1Desc', 'Image1 Description', 'image1 description', 'Image 1 Description', 'Photo 1 Description']),
                image2Desc: getField('Image2 Desc', ['image2Desc', 'Image2 Description', 'image2 description', 'Image 2 Description', 'Photo 2 Description']),
                image3Desc: getField('Image3 Desc', ['image3Desc', 'Image3 Description', 'image3 description', 'Image 3 Description', 'Photo 3 Description']),
                website: getField('External Website', ['Website', 'website', 'URL', 'url', 'website url', 'site url', 'business website', 'website link']),
                phone: getField('Phone', ['phone', 'phone number', 'business phone', 'contact phone', 'primary phone']),
                address: getField('Address', ['address', 'street address', 'business address', 'physical address', 'location']),
                amenities: parseList(getField('Amenities', ['amenities', 'Amenity'])),
                featured: featuredStr === 'TRUE' || featuredStr === 'true' || featuredStr === '1' || featuredStr === 'Yes' || featuredStr === 'yes',
                slug: getField('slug'),
                authorName: getField('authorName', ['Author Name', 'Author', 'author', 'contributor', 'contributor name']),
                publishedDate: (function() {
                    const date = getField('publishedDate', ['Published Date', 'Created Date', 'createdDate', 'Date Created', 'publishDate', 'created on'], true);
                    return date ? normalizeDate(date) : date;
                })(),
                modifiedDate: (function() {
                    const date = getField('modifiedDate', ['Modified Date', 'Updated Date', 'updatedDate', 'Date Updated', 'editedDate', 'Edited Date', 'last updated', 'last modified'], true);
                    return date ? normalizeDate(date) : date;
                })(),
                directionsLink: directionsLinkField || googleMapsUrlField || ''
            };
            
            if (!listing.slug && listing.name) {
                listing.slug = slugify(listing.name);
            }
            
            listing.googleMapsUrl = googleMapsUrlField || listing.directionsLink || '';
            if (!listing.directionsLink && listing.googleMapsUrl) {
                listing.directionsLink = listing.googleMapsUrl;
            }
            
            if (!listing.id && listing.name) {
                listing.id = listing.name.toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }
            
            return sanitizeListing(listing);
        }
        
        // Update sync status UI
        function updateSyncStatus(success, message) {
            const statusBadge = document.getElementById('sheetsStatusBadge');
            const statusIcon = document.getElementById('sheetsStatusIcon');
            const statusText = document.getElementById('sheetsStatusText');
            const actionStatus = document.getElementById('sheetsActionStatus');
            const lastSync = document.getElementById('lastSyncTime');
            
            if (success) {
                statusBadge.style.background = '#34a853';
                statusIcon.textContent = '';
                
                // Extract count from messages like " Loaded 390 listings" or " Loaded 390 listings (CSV)"
                if (message) {
                    const countMatch = message.match(/(\d+)\s+listings?/);
                    if (countMatch) {
                        const count = countMatch[1];
                        statusText.textContent = `Connected (${count} listings)`;
                    } else {
                statusText.textContent = 'Connected';
                    }
                } else {
                    statusText.textContent = 'Connected';
                }
                
                lastSync.textContent = new Date().toLocaleTimeString();
            } else {
                // Check if it's a loading/connecting state or an error
                if (message && (message.includes('Loading') || message.includes('Connecting') || message.includes(''))) {
                    statusBadge.style.background = '#9aa0a6';
                    statusIcon.textContent = '';
                    statusText.textContent = 'Connecting...';
                } else {
                    statusBadge.style.background = '#ea4335';
                    statusIcon.textContent = '';
                    statusText.textContent = 'Error';
                }
            }
            
            if (message) {
                // Don't show "Loaded X listings" or "Connecting..." messages - they're redundant with the status badge
                const isPermanentMessage = message.includes('Loaded') && message.match(/\d+\s+listings?/);
                const isConnectingMessage = message.includes('Connecting') || message.includes('');
                if (!isPermanentMessage && !isConnectingMessage) {
                actionStatus.textContent = message;
                setTimeout(() => {
                    actionStatus.textContent = '';
                }, 3000);
                } else {
                    // Clear the action status for redundant messages
                    actionStatus.textContent = '';
                }
            }
        }
        
        // Load data from Google Sheets on page load
        // Tries Apps Script first (preferred), then CSV as fallback
        async function loadDataFromGoogleSheets() {
            // Set initial status to "Connecting..." (not "Connected" yet)
            updateSyncStatus(false, ' Connecting...');
            
            // Check if running from file:// protocol (local file)
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Try Apps Script first (better format, already working)
            if (GOOGLE_APPS_SCRIPT_URL && !GOOGLE_APPS_SCRIPT_URL.includes('YOUR_SCRIPT_ID')) {
                try {
                    console.log(' Loading data from Google Sheets via Apps Script...');
                    const url = GOOGLE_APPS_SCRIPT_URL + '?t=' + Date.now();
                    let response;
                    
                    // If file:// protocol, use proxy immediately (CORS doesn't work with file://)
                    if (isFileProtocol) {
                        console.log(' Running from file://, using proxy...');
                        console.warn(' Note: Opening HTML files directly (file://) has CORS limitations.');
                        console.warn('   For best results, host this file on a web server (e.g., GitHub Pages, Netlify, or local server).');
                        
                        try {
                            const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
                            response = await fetch(proxyUrl, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache'
                            });
                            
                            if (!response || !response.ok) {
                                throw new Error('Proxy request failed');
                            }
                        } catch (proxyError) {
                            console.error(' Proxy also failed due to CORS:', proxyError);
                            throw new Error('Cannot load from Apps Script when opening file directly. Please host on a web server or use CSV fallback.');
                        }
                    } else {
                        // Try direct fetch first (Apps Script should be configured for CORS)
                        try {
                            response = await fetch(url, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache',
                                credentials: 'omit'
                            });
                            
                            if (!response || !response.ok) {
                                throw new Error('Failed to fetch from Apps Script');
                            }
                        } catch (fetchError) {
                            // Check if it's a CORS error or network error
                            const isCorsError = fetchError.message.includes('CORS') || 
                                              fetchError.message.includes('access control') ||
                                              fetchError.message.includes('Failed to fetch') ||
                                              fetchError.name === 'TypeError';
                            
                            if (isCorsError) {
                                // Try proxy as fallback
                                try {
                                    const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
                                    response = await fetch(proxyUrl, {
                                        method: 'GET',
                                        mode: 'cors',
                                        cache: 'no-cache'
                                    });
                                    
                                    if (!response || !response.ok) {
                                        throw new Error('Proxy also failed');
                                    }
                                } catch (proxyError) {
                                    console.error('Proxy also failed:', proxyError);
                                    throw new Error('Unable to fetch from Apps Script. Please check CORS configuration.');
                                }
                            } else {
                                throw fetchError;
                            }
                        }
                    }
                    
                    if (!response.ok) {
                        // Try to get error message from response
                        let errorMessage = `Failed to fetch from Apps Script (Status: ${response.status})`;
                        try {
                            const errorText = await response.text();
                            if (errorText) {
                                const errorJson = JSON.parse(errorText);
                                errorMessage = errorJson.error || errorMessage;
                            }
                        } catch (e) {
                            // If we can't parse error, use status code
                            if (response.status === 500) {
                                errorMessage = 'Apps Script returned 500 error - check your script for errors';
                            } else if (response.status === 403) {
                                errorMessage = 'Apps Script access denied - check permissions';
                            } else if (response.status === 404) {
                                errorMessage = 'Apps Script URL not found - check your URL';
                            }
                        }
                        throw new Error(errorMessage);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success && result.listings && result.listings.length > 0) {
                        // Debug: Check first listing's category before processing
                        if (result.listings.length > 0) {
                            console.log(' First listing from Google Sheets (before processing):', {
                                name: result.listings[0].name,
                                category: result.listings[0].category,
                                hasCategory: 'category' in result.listings[0],
                                allKeys: Object.keys(result.listings[0]),
                                categoryValue: result.listings[0].category,
                                categoryType: typeof result.listings[0].category
                            });
                        }
                        
                        const listings = result.listings.map(function(listing, index) {
                            // Handle category EXACTLY like type - simple and direct
                            // Type is handled as: listing.type (no normalization, no special logic)
                            // Category should be handled the same way: listing.category
                            
                            // Store original category BEFORE any processing (just like type)
                            const originalCategory = listing.category;
                            
                            // Create a copy of the listing (same as type handling)
                            const listingCopy = Object.assign({}, listing);
                            
                            // Sanitize the listing
                            const sanitized = sanitizeListing(listingCopy);
                            
                            // Restore category EXACTLY as it was in Google Sheets (same as type)
                            // Don't normalize, don't transform - just use what's in Sheets
                            sanitized.category = originalCategory;
                            
                            // Log for debugging (but don't transform the value)
                            if (originalCategory !== undefined && originalCategory !== null && originalCategory !== '') {
                                console.log(' Category from Google Sheets (preserved as-is):', sanitized.name, '->', sanitized.category);
                            } else {
                                console.log(' No category in Google Sheets for:', sanitized.name);
                            }
                            
                            return sanitized;
                        });
                        
                        // Preserve existing filterOptions when loading from Sheets
                        // Ensure data is initialized before accessing it
                        if (typeof data === 'undefined' || !data) {
                            data = JSON.parse(JSON.stringify(initialData));
                        }
                        const existingFilterOptions = data.filterOptions || initialData.filterOptions;
                        const sanitizedFilterOptions = sanitizeFilterOptions(existingFilterOptions, listings);
                        
                        const sheetHeaders = sanitizeSheetHeaders(result.headers || result.sheetHeaders || (data && data.sheetHeaders));
                        
                        data = {
                            listings: listings,
                            filterOptions: sanitizedFilterOptions,
                            sheetHeaders: sheetHeaders
                        };
                        resetUnsavedChanges();
                        
                        updateTableHeaderLabelsFromSheet(sheetHeaders);
                        
                        applyFilterOptionCleanup(sanitizedFilterOptions);
                        
                        console.log(' Loaded ' + listings.length + ' listings from Google Sheets (Apps Script)');
                        
                        // Extract categories from Google Sheets data and ensure they're in TYPE_CATEGORIES
                        // This ensures custom categories from Google Sheets show up even if not in localStorage
                        const categoriesFromData = [...new Set(listings.map(l => l.category).filter(Boolean))];
                        console.log(' Categories found in Google Sheets data:', categoriesFromData);
                        
                        // Load categories from localStorage to get latest emoji/name updates from admin
                        const categoriesFromStorage = loadCategoriesFromStorage();
                        
                        // Add any missing categories from Google Sheets to TYPE_CATEGORIES
                        // Use emoji/name from localStorage (admin) if available
                        let addedCustomCategories = false;
                        categoriesFromData.forEach(function(categoryKey) {
                            if (categoryKey && categoryKey.trim() && !TYPE_CATEGORIES[categoryKey]) {
                                // Check if category exists in localStorage (from admin)
                                let categoryData = null;
                                if (categoriesFromStorage && categoriesFromStorage[categoryKey]) {
                                    categoryData = categoriesFromStorage[categoryKey];
                                    console.log(' Found category in localStorage (from admin):', categoryKey, 'with emoji:', categoryData.emoji);
                                } else if (DEFAULT_TYPE_CATEGORIES[categoryKey]) {
                                    categoryData = DEFAULT_TYPE_CATEGORIES[categoryKey];
                                    console.log(' Found category in DEFAULT_TYPE_CATEGORIES:', categoryKey, 'with emoji:', categoryData.emoji);
                                }
                                
                                // Use data from admin/localStorage if available, otherwise create minimal entry
                                TYPE_CATEGORIES[categoryKey] = categoryData ? {
                                    name: categoryData.name || categoryKey,
                                    emoji: categoryData.emoji || '',
                                    description: categoryData.description || 'Custom category from Google Sheets',
                                    types: categoryData.types || [],
                                    icon: categoryData.icon || ''
                                } : {
                                    name: categoryKey,
                                    emoji: '',
                                    description: 'Custom category from Google Sheets',
                                    types: []
                                };
                                addedCustomCategories = true;
                                console.log(' Added category from Google Sheets to TYPE_CATEGORIES:', categoryKey, 'with emoji:', TYPE_CATEGORIES[categoryKey].emoji || '(none)');
                            } else if (TYPE_CATEGORIES[categoryKey]) {
                                // Category already exists - ALWAYS sync emoji/name from localStorage/admin
                                // Google Sheets only stores the category key, not the emoji
                                if (categoriesFromStorage && categoriesFromStorage[categoryKey]) {
                                    const storageCategory = categoriesFromStorage[categoryKey];
                                    // Always update emoji from admin if it exists (even if currently empty)
                                    if (storageCategory.emoji) {
                                        TYPE_CATEGORIES[categoryKey].emoji = storageCategory.emoji;
                                        console.log(' Synced emoji for category', categoryKey, 'from admin:', storageCategory.emoji);
                                    }
                                    // Always update name from admin if it exists
                                    if (storageCategory.name) {
                                        TYPE_CATEGORIES[categoryKey].name = storageCategory.name;
                                        console.log(' Synced name for category', categoryKey, 'from admin:', storageCategory.name);
                                    }
                                    // Sync other properties too
                                    if (storageCategory.description) {
                                        TYPE_CATEGORIES[categoryKey].description = storageCategory.description;
                                    }
                                    if (storageCategory.icon) {
                                        TYPE_CATEGORIES[categoryKey].icon = storageCategory.icon;
                                    }
                                } else if (DEFAULT_TYPE_CATEGORIES[categoryKey]) {
                                    // Fallback to defaults if not in localStorage
                                    const defaultCategory = DEFAULT_TYPE_CATEGORIES[categoryKey];
                                    if (defaultCategory.emoji && !TYPE_CATEGORIES[categoryKey].emoji) {
                                        TYPE_CATEGORIES[categoryKey].emoji = defaultCategory.emoji;
                                        console.log(' Using default emoji for category', categoryKey, ':', defaultCategory.emoji);
                                    }
                                }
                            }
                        });
                        
                        if (addedCustomCategories) {
                            console.log(' TYPE_CATEGORIES after adding Google Sheets categories:', Object.keys(TYPE_CATEGORIES).length, 'categories');
                            console.log(' Category keys:', Object.keys(TYPE_CATEGORIES));
                        }
                        
                        updateSyncStatus(true, ` Loaded ${listings.length} listings`);
                        renderListings();
                        populateAdminFilters();
                        updateStats();
                        return;
                    }
                } catch (error) {
                    console.error(' Error loading from Apps Script:', error);
                    
                    // Check what type of error it is
                    if (error.message.includes('500')) {
                        updateSyncStatus(false, ' Apps Script error (500) - falling back to CSV');
                        console.error(' Your Google Apps Script has an internal error. Check the Apps Script execution logs.');
                        console.error('   Error:', error.message);
                    } else if (error.message.includes('CORS') || error.message.includes('access control') || error.message.includes('Origin null')) {
                        updateSyncStatus(false, ' CORS error - retrying...');
                        // Only log CORS warning if it's a persistent issue
                        // (Suppress on first attempt, will retry via CSV fallback)
                        if (error.message.includes('Proxy also failed')) {
                            console.warn(' CORS Error: Your Google Apps Script may need CORS headers configured.\n' +
                                        'If this persists, add to your doGet function:\n' +
                                        'return ContentService\n' +
                                        '  .createTextOutput(JSON.stringify({success: true, listings: [...]}))\n' +
                                        '  .setMimeType(ContentService.MimeType.JSON);');
                        } else {
                            // First CORS attempt - just log briefly, will retry
                            console.log(' CORS blocked, trying proxy...');
                        }
                    } else {
                        updateSyncStatus(false, ' Connection error - falling back to CSV');
                        console.error('   Error:', error.message);
                    }
                    
                    console.log(' Falling back to CSV...');
                }
            }
            
            // Fallback to CSV if Apps Script fails or not configured
            if (GOOGLE_SHEET_CSV_URL && !GOOGLE_SHEET_CSV_URL.includes('YOUR_SHEET_ID')) {
                try {
                    const cacheBustUrl = GOOGLE_SHEET_CSV_URL + (GOOGLE_SHEET_CSV_URL.includes('?') ? '&' : '?') + 't=' + Date.now();
                    console.log(' Loading data from Google Sheets CSV...');
                    
                    let response;
                    // If file:// protocol, try multiple approaches
                    if (isFileProtocol) {
                        // Try different proxy services
                        const proxies = [
                            'https://api.allorigins.win/raw?url=',
                            'https://corsproxy.io/?',
                            'https://cors-anywhere.herokuapp.com/'
                        ];
                        
                        let proxySuccess = false;
                        for (let i = 0; i < proxies.length && !proxySuccess; i++) {
                            try {
                                const proxyUrl = proxies[i] + encodeURIComponent(cacheBustUrl);
                                console.log(` Trying proxy ${i + 1}/${proxies.length}...`);
                                response = await fetch(proxyUrl, {
                                    method: 'GET',
                                    mode: 'cors',
                                    cache: 'no-cache'
                                });
                                
                                if (response && response.ok) {
                                    proxySuccess = true;
                                    console.log(' Proxy succeeded!');
                                    break;
                                }
                            } catch (proxyError) {
                                console.warn(` Proxy ${i + 1} failed:`, proxyError.message);
                                continue;
                            }
                        }
                        
                        if (!proxySuccess) {
                            // Last resort: try direct fetch (will likely fail but worth trying)
                            console.warn(' All proxies failed, trying direct CSV fetch...');
                            try {
                                response = await fetch(cacheBustUrl, {
                                    method: 'GET',
                                    mode: 'no-cors'
                                });
                                // If no-cors, we can't verify success, so throw
                                throw new Error('Direct CSV fetch from file:// not possible');
                            } catch (directError) {
                                throw new Error('Cannot load CSV from file:// protocol. All methods failed.');
                            }
                        }
                    } else {
                        response = await fetch(cacheBustUrl);
                    }
                    
                    if (!response || !response.ok) {
                        throw new Error(`Failed to fetch CSV (Status: ${response?.status || 'unknown'})`);
                    }
                    
                    const csvText = await response.text();
                    const parsed = parseCSV(csvText);
                    
                    if (parsed.dataRows && parsed.dataRows.length > 0) {
                            const listings = parsed.dataRows
                                .map(row => mapCSVRowToListing(row))
                            .filter(listing => listing.name); // Only keep listings with names
                        
                        // Extract filter options from listings
                        // Preserve existing filterOptions when loading from CSV
                        // Ensure data is initialized before accessing it
                        if (typeof data === 'undefined' || !data) {
                            data = JSON.parse(JSON.stringify(initialData));
                        }
                        const existingFilterOptions = data.filterOptions || initialData.filterOptions;
                        const sanitizedFilterOptions = sanitizeFilterOptions(existingFilterOptions, listings);
                        
                        const sheetHeaders = sanitizeSheetHeaders(parsed.headers || (data && data.sheetHeaders));
                        
                        data = {
                            listings: listings,
                            filterOptions: sanitizedFilterOptions,
                            sheetHeaders: sheetHeaders
                        };
                        applyFilterOptionCleanup(sanitizedFilterOptions);
                        updateTableHeaderLabelsFromSheet(sheetHeaders);
                        resetUnsavedChanges();
                        resetUnsavedChanges();
                        console.log(' Loaded ' + listings.length + ' listings from Google Sheets (CSV)');
                        
                        // Extract categories from Google Sheets data and ensure they're in TYPE_CATEGORIES
                        // This ensures custom categories from Google Sheets show up even if not in localStorage
                        const categoriesFromData = [...new Set(listings.map(l => l.category).filter(Boolean))];
                        console.log(' Categories found in Google Sheets data:', categoriesFromData);
                        
                        // Load categories from localStorage to get latest emoji/name updates from admin
                        const categoriesFromStorage = loadCategoriesFromStorage();
                        
                        // Add any missing categories from Google Sheets to TYPE_CATEGORIES
                        // Use emoji/name from localStorage (admin) if available
                        let addedCustomCategories = false;
                        categoriesFromData.forEach(function(categoryKey) {
                            if (categoryKey && categoryKey.trim() && !TYPE_CATEGORIES[categoryKey]) {
                                // Check if category exists in localStorage (from admin)
                                let categoryData = null;
                                if (categoriesFromStorage && categoriesFromStorage[categoryKey]) {
                                    categoryData = categoriesFromStorage[categoryKey];
                                    console.log(' Found category in localStorage (from admin):', categoryKey, 'with emoji:', categoryData.emoji);
                                } else if (DEFAULT_TYPE_CATEGORIES[categoryKey]) {
                                    categoryData = DEFAULT_TYPE_CATEGORIES[categoryKey];
                                    console.log(' Found category in DEFAULT_TYPE_CATEGORIES:', categoryKey, 'with emoji:', categoryData.emoji);
                                }
                                
                                // Use data from admin/localStorage if available, otherwise create minimal entry
                                TYPE_CATEGORIES[categoryKey] = categoryData ? {
                                    name: categoryData.name || categoryKey,
                                    emoji: categoryData.emoji || '',
                                    description: categoryData.description || 'Custom category from Google Sheets',
                                    types: categoryData.types || [],
                                    icon: categoryData.icon || ''
                                } : {
                                    name: categoryKey,
                                    emoji: '',
                                    description: 'Custom category from Google Sheets',
                                    types: []
                                };
                                addedCustomCategories = true;
                                console.log(' Added category from Google Sheets to TYPE_CATEGORIES:', categoryKey, 'with emoji:', TYPE_CATEGORIES[categoryKey].emoji || '(none)');
                            } else if (TYPE_CATEGORIES[categoryKey]) {
                                // Category already exists - ALWAYS sync emoji/name from localStorage/admin
                                // Google Sheets only stores the category key, not the emoji
                                if (categoriesFromStorage && categoriesFromStorage[categoryKey]) {
                                    const storageCategory = categoriesFromStorage[categoryKey];
                                    // Always update emoji from admin if it exists (even if currently empty)
                                    if (storageCategory.emoji) {
                                        TYPE_CATEGORIES[categoryKey].emoji = storageCategory.emoji;
                                        console.log(' Synced emoji for category', categoryKey, 'from admin:', storageCategory.emoji);
                                    }
                                    // Always update name from admin if it exists
                                    if (storageCategory.name) {
                                        TYPE_CATEGORIES[categoryKey].name = storageCategory.name;
                                        console.log(' Synced name for category', categoryKey, 'from admin:', storageCategory.name);
                                    }
                                    // Sync other properties too
                                    if (storageCategory.description) {
                                        TYPE_CATEGORIES[categoryKey].description = storageCategory.description;
                                    }
                                    if (storageCategory.icon) {
                                        TYPE_CATEGORIES[categoryKey].icon = storageCategory.icon;
                                    }
                                } else if (DEFAULT_TYPE_CATEGORIES[categoryKey]) {
                                    // Fallback to defaults if not in localStorage
                                    const defaultCategory = DEFAULT_TYPE_CATEGORIES[categoryKey];
                                    if (defaultCategory.emoji && !TYPE_CATEGORIES[categoryKey].emoji) {
                                        TYPE_CATEGORIES[categoryKey].emoji = defaultCategory.emoji;
                                        console.log(' Using default emoji for category', categoryKey, ':', defaultCategory.emoji);
                                    }
                                }
                            }
                        });
                        
                        if (addedCustomCategories) {
                            console.log(' TYPE_CATEGORIES after adding Google Sheets categories:', Object.keys(TYPE_CATEGORIES).length, 'categories');
                            console.log(' Category keys:', Object.keys(TYPE_CATEGORIES));
                        }
                        
                        updateSyncStatus(true, ` Loaded ${listings.length} listings (CSV)`);
                        renderListings();
                        populateAdminFilters();
                        updateStats();
                        return;
                    }
                } catch (error) {
                    console.error(' Error loading from CSV:', error);
                    updateSyncStatus(false, ' CSV fetch failed');
                }
            }
            
            // If both fail, use initial data
            console.log(' Could not load from Google Sheets, using initial data');
            updateSyncStatus(false, ' Using local data only');
            updateTableHeaderLabelsFromSheet((data && data.sheetHeaders) || DEFAULT_TABLE_HEADERS);
            
            // Show warning if running from file://
            if (isFileProtocol) {
                console.error(' IMPORTANT: Opening from file:// protocol has CORS restrictions.');
                console.error('   To fix this, run a local web server:');
                console.error('   1. Open Terminal in this folder');
                console.error('   2. Run: python3 -m http.server 8000');
                console.error('   3. Open: http://localhost:8000/index-sheets.html');
                console.error('   OR host on GitHub Pages / Netlify / etc.');
                
                // Show alert to user
                setTimeout(() => {
                    alert(' CORS Error\n\n' +
                          'Opening HTML files directly (file://) has browser restrictions.\n\n' +
                          'To fix:\n' +
                          '1. Open Terminal in this folder\n' +
                          '2. Run: python3 -m http.server 8000\n' +
                          '3. Open: http://localhost:8000/index-sheets.html\n\n' +
                          'For now, using local data only.');
                }, 1000);
            }
        }
        
        // Reload data from Google Sheets (manual refresh)
        window.reloadFromSheets = async function reloadFromSheets() {
            const confirmed = confirm(' Warning: Reloading from Google Sheets\n\n' +
                                    'This will override all changes you\'ve made in this admin panel.\n' +
                                    'Any unsaved changes will be lost.\n\n' +
                                    'Click OK to reload from Google Sheets and override local changes\n' +
                                    'Click Cancel to keep your local changes');
            if (!confirmed) {
                return;
            }
            // Status will be updated by loadDataFromGoogleSheets()
            await loadDataFromGoogleSheets();
        }
        
        /**
         * Shows a confirmation dialog recommending CSV backup before saving to Sheets
         * @param {number} listingCount - Number of listings to be saved
         * @returns {Promise<boolean>} - true if user confirmed, false if cancelled
         */
        function showBackupConfirmation(listingCount) {
            return new Promise((resolve) => {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
                
                // Create modal dialog
                const modal = document.createElement('div');
                modal.style.cssText = 'background: white; padding: 30px; border-radius: 8px; max-width: 500px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h2 style="margin: 0 0 15px 0; color: #212529; font-size: 24px;"> Backup Recommended</h2>
                        <p style="margin: 0 0 15px 0; color: #6c757d; line-height: 1.6;">
                            You're about to replace <strong>all existing data</strong> in Google Sheets with ${listingCount} listing(s).
                        </p>
                        <p style="margin: 0 0 20px 0; color: #6c757d; line-height: 1.6;">
                            <strong>We recommend downloading a CSV backup first</strong> in case you need to restore the previous data.
                        </p>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;">
                        <button id="backupCancelBtn" style="padding: 10px 20px; border: 1px solid #dee2e6; background: white; color: #212529; border-radius: 18px; cursor: pointer; font-weight: 500;">
                            Cancel
                        </button>
                        <button id="backupDownloadBtn" style="padding: 10px 20px; border: none; background: #4E6B52; color: white; border-radius: 18px; cursor: pointer; font-weight: 600;">
                             Download CSV Backup First
                        </button>
                        <button id="backupProceedBtn" style="padding: 10px 20px; border: none; background: #34a853; color: white; border-radius: 18px; cursor: pointer; font-weight: 600;">
                            Proceed Without Backup
                        </button>
                    </div>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                // Button handlers
                document.getElementById('backupCancelBtn').onclick = () => {
                    document.body.removeChild(overlay);
                    resolve(false);
                };
                
                document.getElementById('backupDownloadBtn').onclick = () => {
                    // Download CSV backup
                    downloadCSV();
                    // Wait a moment for download to start, then proceed
                    setTimeout(() => {
                        document.body.removeChild(overlay);
                        resolve(true);
                    }, 500);
                };
                
                document.getElementById('backupProceedBtn').onclick = () => {
                    document.body.removeChild(overlay);
                    resolve(true);
                };
                
                // Close on overlay click
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        resolve(false);
                    }
                };
            });
        }
        
        window.saveAllToSheets = async function saveAllToSheets() {
            if (!GOOGLE_APPS_SCRIPT_URL || GOOGLE_APPS_SCRIPT_URL.includes('YOUR_SCRIPT_ID')) {
                alert(' Google Sheets not configured. Please set up your Apps Script URL.');
                return;
            }
            
            if (!data.listings || data.listings.length === 0) {
                alert(' No listings to save.');
                return;
            }
            
            // Show confirmation dialog asking if they want to download CSV backup first
            const wantBackup = confirm(' You are about to replace ALL data in Google Sheets.\n\n' +
                                 'Would you like to download a CSV backup first?\n\n' +
                                 'Click OK to download CSV backup before saving\n' +
                                 'Click Cancel to skip backup and continue');
            
            if (wantBackup) {
                // Download CSV backup
                downloadCSV();
                // Wait a moment for download to start
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            // Now ask for confirmation to overwrite
            const confirmed = confirm(' Final Confirmation\n\n' +
                                    `You are about to replace all data in Google Sheets with ${data.listings.length} listing(s).\n\n` +
                                    'This action cannot be undone.\n\n' +
                                    'Click OK to save all listings to Google Sheets and overwrite existing data\n' +
                                    'Click Cancel to abort and keep Google Sheets unchanged');
            if (!confirmed) {
                return; // User cancelled
            }
            
            // Show "in progress" status
            updateSyncStatus(true, ` Saving ${data.listings.length} listings...`);
            
            try {
                // Verify categories are in listings before saving
                const listingsWithCategories = data.listings.map(function(listing) {
                    // Ensure category field is included
                    const listingCopy = Object.assign({}, listing);
                    if (!('category' in listingCopy)) {
                        console.warn(' Listing missing category field:', listing.name);
                        listingCopy.category = listing.category || '';
                    }
                    console.log(' Saving listing:', listing.name, '- Category:', listingCopy.category);
                    return listingCopy;
                });
                
                // Log category summary before saving
                const categoriesBeingSaved = [...new Set(listingsWithCategories.map(l => l.category).filter(Boolean))];
                console.log(' Categories being saved to Google Sheets:', categoriesBeingSaved);
                
                // Send all listings at once with a "replaceAll" action
                // This tells the Apps Script to clear the sheet and replace with these listings
                const postData = JSON.stringify({
                    action: 'replaceAllListings',
                    listings: listingsWithCategories
                });
                
                let result = { success: false };
                
                // Try direct fetch first
                try {
                    const response = await fetch(GOOGLE_APPS_SCRIPT_URL, {
                        method: 'POST',
                        mode: 'cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: postData
                    });
                    
                    try {
                        const responseText = await response.text();
                        result = responseText ? JSON.parse(responseText) : { success: true };
                    } catch (e) {
                        result = { success: true }; // Assume success if no response
                    }
                } catch (corsError) {
                    console.log('Direct POST failed due to CORS, trying no-cors mode...');
                    
                    // Try no-cors mode - sends request but can't read response
                    try {
                        await fetch(GOOGLE_APPS_SCRIPT_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            body: postData  // Send raw JSON string
                        });
                        
                        // With no-cors, we can't read response, so assume success
                        result = { success: true };
                        console.log('Sent via no-cors mode (can\'t verify response)');
                    } catch (e) {
                        console.error('No-cors also failed:', e);
                        result = { success: false, error: 'Failed to connect to Google Sheets' };
                        alert(' Unable to save to Google Sheets. Changes saved locally only.\n\n' +
                              'This may be due to CORS restrictions. Your Apps Script may need to be configured to allow CORS.');
                    }
                }
                
                if (result.success) {
            updateSyncStatus(true, ` Replaced all data in Google Sheets with ${data.listings.length} listings`);
            resetUnsavedChanges();
                    alert(` Successfully saved all ${data.listings.length} listings to Google Sheets!`);
                } else {
                    updateSyncStatus(false);
                    alert(' Error saving to Google Sheets: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error saving to Google Sheets:', error);
                updateSyncStatus(false, ' Save failed');
                alert(' Error saving to Google Sheets: ' + error.message);
            }
        }
        
        // Store current sort value
        let currentAdminSort = 'name-asc';
        
        // Error Console Functions
        function showErrorConsole() {
            document.getElementById('errorConsoleSection').style.display = 'block';
            document.body.classList.add('error-console-open');
            validateListings();
        }
        
        function hideErrorConsole() {
            document.getElementById('errorConsoleSection').style.display = 'none';
            document.body.classList.remove('error-console-open');
        }
        
        async function validateListings() {
            if (!data || !data.listings) {
                console.warn('No data available to validate');
                return;
            }
            
            const errors = [];
            const slugCounts = {};
            
            // First pass: collect slugs for duplicate checking
            data.listings.forEach(function(listing, index) {
                // Check slug - be lenient with what we accept
                const slugValue = listing.slug;
                
                // Accept slug if it exists and is not null/undefined/empty
                // Even if it's a number or matches ID, it's still a valid slug
                if (slugValue !== undefined && slugValue !== null && slugValue !== '') {
                    const slugStr = String(slugValue).trim();
                    if (slugStr !== '') {
                        if (!slugCounts[slugStr]) {
                            slugCounts[slugStr] = [];
                        }
                        slugCounts[slugStr].push({ index: index, listing: listing });
                    }
                }
            });
            
            // Check for duplicate slugs
            Object.keys(slugCounts).forEach(function(slug) {
                if (slugCounts[slug].length > 1) {
                    slugCounts[slug].forEach(function(item) {
                        errors.push({
                            type: 'duplicate-slug',
                            severity: 'error',
                            message: 'Duplicate slug: "' + slug + '"',
                            listing: item.listing,
                            index: item.index
                        });
                    });
                }
            });
            
            // Check each listing for issues
            data.listings.forEach(function(listing, index) {
                // Required fields - only check name and slug
                if (!listing.name || listing.name.trim() === '') {
                    errors.push({
                        type: 'missing-field',
                        severity: 'error',
                        message: 'Missing required field: name',
                        listing: listing,
                        index: index
                    });
                }
                
                // Check for missing slug - slugs are needed for View Details URLs
                const slugValue = listing.slug;
                if (!slugValue || slugValue === null || slugValue === '' || String(slugValue).trim() === '') {
                    errors.push({
                        type: 'missing-slug',
                        severity: 'warning',
                        message: 'Missing slug: "' + (listing.name || 'Unnamed listing') + '" will use auto-generated slug from name',
                        listing: listing,
                        index: index
                    });
                }
                
                // Validate dates
                if (listing.publishedDate && listing.publishedDate.trim() !== '') {
                    // Normalize the date before validation
                    const normalizedDate = normalizeDate(listing.publishedDate);
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(normalizedDate)) {
                        errors.push({
                            type: 'invalid-date',
                            severity: 'warning',
                            message: 'Invalid date format for publishedDate: "' + listing.publishedDate + '" (expected YYYY-MM-DD)',
                            listing: listing,
                            index: index
                        });
                    } else if (normalizedDate !== listing.publishedDate) {
                        // Update the listing with normalized date
                        listing.publishedDate = normalizedDate;
                    }
                }
                
                if (listing.modifiedDate && listing.modifiedDate.trim() !== '') {
                    // Normalize the date before validation
                    const normalizedDate = normalizeDate(listing.modifiedDate);
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(normalizedDate)) {
                        errors.push({
                            type: 'invalid-date',
                            severity: 'warning',
                            message: 'Invalid date format for modifiedDate: "' + listing.modifiedDate + '" (expected YYYY-MM-DD)',
                            listing: listing,
                            index: index
                        });
                    } else if (normalizedDate !== listing.modifiedDate) {
                        // Update the listing with normalized date
                        listing.modifiedDate = normalizedDate;
                    }
                }
                
                // Validate status
                if (listing.status && listing.status.trim() !== '') {
                    const status = listing.status.toLowerCase();
                    if (status !== 'publish' && status !== 'draft' && status !== 'private') {
                        errors.push({
                            type: 'invalid-status',
                            severity: 'warning',
                            message: 'Invalid status: "' + listing.status + '" (expected publish/draft/private)',
                            listing: listing,
                            index: index
                        });
                    }
                }
                
                // Validate featured field
                if (listing.featured !== undefined && listing.featured !== null && listing.featured !== '' && listing.featured !== 'TRUE' && listing.featured !== 'FALSE' && listing.featured !== true && listing.featured !== false) {
                    errors.push({
                        type: 'invalid-featured',
                        severity: 'warning',
                        message: 'Invalid featured value: "' + listing.featured + '" (expected TRUE/FALSE)',
                        listing: listing,
                        index: index
                    });
                }
                
                // Check URLs for validity (basic format check)
                const urlFields = ['website', 'image1', 'image2', 'image3', 'directionsLink', 'externalWebsite'];
                urlFields.forEach(function(field) {
                    if (listing[field] && listing[field].trim() !== '') {
                        const url = listing[field].trim();
                        // Basic URL validation
                        if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('/')) {
                            errors.push({
                                type: 'invalid-url',
                                severity: 'warning',
                                message: 'Invalid URL format for ' + field + ': "' + url + '"',
                                listing: listing,
                                index: index
                            });
                        }
                        
                        // Ensure primary images come from ImageKit for Framer performance
                        const isImageField = (field === 'image1' || field === 'image2' || field === 'image3');
                        if (isImageField && url.startsWith('http') && !url.includes('ik.imagekit.io/')) {
                            errors.push({
                                type: 'non-imagekit-image',
                                severity: 'warning',
                                message: field + ' is not hosted on ImageKit. Convert before importing: "' + url + '"',
                                listing: listing,
                                index: index
                            });
                        }
                    }
                });
            });
            
            // Display errors first (synchronous checks)
            displayErrors(errors);
            
            // Check for broken image URLs (async - check ALL images)
            const imageErrors = [];
            const checkedImages = new Set();
            
            // Show loading state
            const consoleContent = document.getElementById('errorConsoleContent');
            const loadingHtml = consoleContent.innerHTML + '<div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 4px; color: #1976d2;"><strong>Checking all images for 404 errors...</strong> <span id="imageCheckProgress">0</span> images checked. This may take a moment.</div>';
            consoleContent.innerHTML = loadingHtml;
            
            // Collect ALL images to check from all listings
            const imagesToCheck = [];
            data.listings.forEach(function(listing, index) {
                const imageFields = ['image1', 'image2', 'image3'];
                
                imageFields.forEach(function(field) {
                    const imageUrl = listing[field];
                    if (imageUrl && imageUrl.trim() !== '' && !checkedImages.has(imageUrl)) {
                        checkedImages.add(imageUrl);
                        try {
                            const url = new URL(imageUrl);
                            if (url.protocol === 'http:' || url.protocol === 'https:') {
                                imagesToCheck.push({
                                    url: imageUrl,
                                    listing: listing,
                                    index: index,
                                    field: field
                                });
                            }
                        } catch (e) {
                            // Invalid URL format - already caught above
                        }
                    }
                });
            });
            
            // Check images using Image object - this should detect 404s
            const checkImage = function(imageInfo) {
                return new Promise(function(resolve) {
                    const img = new Image();
                    let resolved = false;
                    const timeout = 12000; // 12 second timeout
                    
                    // Set up timeout first
                    const timeoutId = setTimeout(function() {
                        if (!resolved) {
                            resolved = true;
                            resolve({
                                error: {
                                    type: 'broken-image',
                                    severity: 'error',
                                    message: 'Image load timeout (12s): ' + imageInfo.url,
                                    listing: imageInfo.listing,
                                    index: imageInfo.index,
                                    field: imageInfo.field
                                }
                            });
                        }
                    }, timeout);
                    
                    // Image loaded successfully
                    img.onload = function() {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            resolve({ error: null });
                        }
                    };
                    
                    // Image failed to load (404, network error, etc.)
                    img.onerror = function() {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            resolve({
                                error: {
                                    type: 'broken-image',
                                    severity: 'error',
                                    message: '404 or broken image: ' + imageInfo.url,
                                    listing: imageInfo.listing,
                                    index: imageInfo.index,
                                    field: imageInfo.field
                                }
                            });
                        }
                    };
                    
                    // Start loading the image
                    // Add cache busting to ensure fresh check
                    const separator = imageInfo.url.includes('?') ? '&' : '?';
                    img.src = imageInfo.url + separator + '_check=' + Date.now();
                });
            };
            
            // Check images in parallel batches (10 at a time)
            (async function() {
                console.log(' Starting image validation for', imagesToCheck.length, 'images');
                const batchSize = 10;
                let checkedCount = 0;
                
                for (let i = 0; i < imagesToCheck.length; i += batchSize) {
                    const batch = imagesToCheck.slice(i, i + batchSize);
                    const batchPromises = batch.map(function(imageInfo) {
                        return checkImage(imageInfo).then(function(result) {
                            checkedCount++;
                            // Update progress
                            const progressEl = document.getElementById('imageCheckProgress');
                            if (progressEl) {
                                progressEl.textContent = checkedCount + ' / ' + imagesToCheck.length;
                            }
                            
                            // Log errors for debugging
                            if (result && result.error) {
                                console.log(' Broken image found:', result.error.message, 'for listing:', result.error.listing.name);
                            }
                            
                            return result;
                        });
                    });
                    
                    const batchResults = await Promise.all(batchPromises);
                    batchResults.forEach(function(result) {
                        if (result && result.error) {
                            imageErrors.push(result.error);
                        }
                    });
                }
                
                console.log(' Image validation complete. Found', imageErrors.length, 'broken images');
                
                // Merge image errors with other errors and re-display
                errors.push.apply(errors, imageErrors);
                displayErrors(errors);
            })();
        }
        
        function displayErrors(errors) {
            const consoleContent = document.getElementById('errorConsoleContent');
            const consoleTitle = document.getElementById('errorConsoleTitle');
            
            if (errors.length === 0) {
                consoleContent.innerHTML = '<div style="text-align: center; padding: 40px; color: #28a745;"><p style="font-size: 18px; font-weight: 600;"> No errors found!</p><p style="margin-top: 10px; color: #666;">All listings are ready for Framer Google Sheets import.</p></div>';
                consoleTitle.textContent = 'Framer Import Error Console - No Errors';
                return;
            }
            
            // Sort errors by severity (errors first, then warnings)
            errors.sort(function(a, b) {
                if (a.severity === 'error' && b.severity !== 'error') return -1;
                if (a.severity !== 'error' && b.severity === 'error') return 1;
                return 0;
            });
            
            // Group errors by type
            const errorsByType = {};
            errors.forEach(function(error) {
                if (!errorsByType[error.type]) {
                    errorsByType[error.type] = [];
                }
                errorsByType[error.type].push(error);
            });
            
            let html = '<div style="margin-bottom: 20px;"><strong style="color: #dc3545; font-size: 16px;">Total Issues: ' + errors.length + '</strong></div>';
            
            Object.keys(errorsByType).forEach(function(type) {
                const typeErrors = errorsByType[type];
                const severity = typeErrors[0].severity;
                const severityColor = severity === 'error' ? '#dc3545' : '#ffc107';
                const severityIcon = severity === 'error' ? '' : '';
                
                html += '<div style="margin-bottom: 20px; border-left: 4px solid ' + severityColor + '; padding-left: 15px;">';
                html += '<h4 style="margin: 0 0 10px 0; color: ' + severityColor + ';">' + severityIcon + ' ' + type.replace(/-/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }) + ' (' + typeErrors.length + ')</h4>';
                
                typeErrors.forEach(function(error) {
                    const listingName = error.listing.name || 'Unnamed Listing';
                    
                    html += '<div style="background: #f8f9fa; padding: 12px; margin: 8px 0; border-radius: 4px; cursor: pointer; transition: background 0.2s;" ';
                    html += 'onmouseover="this.style.background=\'#e9ecef\'" onmouseout="this.style.background=\'#f8f9fa\'" ';
                    html += 'onclick="navigateToListing(' + error.index + ')">';
                    html += '<div style="font-weight: 600; color: #333; margin-bottom: 4px;">' + listingName + '</div>';
                    html += '<div style="color: #666; font-size: 14px;">' + error.message + '</div>';
                    html += '</div>';
                });
                
                html += '</div>';
            });
            
            consoleContent.innerHTML = html;
            consoleTitle.textContent = 'Framer Import Error Console - ' + errors.length + ' Issue' + (errors.length !== 1 ? 's' : '');
        }
        
        function navigateToListing(index) {
            // Find the listing card by ID or slug
            const listing = data.listings[index];
            if (!listing) return;
            
            // Scroll to the listings grid
            const grid = document.getElementById('listingsGrid');
            if (!grid) return;
            
            // Find the card element for this listing by data attribute or by position
            const cards = grid.querySelectorAll('.flip-card');
            let targetCard = null;
            
            // Try to find by data attribute if it exists
            cards.forEach(function(card) {
                const cardId = card.getAttribute('data-id');
                const cardSlug = card.getAttribute('data-slug');
                if (cardId === listing.id || cardSlug === listing.slug) {
                    targetCard = card;
                }
            });
            
            // Fallback: try by index
            if (!targetCard && cards[index]) {
                targetCard = cards[index];
            }
            
            if (targetCard) {
                targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Highlight the card
                targetCard.style.boxShadow = '0 0 0 4px #dc3545';
                targetCard.style.transition = 'box-shadow 0.3s';
                targetCard.style.zIndex = '1000';
                setTimeout(function() {
                    targetCard.style.boxShadow = '';
                    targetCard.style.zIndex = '';
                }, 2000);
            } else {
                // Card not found - might be filtered out, so clear filters and search for it
                const searchInput = document.getElementById('adminSearchInput');
                if (searchInput && listing.name) {
                    // Clear all filters
                    if (document.getElementById('adminTypeFilter')) {
                        document.getElementById('adminTypeFilter').value = '';
                    }
                    if (document.getElementById('adminAreaFilter')) {
                        document.getElementById('adminAreaFilter').value = '';
                    }
                    if (document.getElementById('adminAmenityFilter')) {
                        document.getElementById('adminAmenityFilter').value = '';
                    }
                    searchInput.value = listing.name;
                    filterListings();
                    // Try again after a short delay
                    setTimeout(function() {
                        navigateToListing(index);
                    }, 300);
                }
            }
        }
        
        function renderListings(listings) {
            if (!listings) listings = data.listings;
            const grid = document.getElementById('listingsGrid');
            grid.innerHTML = '';
            
            // Sort listings based on current sort value
            const sortedListings = listings.slice().sort(function(a, b) {
                switch(currentAdminSort) {
                    case 'name-asc':
                        const aName = (a.name || '').toLowerCase();
                        const bName = (b.name || '').toLowerCase();
                        return aName.localeCompare(bName);
                    case 'name-desc':
                        const aNameDesc = (a.name || '').toLowerCase();
                        const bNameDesc = (b.name || '').toLowerCase();
                        return bNameDesc.localeCompare(aNameDesc);
                    case 'area-asc':
                        const aArea = (a.area || '').toLowerCase();
                        const bArea = (b.area || '').toLowerCase();
                        return aArea.localeCompare(bArea);
                    case 'type-asc':
                        const aType = (a.type || '').toLowerCase();
                        const bType = (b.type || '').toLowerCase();
                        return aType.localeCompare(bType);
                    default:
                        const aNameDefault = (a.name || '').toLowerCase();
                        const bNameDefault = (b.name || '').toLowerCase();
                        return aNameDefault.localeCompare(bNameDefault);
                }
            });
            
            sortedListings.forEach(function(listing) {
                const card = document.createElement('div');
                card.className = 'flip-card';
                // Add data attributes for navigation
                if (listing.id) {
                    card.setAttribute('data-id', listing.id.toString());
                }
                if (listing.slug) {
                    card.setAttribute('data-slug', listing.slug);
                }
                
                // Flip functionality on click (but not when clicking buttons or links)
                card.onclick = function(e) {
                    // Don't flip if clicking on links or buttons inside
                    if (e.target.tagName === 'A' || e.target.tagName === 'BUTTON' || e.target.closest('a') || e.target.closest('button')) {
                        return;
                    }
                    
                    // Close all other flipped cards
                    document.querySelectorAll('.flip-card.flipped').forEach(function(otherCard) {
                        if (otherCard !== card) {
                            otherCard.classList.remove('flipped');
                        }
                    });
                    
                    this.classList.toggle('flipped');
                };
                
                const inner = document.createElement('div');
                inner.className = 'flip-card-inner';
                
                // Front of card
                const front = document.createElement('div');
                front.className = 'flip-card-front';
                
                // Create scrollable image container
                const imgContainer = document.createElement('div');
                imgContainer.className = 'card-front-image-scroll';
                imgContainer.style.cssText = 'position: relative; width: 100%; height: 240px; overflow-x: auto; overflow-y: hidden; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; scrollbar-width: none; flex-shrink: 0;';
                imgContainer.style.setProperty('-ms-overflow-style', 'none');
                
                const imgWrapper = document.createElement('div');
                imgWrapper.style.cssText = 'position: absolute; top: 0; left: 0; width: auto; height: 100%; display: flex;';
                
                // Count images
                const imageCount = (listing.image1 ? 1 : 0) + (listing.image2 ? 1 : 0) + (listing.image3 ? 1 : 0);
                
                // Add image1 if it exists
                if (listing.image1) {
                    const img1 = document.createElement('img');
                    img1.src = getAdminImageUrl(listing.image1);
                    img1.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    img1.onerror = function() {
                        this.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    };
                    imgWrapper.appendChild(img1);
                }
                
                // Add image2 if it exists
                if (listing.image2) {
                    const img2 = document.createElement('img');
                    img2.src = getAdminImageUrl(listing.image2);
                    img2.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    img2.onerror = function() {
                        this.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    };
                    imgWrapper.appendChild(img2);
                }
                
                // Add image3 if it exists
                if (listing.image3) {
                    const img3 = document.createElement('img');
                    img3.src = getAdminImageUrl(listing.image3);
                    img3.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    img3.onerror = function() {
                        this.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    };
                    imgWrapper.appendChild(img3);
                }
                
                // If no images, add fallback
                if (imageCount === 0) {
                    const img = document.createElement('img');
                    img.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    img.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    imgWrapper.appendChild(img);
                }
                
                // Set wrapper and image widths to accommodate all images side by side
                if (imageCount > 1) {
                    setTimeout(function() {
                        const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                        if (containerWidth > 0) {
                            imgWrapper.style.width = (containerWidth * imageCount) + 'px';
                            const images = imgWrapper.querySelectorAll('img');
                            images.forEach(function(img) {
                                img.style.width = containerWidth + 'px';
                                img.style.minWidth = containerWidth + 'px';
                                img.style.maxWidth = containerWidth + 'px';
                                img.style.height = '240px';
                            });
                        }
                    }, 10);
                }
                
                imgContainer.appendChild(imgWrapper);
                front.appendChild(imgContainer);
                
                // Add scroll arrow if there are multiple images
                if (imageCount > 1) {
                    const totalImages = imageCount;
                    
                    // Function to get current index based on scroll position
                    const getCurrentIndex = function() {
                        const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                        if (containerWidth === 0) return 0;
                        const scrollLeft = imgContainer.scrollLeft || 0;
                        // Round to nearest index
                        return Math.round(scrollLeft / containerWidth);
                    };
                    
                    // Single right arrow that cycles forward through images
                    const rightArrow = document.createElement('div');
                    rightArrow.className = 'scroll-arrow scroll-arrow-right';
                    
                    rightArrow.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                        if (containerWidth === 0) return;
                        
                        let currentIndex = getCurrentIndex();
                        // Cycle forward (next image)
                        currentIndex = (currentIndex + 1) % totalImages;
                        imgContainer.scrollTo({ left: currentIndex * containerWidth, behavior: 'smooth' });
                    });
                    
                    // Position arrow at center of image container (same approach as frontpage_framer.html)
                    setTimeout(function() {
                        const containerHeight = imgContainer.offsetHeight || 240;
                        if (containerHeight > 0) {
                            // Use container height divided by 2 for vertical center
                            // This matches frontpage_framer.html which uses containerWidth / 2 for square containers
                            // Use setProperty with 'important' to override CSS 'top: 50% !important'
                            rightArrow.style.setProperty('top', (containerHeight / 2) + 'px', 'important');
                            rightArrow.style.setProperty('transform', 'translateY(-50%)', 'important');
                        }
                    }, 10);
                    
                    // Append to front (not imgContainer) so it doesn't scroll with images
                    front.appendChild(rightArrow);
                }
                
                // Featured badge
                if (listing.featured) {
                    const badge = document.createElement('div');
                    badge.className = 'featured-badge';
                    badge.textContent = 'FEATURED';
                    badge.style.cssText = 'position: absolute; top: 10px; left: 10px; z-index: 10;';
                    front.appendChild(badge);
                }
                
                // Card content - allow it to grow to show all content
                const cardContent = document.createElement('div');
                cardContent.style.cssText = 'padding: 20px 0px 0px 0px; display: flex; flex-direction: column; flex: 1 1 auto;';
                
                // Build contact info HTML with icons
                const mapUrl = listing.address ? (listing.directionsLink && listing.directionsLink.trim() 
                    ? listing.directionsLink 
                    : 'https://www.google.com/maps/search/?api=1&query=' + encodeURIComponent(listing.address)) : '';
                
                // Format modified date for inline display
                const formatModifiedDate = function(dateStr) {
                    if (!dateStr) return '';
                    try {
                        const date = new Date(dateStr);
                        if (isNaN(date.getTime())) return '';
                        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        return months[date.getMonth()] + ' ' + date.getDate();
                    } catch (e) {
                        return '';
                    }
                };
                const modifiedDateFormatted = formatModifiedDate(listing.modifiedDate);
                const authorWithDate = listing.authorName + (modifiedDateFormatted ? ' <span style="color: var(--text-secondary); font-weight: normal;">(edited ' + modifiedDateFormatted + ')</span>' : '');
                
                const contactHtml = '<div class="listing-contact">' +
                    // Author with icon and modified date inline
                    (listing.authorName ? 
                    '<div class="card-info-item" onclick="event.stopPropagation();">' +
                    '<div class="card-info-icon">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">' +
                    '<path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />' +
                    '</svg>' +
                    '</div>' +
                    '<div class="card-info-text">' + authorWithDate + '</div>' +
                    '</div>' : '') +
                    // Published Date
                    (listing.publishedDate ? 
                    '<div class="card-info-item" onclick="event.stopPropagation();">' +
                    '<div class="card-info-icon">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">' +
                    '<path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0v-7.5A2.25 2.25 0 015.25 9h13.5A2.25 2.25 0 0121 11.25v7.5" />' +
                    '</svg>' +
                    '</div>' +
                    '<div class="card-info-text">Published: ' + listing.publishedDate + '</div>' +
                    '</div>' : '') +
                    // Phone with icon
                    (listing.phone ? 
                    '<a href="tel:' + listing.phone.replace(/[^0-9+]/g, '') + '" class="card-info-item" onclick="event.stopPropagation();">' +
                    '<div class="card-info-icon">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">' +
                    '<path stroke-linecap="round" stroke-linejoin="round" d="M2.25 6.75c0 8.284 6.716 15 15 15h2.25a2.25 2.25 0 002.25-2.25v-1.372c0-.516-.351-.966-.852-1.091l-4.423-1.106c-.44-.11-.902.055-1.173.417l-.97 1.293c-.282.376-.769.542-1.21.38a12.035 12.035 0 01-7.143-7.143c-.162-.441.004-.928.38-1.21l1.293-.97c.363-.271.527-.734.417-1.173L6.963 3.102a1.125 1.125 0 00-1.091-.852H4.5A2.25 2.25 0 002.25 4.5v2.25z" />' +
                    '</svg>' +
                    '</div>' +
                    '<div class="card-info-text">' + listing.phone + '</div>' +
                    '</a>' : '') +
                    // Address with icon (clickable to map)
                    (listing.address ? 
                    '<a href="' + mapUrl + '" target="_blank" class="card-info-item" onclick="event.stopPropagation();">' +
                    '<div class="card-info-icon">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">' +
                    '<path stroke-linecap="round" stroke-linejoin="round" d="M15 10.5a3 3 0 11-6 0 3 3 0 016 0z" />' +
                    '<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z" />' +
                    '</svg>' +
                    '</div>' +
                    '<div class="card-info-text">' + listing.address + '</div>' +
                    '</a>' : '') +
                    // Website with icon
                    (listing.website ? 
                    '<a href="' + listing.website + '" target="_blank" class="card-info-item" onclick="event.stopPropagation();">' +
                    '<div class="card-info-icon">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">' +
                    '<path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 008.716-6.747M12 21a9.004 9.004 0 01-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 017.843 4.582M12 3a8.997 8.997 0 00-7.843 4.582m15.686 0A11.953 11.953 0 0112 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0121 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0112 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 013 12c0-1.605.42-3.113 1.157-4.418" />' +
                    '</svg>' +
                    '</div>' +
                    '<div class="card-info-text">' + listing.website + '</div>' +
                    '</a>' : '') +
                    '</div>';
                
                // Description with up to 5 lines
                const descriptionHTML = listing.description ? 
                    '<p class="listing-desc">' + listing.description + '</p>' :
                    '<p class="listing-desc">No description</p>';
                
                // Get category name for display
                const categoryKey = getCategoryForType(listing.type, listing);
                const categoryName = categoryKey && TYPE_CATEGORIES && TYPE_CATEGORIES[categoryKey] ? TYPE_CATEGORIES[categoryKey].name : '';
                const categoryHTML = categoryName ? 
                    '<div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">' + categoryName + '</div>' : '';
                
                cardContent.innerHTML = 
                    categoryHTML +
                    '<h3 style="font-size: 18px; margin-bottom: 8px; color: var(--text-primary);">' + listing.name + '</h3>' +
                    '<div class="listing-meta" style="display: flex; gap: 10px; margin-bottom: 12px; flex-wrap: wrap;">' +
                    '<span class="badge badge-type ' + getIconClass(listing.type, listing) + '" data-type="' + listing.type + '" onclick="filterByAdminBadge(event, \'type\', \'' + listing.type.replace(/'/g, "\\'") + '\')" style="cursor: pointer;">' + listing.type + '</span>' +
                    '<span class="badge badge-area" data-area="' + listing.area + '" onclick="filterByAdminBadge(event, \'area\', \'' + listing.area.replace(/'/g, "\\'") + '\')" style="cursor: pointer;">' + listing.area + '</span>' +
                    '</div>' +
                    descriptionHTML +
                    (listing.amenities && listing.amenities.length > 0 ? 
                    '<div class="listing-amenities">' +
                    listing.amenities.map(function(a) {
                        const escapedAmenity = a.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        return '<span class="amenity" onclick="filterByAdminBadge(event, \'amenity\', \'' + escapedAmenity + '\')" style="cursor: pointer;">' + a + '</span>';
                    }).join('') +
                    '</div>' : '') +
                    contactHtml;
                
                // Edit and Delete buttons
                const actions = document.createElement('div');
                actions.className = 'listing-actions';
                
                const editBtn = document.createElement('button');
                editBtn.className = 'btn-edit';
                editBtn.textContent = 'Edit';
                editBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    editListing(listing.id);
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn-delete';
                
                // Check if this listing is waiting for confirmation
                if (deleteConfirmId === listing.id) {
                    deleteBtn.textContent = 'Confirm Delete?';
                    deleteBtn.style.background = '#dc2626';
                } else {
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.style.background = '#E3795C';
                }
                
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    deleteListing(listing.id);
                });
                
                const duplicateBtn = document.createElement('button');
                duplicateBtn.className = 'btn-duplicate';
                duplicateBtn.textContent = 'Duplicate';
                duplicateBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    duplicateListing(listing.id);
                });
                
                actions.appendChild(editBtn);
                actions.appendChild(duplicateBtn);
                actions.appendChild(deleteBtn);
                cardContent.appendChild(actions);
                front.appendChild(cardContent);
                
                // Back of card
                const back = document.createElement('div');
                back.className = 'flip-card-back';
                
                // Build description sections with labels for back of card
                const backDescriptionHTML = listing.description && listing.description.trim() ? 
                    '<div style="margin-bottom: 15px;">' +
                    '<h4 style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Description</h4>' +
                    '<p style="font-size: 14px; color: var(--text-secondary); line-height: 1.6; white-space: pre-wrap; margin: 0;">' + listing.description + '</p>' +
                    '</div>' : '';
                
                const backDetailedDescriptionHTML = listing.detailedDescription && listing.detailedDescription.trim() ? 
                    '<div style="margin-bottom: 15px;">' +
                    '<h4 style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Detailed Description</h4>' +
                    '<p style="font-size: 14px; color: var(--text-secondary); line-height: 1.6; white-space: pre-wrap; margin: 0;">' + listing.detailedDescription + '</p>' +
                    '</div>' : '';
                
                const sanitizedCustomHtml = listing.customHtml && listing.customHtml.trim() ? sanitizeCustomHtml(listing.customHtml) : '';
                const backCustomHtmlPreview = sanitizedCustomHtml ?
                    '<div class="custom-html-preview">' +
                    '<div class="custom-html-preview-title">Custom HTML Preview</div>' +
                    '<div class="custom-html-render">' + sanitizedCustomHtml + '</div>' +
                    '</div>' : '';
                
                back.innerHTML = 
                    '<button class="flip-close-btn" onclick="event.stopPropagation(); this.closest(\'.flip-card\').classList.remove(\'flipped\');">&times;</button>' +
                    '<h3 style="font-size: 22px; margin-bottom: 12px; color: var(--text-primary);">' + listing.name + '</h3>' +
                    backDescriptionHTML +
                    backDetailedDescriptionHTML +
                    backCustomHtmlPreview;
                
                // Add Edit and Delete buttons to the back of the card
                const backActions = document.createElement('div');
                backActions.className = 'listing-actions';
                
                const backEditBtn = document.createElement('button');
                backEditBtn.className = 'btn-edit';
                backEditBtn.textContent = 'Edit';
                backEditBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    editListing(listing.id);
                });
                
                const backDeleteBtn = document.createElement('button');
                backDeleteBtn.className = 'btn-delete';
                
                // Check if this listing is waiting for confirmation
                if (deleteConfirmId === listing.id) {
                    backDeleteBtn.textContent = 'Confirm Delete?';
                    backDeleteBtn.style.background = '#dc2626';
                } else {
                    backDeleteBtn.textContent = 'Delete';
                    backDeleteBtn.style.background = '#E3795C';
                }
                
                backDeleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    deleteListing(listing.id);
                });
                
                const backDuplicateBtn = document.createElement('button');
                backDuplicateBtn.className = 'btn-duplicate';
                backDuplicateBtn.textContent = 'Duplicate';
                backDuplicateBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    duplicateListing(listing.id);
                });
                
                backActions.appendChild(backEditBtn);
                backActions.appendChild(backDuplicateBtn);
                backActions.appendChild(backDeleteBtn);
                back.appendChild(backActions);
                
                inner.appendChild(front);
                inner.appendChild(back);
                card.appendChild(inner);
                grid.appendChild(card);
            });
            
            updateStats(listings);
            
            // Update listings count display
            const countDisplay = document.getElementById('listingsCount');
            if (countDisplay) {
                const count = listings.length;
                countDisplay.textContent = count === 1 ? '1 listing' : count + ' listings';
            }
            
            // Update map markers with the listings
            if (typeof updateMapMarkers === 'function') {
                updateMapMarkers(listings);
            }
        }
        
        function updateStats(listings) {
            if (!listings) listings = data.listings;
            document.getElementById('totalListings').textContent = listings.length;
            document.getElementById('featuredCount').textContent = listings.filter(function(l) { return l.featured; }).length;
            const uniqueAreas = {};
            listings.forEach(function(l) { uniqueAreas[l.area] = true; });
            document.getElementById('areasCount').textContent = Object.keys(uniqueAreas).length;
            const uniqueTypes = {};
            listings.forEach(function(l) { uniqueTypes[l.type] = true; });
            document.getElementById('typesCount').textContent = Object.keys(uniqueTypes).length;
        }
        
        let currentAdminTypeFilter = ''; // Track which category is currently active (empty string = "All Types")
        
        function filterListings() {
            const searchTerm = document.getElementById('adminSearchInput').value.toLowerCase().trim();
            const areaFilter = document.getElementById('adminAreaFilter').value;
            const amenityFilter = document.getElementById('adminAmenityFilter').value;
            
            const filtered = data.listings.filter(function(listing) {
                // Build comprehensive searchable text from all listing fields
                const searchableText = [
                    listing.name || '',
                    listing.slug || '',
                    listing.id || '',
                    listing.type || '',
                    listing.category || '',
                    listing.area || '',
                    listing.description || '',
                    listing.detailedDescription || '',
                    listing.customHtml || '',
                    listing.address || '',
                    listing.phone || '',
                    listing.website || '',
                    listing.authorName || '',
                    listing.publishedDate || '',
                    listing.modifiedDate || '',
                    listing.directionsLink || '',
                    listing.googleMapsUrl || '',
                    listing.image1Desc || '',
                    listing.image2Desc || '',
                    listing.image3Desc || '',
                    Array.isArray(listing.amenities) ? listing.amenities.join(' ') : (listing.amenities || '')
                ].join(' ').toLowerCase();
                
                const matchesSearch = !searchTerm || searchableText.indexOf(searchTerm) > -1;
                // Check if type matches - either direct match or category match
                let matchesType = true;
                if (currentAdminTypeFilter) {
                    // Check if it's a category key
                    if (TYPE_CATEGORIES && TYPE_CATEGORIES[currentAdminTypeFilter]) {
                        // Use getCategoryForType to determine the listing's category
                        // This handles both automatic type mapping and category overrides
                        const listingCategory = getCategoryForType(listing.type, listing);
                        matchesType = listingCategory === currentAdminTypeFilter;
                        
                        // Debug logging
                        if (listingCategory !== currentAdminTypeFilter) {
                            // This listing doesn't match the selected category
                        }
                    } else {
                        // Direct type match (legacy support)
                        matchesType = listing.type === currentAdminTypeFilter;
                    }
                }
                const matchesArea = !areaFilter || listing.area === areaFilter;
                const matchesAmenity = !amenityFilter || listing.amenities.indexOf(amenityFilter) > -1;
                
                return matchesSearch && matchesType && matchesArea && matchesAmenity;
            });
            
            console.log(' filterListings result:', filtered.length, 'of', data.listings.length, 'listings match filter');
            if (currentAdminTypeFilter) {
                console.log(' Filtering by category:', currentAdminTypeFilter);
                console.log(' Sample filtered types:', filtered.slice(0, 5).map(function(l) {
                    return l.type + ' -> ' + getCategoryForType(l.type, l);
                }).join(', '));
            }
            
            // Update clear button style based on filter state
            updateClearButtonStyle();
            
            renderListings(filtered);
        }
        
        function sortAdminListings() {
            const sortDropdown = document.getElementById('adminSortDropdown');
            if (sortDropdown) {
                currentAdminSort = sortDropdown.value;
                
                // Get currently filtered listings by re-running the filter
                // This will re-render with the new sort
                filterListings();
            }
        }
        
        window.filterAdminByType = function filterAdminByType(typeOrCategory) {
            currentAdminTypeFilter = typeOrCategory || '';
            
            console.log(' filterAdminByType called with:', typeOrCategory, '| currentAdminTypeFilter:', currentAdminTypeFilter);
            console.log(' TYPE_CATEGORIES available:', TYPE_CATEGORIES ? 'YES' : 'NO');
            if (TYPE_CATEGORIES && typeOrCategory) {
                console.log(' Category exists in TYPE_CATEGORIES:', TYPE_CATEGORIES[typeOrCategory] ? 'YES' : 'NO');
            }
            
            // Update button active states - only one category should be active at a time
            const buttons = document.querySelectorAll('#adminTab .type-filter-btn');
            buttons.forEach(function(btn) {
                btn.classList.remove('active');
                // Check if it matches by type or category
                if (!typeOrCategory) {
                    // "All Types" button - activate if no filter
                    if (btn.dataset.type === '' && !btn.dataset.category) {
                        btn.classList.add('active');
                    }
                } else {
                    // Category button - activate if it matches the current filter
                    if (btn.dataset.category === typeOrCategory) {
                        btn.classList.add('active');
                    }
                }
            });
            
            // Call filterListings to apply the filter
            filterListings();
            // Update clear button style
            updateClearButtonStyle();
        }
        
        window.handleAdminTypeFilter = function handleAdminTypeFilter() {
            const typeFilter = document.getElementById('adminTypeFilter');
            const value = typeFilter ? typeFilter.value : '';
            
            // Set the type filter to the selected type (direct type match, not category)
            if (value) {
                currentAdminTypeFilter = value;
            } else {
                currentAdminTypeFilter = '';
            }
            
            // Update button active states
            const buttons = document.querySelectorAll('#adminTab .type-filter-btn');
            buttons.forEach(function(btn) {
                btn.classList.remove('active');
                if (!value && btn.dataset.type === '' && !btn.dataset.category) {
                    btn.classList.add('active');
                }
            });
            
            // Call filterListings to apply the filter
            filterListings();
            // Update clear button style
            updateClearButtonStyle();
        }
        
        window.filterByAdminBadge = function filterByAdminBadge(event, filterType, value) {
            event.stopPropagation(); // Prevent card flip
            
            if (filterType === 'type') {
                // Set type filter
                const typeFilter = document.getElementById('adminTypeFilter');
                if (typeFilter) {
                    typeFilter.value = value;
                    handleAdminTypeFilter();
                }
            } else if (filterType === 'area') {
                // Set area filter
                const areaFilter = document.getElementById('adminAreaFilter');
                if (areaFilter) {
                    areaFilter.value = value;
                    filterListings();
                }
            } else if (filterType === 'amenity') {
                // Set amenity filter
                const amenityFilter = document.getElementById('adminAmenityFilter');
                if (amenityFilter) {
                    amenityFilter.value = value;
                    filterListings();
                }
            }
        }
        
        // Function to check if any filter is applied
        function hasActiveFilters() {
            const searchTerm = document.getElementById('adminSearchInput').value.trim();
            const areaFilter = document.getElementById('adminAreaFilter').value;
            const amenityFilter = document.getElementById('adminAmenityFilter').value;
            return searchTerm || areaFilter || amenityFilter || currentAdminTypeFilter;
        }
        
        // Function to update clear button style based on filter state
        function updateClearButtonStyle() {
            const clearButton = document.querySelector('button[onclick="clearAdminFilters()"]');
            if (!clearButton) return;
            
            if (hasActiveFilters()) {
                clearButton.style.display = '';
                clearButton.style.background = '#dc3545';
                clearButton.style.color = 'white';
                clearButton.style.borderColor = '#dc3545';
            } else {
                clearButton.style.display = 'none';
            }
        }
        
        function clearAdminFilters() {
            document.getElementById('adminSearchInput').value = '';
            const typeFilter = document.getElementById('adminTypeFilter');
            if (typeFilter) typeFilter.value = '';
            document.getElementById('adminAreaFilter').value = '';
            document.getElementById('adminAmenityFilter').value = '';
            currentAdminTypeFilter = '';
            
            // Update button style after clearing
            updateClearButtonStyle();
            
            // Reset quick filter buttons - only activate "All Types" button
            // Category buttons have both data-type="" and data-category, so we need to exclude those
            const buttons = document.querySelectorAll('#adminTab .type-filter-btn');
            buttons.forEach(function(btn) {
                btn.classList.remove('active');
                // Only activate "All Types" button: it has data-type="" but NO data-category attribute
                // OR it has the ID adminAllTypesBtn
                if ((btn.id === 'adminAllTypesBtn') || 
                    (btn.dataset.type === '' && !btn.dataset.category)) {
                    btn.classList.add('active');
                }
            });
            
            renderListings(data.listings);
        }
        
        function populateAdminFilters() {
            if (!data || !data.filterOptions) return;
            refreshFilterSelect('adminTypeFilter', data.filterOptions.types);
            refreshFilterSelect('adminAreaFilter', data.filterOptions.areas);
            refreshFilterSelect('adminAmenityFilter', data.filterOptions.amenities);
            
            // Render type filter buttons dynamically based on usage
            if (data.listings) {
                renderAdminTypeFilterButtons(data.listings, '#adminTab .type-quick-filters'); // Show all categories
                
                // Update clear button style after filters are populated
                updateClearButtonStyle();
                
                // Make sure "All Types" button has correct handler after categories are rendered
                // Use ID selector first, then fallback to querySelector
                const allTypesBtn = document.getElementById('adminAllTypesBtn') || 
                                    document.querySelector('#adminTab .type-filter-btn[data-type=""]:not([data-category])');
                if (allTypesBtn) {
                    // Remove any existing onclick handlers
                    allTypesBtn.onclick = null;
                    // Remove any existing event listeners by cloning and replacing
                    const newAllTypesBtn = allTypesBtn.cloneNode(true);
                    allTypesBtn.parentNode.replaceChild(newAllTypesBtn, allTypesBtn);
                    // Set ID on new button
                    newAllTypesBtn.id = 'adminAllTypesBtn';
                    // Add handler
                    newAllTypesBtn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log(' All Types button clicked');
                        currentAdminTypeFilter = '';
                        filterAdminByType('');
                    };
                }
            }
        }

        function populatePreviewFilters() {
            if (!data || !data.filterOptions) return;
            refreshFilterSelect('previewAreaFilter', data.filterOptions.areas);
            refreshFilterSelect('previewAmenityFilter', data.filterOptions.amenities);
        }
        
        // Get all categories from TYPE_CATEGORIES
        // Returns ALL categories regardless of whether they have matching types in the data
        // Categories with matching types will have a count > 0
        function getCategoriesByUsage(listings) {
            // Initialize counts for all categories (0 if no listings)
            const categoryCounts = {};
            const categoryTypesMap = {};
            
            // Track custom categories from Google Sheets that aren't in TYPE_CATEGORIES
            const customCategories = {};
            
            // Initialize all categories from TYPE_CATEGORIES
            for (const categoryKey in TYPE_CATEGORIES) {
                categoryCounts[categoryKey] = 0;
                categoryTypesMap[categoryKey] = [];
            }
            
            // Count listings for each category if we have listings
            // Use category from Google Sheets directly (no auto-assignment)
            if (listings && listings.length > 0) {
                listings.forEach(function(listing) {
                    // Use category from Google Sheets if it exists (simple, direct - no auto-assignment)
                    let listingCategory = null;
                    if (listing.category && listing.category.trim() !== '') {
                        // Use category directly from Google Sheets
                        listingCategory = listing.category.trim();
                    } else if (listing.type) {
                        // Only use auto-assignment as fallback if no category in Google Sheets
                        listingCategory = getCategoryForType(listing.type, listing);
                    }
                    
                    if (listingCategory) {
                        if (TYPE_CATEGORIES[listingCategory]) {
                            // Category exists in TYPE_CATEGORIES - count it
                            categoryCounts[listingCategory] = (categoryCounts[listingCategory] || 0) + 1;
                            // Track which types belong to this category
                            if (listing.type && categoryTypesMap[listingCategory].indexOf(listing.type) === -1) {
                                categoryTypesMap[listingCategory].push(listing.type);
                            }
                        } else {
                            // Category exists in Google Sheets but not in TYPE_CATEGORIES
                            // Add it as a custom category so it shows in sidebar
                            if (!customCategories[listingCategory]) {
                                customCategories[listingCategory] = {
                                    name: listingCategory,
                                    emoji: '',
                                    description: 'Custom category from Google Sheets',
                                    count: 0,
                                    types: []
                                };
                            }
                            customCategories[listingCategory].count++;
                            if (listing.type && customCategories[listingCategory].types.indexOf(listing.type) === -1) {
                                customCategories[listingCategory].types.push(listing.type);
                            }
                        }
                    }
                });
            }
            
            // Add custom categories to TYPE_CATEGORIES temporarily for display
            // (They'll be shown in sidebar but won't persist - admin should add them properly)
            for (const customKey in customCategories) {
                if (!TYPE_CATEGORIES[customKey]) {
                    TYPE_CATEGORIES[customKey] = {
                        name: customCategories[customKey].name,
                        emoji: customCategories[customKey].emoji,
                        description: customCategories[customKey].description,
                        types: []
                    };
                    categoryCounts[customKey] = customCategories[customKey].count;
                    categoryTypesMap[customKey] = customCategories[customKey].types;
                    console.log(' Added custom category to TYPE_CATEGORIES:', customKey, 'with', customCategories[customKey].count, 'listings');
                }
            }
            
            // Convert all categories to array
            const categoriesArray = Object.keys(TYPE_CATEGORIES).map(function(categoryKey) {
                return {
                    key: categoryKey,
                    category: TYPE_CATEGORIES[categoryKey],
                    count: categoryCounts[categoryKey] || 0,
                    types: categoryTypesMap[categoryKey] || [] // Types found in data for this category
                };
            });
            
            // Sort by count (descending), then by category name (ascending) for ties
            categoriesArray.sort(function(a, b) {
                if (b.count !== a.count) {
                    return b.count - a.count; // Most used first
                }
                return a.category.name.localeCompare(b.category.name); // Alphabetical for ties
            });
            
            return categoriesArray;
        }
        
        // Dynamically render category filter buttons
        // Shows ALL categories from TYPE_CATEGORIES regardless of whether they have matching types
        function renderAdminTypeFilterButtons(listings, containerSelector, maxVisible) {
            const container = document.querySelector(containerSelector);
            if (!container) return;
            
            // Get ALL categories (will show all regardless of usage)
            const categoriesByUsage = getCategoriesByUsage(listings || []);
            
            if (categoriesByUsage.length === 0) {
                console.log(' No categories defined in TYPE_CATEGORIES');
                return;
            }
            
            console.log(' Admin: All categories (showing all regardless of usage):', categoriesByUsage.map(function(c) {
                return c.category.name + ' (' + c.count + ' listings)';
            }).join(', '));
            
            // Show ALL categories - if maxVisible is not specified or is less than total, show all
            // Otherwise respect maxVisible but default to showing all
            const totalCategories = categoriesByUsage.length;
            const effectiveMaxVisible = maxVisible && maxVisible >= totalCategories ? maxVisible : totalCategories;
            
            const visibleCategories = categoriesByUsage.slice(0, effectiveMaxVisible);
            const hiddenCategories = categoriesByUsage.slice(effectiveMaxVisible);
            
            // Clear existing buttons (except "All Types" button)
            const existingButtons = container.querySelectorAll('.type-filter-btn[data-category]:not([data-category=""])');
            existingButtons.forEach(function(btn) {
                btn.remove();
            });
            
            // Remove existing expanded section and see-more button if they exist
            const existingExpanded = container.querySelector('.type-filters-expanded');
            const existingSeeMore = container.querySelector('.type-filter-see-more-btn');
            if (existingExpanded) existingExpanded.remove();
            if (existingSeeMore) existingSeeMore.remove();
            
            // Get the "All Types" button to insert after it
            const allTypeBtn = container.querySelector('.type-filter-btn[data-type=""]');
            
            // Render visible categories - insert them right after the "All Types" button
            visibleCategories.forEach(function(categoryInfo) {
                const btn = document.createElement('button');
                btn.className = 'type-filter-btn category-filter-btn';
                btn.setAttribute('data-category', categoryInfo.key);
                btn.setAttribute('data-type', ''); // Empty to indicate it's a category
                
                // Create button content with emoji and name
                const emojiSpan = document.createElement('span');
                emojiSpan.className = 'category-emoji';
                emojiSpan.textContent = categoryInfo.category.emoji;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'category-name';
                nameSpan.textContent = categoryInfo.category.name;
                
                btn.appendChild(emojiSpan);
                btn.appendChild(nameSpan);
                btn.title = categoryInfo.category.description;
                
                // When clicked, filter by all types in this category
                // Only one category can be active at a time
                btn.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check if this category is already active
                    if (currentAdminTypeFilter === categoryInfo.key) {
                        // If clicking the same category, clear the filter and show "All Types"
                        console.log(' Clearing category filter');
                        currentAdminTypeFilter = '';
                        filterAdminByType('');
                    } else {
                        // Clear previous selection and set this category as active
                        console.log(' Filtering by category:', categoryInfo.key, categoryInfo.category.name);
                        currentAdminTypeFilter = categoryInfo.key;
                        filterAdminByType(categoryInfo.key);
                    }
                };
                
                if (allTypeBtn) {
                    // Insert after "All Types" button
                    if (allTypeBtn.nextSibling) {
                        container.insertBefore(btn, allTypeBtn.nextSibling);
                    } else {
                        // If "All Types" button is the last child, append after it
                        container.appendChild(btn);
                    }
                } else {
                    // If no "All Types" button, just append
                    container.appendChild(btn);
                }
            });
            
            // Render hidden categories in expandable section (if there are any)
            if (hiddenCategories.length > 0) {
                const expandedDiv = document.createElement('div');
                expandedDiv.className = 'type-filters-expanded';
                expandedDiv.style.display = 'none';
                
                hiddenCategories.forEach(function(categoryInfo) {
                    const btn = document.createElement('button');
                    btn.className = 'type-filter-btn category-filter-btn';
                    btn.setAttribute('data-category', categoryInfo.key);
                    btn.setAttribute('data-type', '');
                    
                    const emojiSpan = document.createElement('span');
                    emojiSpan.className = 'category-emoji';
                    emojiSpan.textContent = categoryInfo.category.emoji;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'category-name';
                    nameSpan.textContent = categoryInfo.category.name;
                    
                    btn.appendChild(emojiSpan);
                    btn.appendChild(nameSpan);
                    btn.title = categoryInfo.category.description;
                    
                    // Only one category can be active at a time
                    btn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Check if this category is already active
                        if (currentAdminTypeFilter === categoryInfo.key) {
                            // If clicking the same category, clear the filter and show "All Types"
                            console.log(' Clearing category filter (hidden category)');
                            currentAdminTypeFilter = '';
                            filterAdminByType('');
                        } else {
                            // Clear previous selection and set this category as active
                            console.log(' Filtering by category (hidden):', categoryInfo.key, categoryInfo.category.name);
                            currentAdminTypeFilter = categoryInfo.key;
                            filterAdminByType(categoryInfo.key);
                        }
                    };
                    
                    expandedDiv.appendChild(btn);
                });
                
                container.appendChild(expandedDiv);
                
                // Add "See More" button
                const seeMoreBtn = document.createElement('button');
                seeMoreBtn.className = 'type-filter-see-more-btn';
                seeMoreBtn.onclick = function() {
                    toggleAdminTypeFilters();
                };
                seeMoreBtn.innerHTML = '<span class="see-more-text">See More</span><span class="see-less-text" style="display: none;">See Less</span>';
                container.appendChild(seeMoreBtn);
            }
        }
        
        // Toggle "See More" functionality for admin type filters
        function toggleAdminTypeFilters() {
            const container = document.querySelector('#adminTab .type-quick-filters');
            if (!container) return;
            
            const expanded = container.querySelector('.type-filters-expanded');
            const seeMoreBtn = container.querySelector('.type-filter-see-more-btn');
            
            if (expanded && seeMoreBtn) {
                const seeMoreTextSpan = seeMoreBtn.querySelector('.see-more-text');
                const seeLessTextSpan = seeMoreBtn.querySelector('.see-less-text');
                
                if (expanded.style.display === 'none' || !expanded.style.display) {
                    expanded.style.display = 'block';
                    if (seeMoreTextSpan) seeMoreTextSpan.style.display = 'none';
                    if (seeLessTextSpan) seeLessTextSpan.style.display = 'inline';
                } else {
                    expanded.style.display = 'none';
                    if (seeMoreTextSpan) seeMoreTextSpan.style.display = 'inline';
                    if (seeLessTextSpan) seeLessTextSpan.style.display = 'none';
                }
            }
        }
        
        // Make toggleAdminTypeFilters available globally
        window.toggleAdminTypeFilters = toggleAdminTypeFilters;
        
        function renderAmenitiesCheckboxes() {
            const container = document.getElementById('amenitiesCheckboxes');
            if (!container) return;
            
            // Ensure data is initialized
            if (typeof data === 'undefined' || !data || !data.filterOptions || !data.filterOptions.amenities) {
                console.warn('Data not initialized yet, skipping renderAmenitiesCheckboxes');
                return;
            }
            
            // Sort amenities alphabetically
            const amenities = data.filterOptions.amenities.slice().sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            container.innerHTML = amenities.map(function(amenity) {
                const id = 'amenity-' + amenity.replace(/\s+/g, '-').toLowerCase();
                return '<div class="checkbox-item">' +
                    '<input type="checkbox" id="' + id + '" value="' + amenity + '" />' +
                    '<label for="' + id + '" style="font-weight: normal; margin: 0;">' + amenity + '</label>' +
                    '</div>';
            }).join('');
        }
        
        window.openAddModal = function openAddModal() {
            document.getElementById('modalTitle').textContent = 'Add New Listing';
            document.getElementById('listingForm').reset();
            document.getElementById('editingId').value = '';
            // Reset default value for slug auto-generation
            const nameInput = document.getElementById('listingName');
            if (nameInput) nameInput.defaultValue = '';
            // Ensure dropdowns are populated with current options
            updateTypeDropdown();
            updateAreaDropdown();
            updateCategoryDropdown();
            renderAmenitiesCheckboxes();
            document.getElementById('listingModal').classList.add('active');
            // Initialize image upload buttons after modal is shown
            setTimeout(function() {
                initImageUploadButtons();
            }, 100);
        }
        
        function editListing(id) {
            const listing = data.listings.find(function(l) { return l.id === id; });
            if (!listing) return;
            
            // Ensure dropdowns are populated with current options
            updateTypeDropdown();
            updateAreaDropdown();
            updateCategoryDropdown();
            renderAmenitiesCheckboxes();
            
            document.getElementById('modalTitle').textContent = 'Edit Listing';
            document.getElementById('editingId').value = id;
            const nameInput = document.getElementById('listingName');
            nameInput.value = listing.name;
            nameInput.defaultValue = listing.name; // Store original name for slug comparison
            document.getElementById('listingType').value = listing.type;
            document.getElementById('listingArea').value = listing.area;
            document.getElementById('listingDescription').value = listing.description;
            const detailedDescriptionInput = document.getElementById('listingDetailedDescription');
            if (detailedDescriptionInput) detailedDescriptionInput.value = listing.detailedDescription || '';
            const customHtmlInput = document.getElementById('listingCustomHtml');
            if (customHtmlInput) customHtmlInput.value = listing.customHtml || '';
            const slugInput = document.getElementById('listingSlug');
            // Show the slug if it exists, otherwise show the auto-generated slug
            if (slugInput) {
                slugInput.value = listing.slug || slugify(listing.name || '');
            }
            
            // Set category from Google Sheets - simple, direct (no auto-assignment)
            const categoryInput = document.getElementById('listingCategory');
            if (categoryInput) {
                // Use category from listing (from Google Sheets) - no auto-assignment
                const categoryValue = listing.category || '';
                // Set the value directly (same as type field)
                categoryInput.value = categoryValue;
                console.log(' Set category for', listing.name, 'to:', categoryValue, '(from Google Sheets, no auto-assignment)');
            }
            const image1Input = document.getElementById('listingImage1');
            if (image1Input) {
                image1Input.value = listing.image1 || '';
                // Store fileId from listing data (if available) for ImageKit metadata updates
                if (listing.image1FileId) {
                    image1Input.dataset.imagekitFileId = listing.image1FileId;
                    console.log('Loaded image1FileId from listing:', listing.image1FileId);
                }
            }
            
            const image2Input = document.getElementById('listingImage2');
            if (image2Input) {
                image2Input.value = listing.image2 || '';
                // Store fileId from listing data (if available) for ImageKit metadata updates
                if (listing.image2FileId) {
                    image2Input.dataset.imagekitFileId = listing.image2FileId;
                    console.log('Loaded image2FileId from listing:', listing.image2FileId);
                }
            }
            
            const image3Input = document.getElementById('listingImage3');
            if (image3Input) {
                image3Input.value = listing.image3 || '';
                // Store fileId from listing data (if available) for ImageKit metadata updates
                if (listing.image3FileId) {
                    image3Input.dataset.imagekitFileId = listing.image3FileId;
                    console.log('Loaded image3FileId from listing:', listing.image3FileId);
                }
            }
            
            // Set image descriptions
            const image1DescInput = document.getElementById('listingImage1Desc');
            if (image1DescInput) image1DescInput.value = listing.image1Desc || '';
            const image2DescInput = document.getElementById('listingImage2Desc');
            if (image2DescInput) image2DescInput.value = listing.image2Desc || '';
            const image3DescInput = document.getElementById('listingImage3Desc');
            if (image3DescInput) image3DescInput.value = listing.image3Desc || '';
            document.getElementById('listingWebsite').value = listing.website;
            document.getElementById('listingPhone').value = listing.phone || '';
            document.getElementById('listingAddress').value = listing.address || '';
            const authorNameInput = document.getElementById('listingAuthorName');
            if (authorNameInput) authorNameInput.value = listing.authorName || '';
            const publishedInput = document.getElementById('listingPublishedDate');
            if (publishedInput) publishedInput.value = listing.publishedDate || '';
            const modifiedInput = document.getElementById('listingModifiedDate');
            if (modifiedInput) modifiedInput.value = listing.modifiedDate || '';
            const directionsInput = document.getElementById('listingDirectionsLink');
            // If directions link is empty but address exists, auto-generate it
            if (directionsInput) {
                if (listing.directionsLink && listing.directionsLink.trim()) {
                    directionsInput.value = listing.directionsLink;
                } else if (listing.address && listing.address.trim()) {
                    const encodedAddress = encodeURIComponent(listing.address.trim());
                    directionsInput.value = 'https://www.google.com/maps/search/?api=1&query=' + encodedAddress;
                } else {
                    directionsInput.value = '';
                }
            }
            document.getElementById('listingFeatured').checked = listing.featured || false;
            
            const checkboxes = document.querySelectorAll('#amenitiesCheckboxes input[type="checkbox"]');
            checkboxes.forEach(function(checkbox) {
                checkbox.checked = listing.amenities.indexOf(checkbox.value) > -1;
            });
            
            document.getElementById('listingModal').classList.add('active');
            // Re-initialize image upload buttons after modal is shown
            setTimeout(function() {
                initImageUploadButtons();
            }, 100);
        }
        
        async function deleteListing(id) {
            const listing = data.listings.find(function(l) { return l.id === id; });
            
            if (!listing) {
                alert('Listing not found!');
                return;
            }
            
            // Check if this is the confirmation click
            if (deleteConfirmId === id) {
                // Confirmed - delete it
                deleteConfirmId = null;
                if (deleteConfirmTimeout) clearTimeout(deleteConfirmTimeout);
                
                // Delete from Google Sheets if configured
                if (GOOGLE_APPS_SCRIPT_URL && !GOOGLE_APPS_SCRIPT_URL.includes('YOUR_SCRIPT_ID')) {
                    try {
                        let result = { success: false };
                        
                        // Use GET request to avoid CORS preflight (OPTIONS) issues
                        // GET requests don't trigger CORS preflight, so they work even if OPTIONS fails
                        try {
                            const deleteUrl = GOOGLE_APPS_SCRIPT_URL + '?action=deleteListing&listingId=' + encodeURIComponent(id) + '&t=' + Date.now();
                            const response = await fetch(deleteUrl, {
                                method: 'GET',
                                mode: 'cors'
                            });
                            
                            if (!response.ok) {
                                throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                            }
                            
                            const responseText = await response.text();
                            if (!responseText || responseText.trim() === '') {
                                throw new Error('Empty response from server');
                            }
                            
                            result = JSON.parse(responseText);
                            console.log('Delete response:', result);
                            
                            // Verify we got a valid response
                            if (!result || typeof result.success === 'undefined') {
                                throw new Error('Invalid response format from server');
                            }
                        } catch (fetchError) {
                            console.error('Error deleting from Google Sheets:', fetchError);
                            throw new Error('Failed to delete from Google Sheets: ' + fetchError.message);
                        }
                        
                        // Verify deletion was successful before updating local data
                        if (result && result.success) {
                            console.log(' Delete confirmed successful:', result);
                            
                            // IMPORTANT: Remove from local data BEFORE refreshing display
                            // This prevents any reload from restoring the deleted listing
                            const beforeCount = data.listings.length;
                            data.listings = data.listings.filter(function(l) { 
                                const matches = String(l.id).trim() === String(id).trim();
                                if (matches) {
                                    console.log('Removing listing from local data:', l.name, 'ID:', l.id);
                                }
                                return !matches;
                            });
                            const afterCount = data.listings.length;
                            console.log('Local data updated: ' + beforeCount + '  ' + afterCount + ' listings');
                            
                            // Verify it was actually removed
                            const stillExists = data.listings.some(function(l) {
                                return String(l.id).trim() === String(id).trim();
                            });
                            
                            if (stillExists) {
                                console.error(' ERROR: Listing still exists in local data after delete!');
                                console.error('Listing ID:', id);
                                console.error('Matching listings:', data.listings.filter(function(l) {
                                    return String(l.id).trim() === String(id).trim();
                                }));
                            }
                            
                            updateSyncStatus(true, ' Deleted from Google Sheets');
                            
                            // DON'T reload from Google Sheets - we've already updated local data
                            // The delete is already saved to Google Sheets, reloading would be redundant
                            // and could cause issues if there's a delay in Google Sheets processing
                        console.log(' Listing deleted successfully from Google Sheets. Local data updated.');
                        console.log('NOT reloading from Google Sheets - local data is already correct.');
                        showUnsavedChangesBadge();
                            
                            // Refresh the display immediately with updated local data
                            applyFilterOptionCleanup();
                            renderListings();
                            
                            // Show success message
                            alert(' "' + listing.name + '" has been deleted from Google Sheets.');
                        } else {
                            // Delete failed - don't update local data, show error
                            const errorMsg = result && result.error ? result.error : 'Delete failed - unknown error';
                            console.error(' Delete failed:', errorMsg);
                            console.error('Full result:', result);
                            throw new Error(errorMsg);
                        }
                    } catch (error) {
                        console.error(' Error deleting from Google Sheets:', error);
                        console.error('Error details:', error.message, error.stack);
                        updateSyncStatus(false, ' Delete failed: ' + error.message);
                        
                        // IMPORTANT: Do NOT delete locally if Google Sheets delete failed
                        // This prevents the listing from coming back when data is reloaded
                        // The listing should remain in both local data and Google Sheets until delete succeeds
                        alert(' Failed to delete from Google Sheets: ' + error.message + '\n\n' +
                              'The listing was NOT deleted. Please try again or check the Google Apps Script logs.\n\n' +
                              'If the problem persists, you can delete it directly in Google Sheets.');
                        
                        // Do NOT remove from local data - keep it in sync with Google Sheets
                        // Refresh the display to show the listing is still there
                        applyFilterOptionCleanup();
                        renderListings();
                    }
                } else {
                    // No Google Sheets configured - delete locally only
                    data.listings = data.listings.filter(function(l) { return l.id !== id; });
                    updateSyncStatus(false, ' Deleted locally only (Google Sheets not configured)');
                    alert('Deleted "' + listing.name + '" (Local only - configure Google Sheets to sync)');
                    
                    // Refresh the display
                    applyFilterOptionCleanup();
                    renderListings();
                }
                
            } else {
                // First click - set confirmation needed
                deleteConfirmId = id;
                
                // Clear any existing timeout
                if (deleteConfirmTimeout) clearTimeout(deleteConfirmTimeout);
                
                // Re-render to update button text
                renderListings();
                
                // Reset after 3 seconds
                deleteConfirmTimeout = setTimeout(function() {
                    deleteConfirmId = null;
                    renderListings();
                }, 3000);
            }
        }
        
        function duplicateListing(id) {
            const listing = data.listings.find(function(l) { return l.id === id; });
            
            if (!listing) {
                alert('Listing not found!');
                return;
            }
            
            // Create a deep copy of the listing
            const duplicate = JSON.parse(JSON.stringify(listing));
            
            // Generate a new ID
            duplicate.id = Date.now().toString();
            
            // Modify the name to indicate it's a duplicate
            duplicate.name = (listing.name || 'Untitled Listing') + ' (Copy)';
            
            // Generate a new slug if it exists
            if (duplicate.slug) {
                duplicate.slug = duplicate.slug + '-copy';
            }
            
            // Add to the listings array
            data.listings.push(duplicate);
            
            // Re-render the list to show the new duplicate
            renderListings();
            showUnsavedChangesBadge();
            
            // Optionally open the duplicate for editing
            setTimeout(function() {
                editListing(duplicate.id);
            }, 100);
            
            alert(' Duplicated "' + listing.name + '"');
        }
        
        function saveListing(event) {
            event.preventDefault();
            
            const getValue = function(id) {
                const el = document.getElementById(id);
                return el ? el.value : '';
            };
            
            const getChecked = function(id) {
                const el = document.getElementById(id);
                return el ? el.checked : false;
            };
            
            const checkboxes = document.querySelectorAll('#amenitiesCheckboxes input[type="checkbox"]:checked');
            const selectedAmenities = [];
            checkboxes.forEach(function(cb) { selectedAmenities.push(cb.value); });
            
            const editingId = document.getElementById('editingId').value;
            const isUpdate = !!editingId;
            const existingListing = isUpdate ? data.listings.find(function(l) { return l.id === editingId; }) : null;
            const generatedId = editingId || Date.now().toString();
            
            // Get category - handle EXACTLY like type (simple, direct, no normalization)
            // Type: getValue('listingType') - no transformation
            // Category: getValue('listingCategory') - same approach
            const categoryValue = getValue('listingCategory');
            
            // Get fileIds from dataset attributes (stored during upload or loaded from listing data)
            const image1Field = document.getElementById('listingImage1');
            const image2Field = document.getElementById('listingImage2');
            const image3Field = document.getElementById('listingImage3');
            
            const listingUpdates = {
                id: generatedId,
                name: getValue('listingName'),
                slug: getValue('listingSlug'),
                type: getValue('listingType'), // Simple, direct - no normalization
                area: getValue('listingArea'),
                description: getValue('listingDescription'),
                detailedDescription: getValue('listingDetailedDescription'),
                customHtml: getValue('listingCustomHtml'),
                image1: getValue('listingImage1'),
                image2: getValue('listingImage2'),
                image3: getValue('listingImage3'),
                image1Desc: getValue('listingImage1Desc'),
                image2Desc: getValue('listingImage2Desc'),
                image3Desc: getValue('listingImage3Desc'),
                // Store fileIds for ImageKit metadata updates (preserved when duplicating)
                image1FileId: image1Field && image1Field.dataset.imagekitFileId ? image1Field.dataset.imagekitFileId : (existingListing && existingListing.image1FileId ? existingListing.image1FileId : undefined),
                image2FileId: image2Field && image2Field.dataset.imagekitFileId ? image2Field.dataset.imagekitFileId : (existingListing && existingListing.image2FileId ? existingListing.image2FileId : undefined),
                image3FileId: image3Field && image3Field.dataset.imagekitFileId ? image3Field.dataset.imagekitFileId : (existingListing && existingListing.image3FileId ? existingListing.image3FileId : undefined),
                website: getValue('listingWebsite'),
                phone: getValue('listingPhone'),
                address: getValue('listingAddress'),
                amenities: selectedAmenities,
                featured: getChecked('listingFeatured'),
                authorName: getValue('listingAuthorName'),
                publishedDate: getValue('listingPublishedDate'),
                modifiedDate: getValue('listingModifiedDate'),
                directionsLink: getValue('listingDirectionsLink'),
                googleMapsUrl: getValue('listingDirectionsLink'),
                category: categoryValue || '' // Simple, direct - same as type (empty string if not selected)
            };
            
            const listing = sanitizeListing(Object.assign({}, existingListing || {}, listingUpdates));
            
            if (!listing.slug && listing.name) {
                listing.slug = slugify(listing.name);
            }
            
            // Save locally only - user must click "Save All to Google Sheets" to sync
                        if (isUpdate) {
                            const index = data.listings.findIndex(function(l) { return l.id === editingId; });
                            if (index >= 0) {
                                data.listings[index] = listing;
                    alert('"' + listing.name + '" has been updated locally!\n\n Click "Save All to Google Sheets" to sync changes.');
                        } else {
                            data.listings.push(listing);
                    alert('"' + listing.name + '" has been added locally!\n\n Click "Save All to Google Sheets" to sync changes.');
                }
                    } else {
                        data.listings.push(listing);
                alert('"' + listing.name + '" has been added locally!\n\n Click "Save All to Google Sheets" to sync changes.');
            }
            
            // Update ImageKit metadata for all images that have descriptions and ImageKit URLs
            // This ensures descriptions are synced to ImageKit when saving
            async function syncImageDescriptionsToImageKit() {
                const imageFields = ['listingImage1', 'listingImage2', 'listingImage3'];
                const descFields = ['listingImage1Desc', 'listingImage2Desc', 'listingImage3Desc'];
                
                for (let i = 0; i < imageFields.length; i++) {
                    const imageField = document.getElementById(imageFields[i]);
                    const descField = document.getElementById(descFields[i]);
                    
                    if (!imageField || !descField) continue;
                    
                    const imageUrl = imageField.value.trim();
                    const description = descField.value.trim();
                    
                    // Only update if both description and image URL are present and it's an ImageKit URL
                    if (description && imageUrl && imageUrl.includes('ik.imagekit.io')) {
                        try {
                            // Try to get fileId from multiple sources:
                            // 1. From the image input's data attribute (stored during upload or loaded from listing)
                            // 2. From the current listing data (for duplicated listings)
                            // 3. From the existing listing data (if available)
                            const storedFileId = imageField.dataset.imagekitFileId || null;
                            const listingFileIdKey = imageFields[i] === 'listingImage1' ? 'image1FileId' : 
                                                     imageFields[i] === 'listingImage2' ? 'image2FileId' : 
                                                     imageFields[i] === 'listingImage3' ? 'image3FileId' : null;
                            // Check the listing we're about to save (includes fileIds from duplicate)
                            const currentListingFileId = listingFileIdKey && listing[listingFileIdKey] ? listing[listingFileIdKey] : null;
                            // Also check the existing listing (for updates)
                            const existingListingFileId = listingFileIdKey && existingListing && existingListing[listingFileIdKey] ? existingListing[listingFileIdKey] : null;
                            // Use the most reliable source: stored in DOM > current listing > existing listing
                            const fileIdToUse = storedFileId || currentListingFileId || existingListingFileId || null;
                            
                            console.log('Syncing ImageKit metadata on save:', {
                                image: imageUrl.substring(0, 50) + '...',
                                description: description.substring(0, 50) + '...',
                                fileId: fileIdToUse || 'not available (will search by path)',
                                source: storedFileId ? 'DOM' : (currentListingFileId ? 'current listing' : (existingListingFileId ? 'existing listing' : 'none'))
                            });
                            
                            // Update ImageKit metadata - if fileId is not available, search by path
                            await updateImageKitMetadata(imageUrl, description, fileIdToUse);
                            
                            console.log(' ImageKit metadata synced for', imageFields[i]);
                        } catch (error) {
                            console.warn('Failed to sync ImageKit metadata for', imageFields[i], ':', error);
                            // Don't fail the save if ImageKit update fails
                        }
                    }
                }
            }
            
            // Sync image descriptions to ImageKit (don't await - do it in background)
            syncImageDescriptionsToImageKit().catch(function(error) {
                console.warn('Some ImageKit metadata syncs may have failed:', error);
            });
            
            // Update filter options, refresh display, and close modal
            applyFilterOptionCleanup();
            renderListings();
            showUnsavedChangesBadge();
            closeModal();
        }
        
        window.closeModal = function closeModal() {
            document.getElementById('listingModal').classList.remove('active');
        }
        
        function exportData() {
            const format = confirm('Choose Export Format\n\n' +
                                'Click OK to export as JSON data file\n' +
                                'Click Cancel to export full HTML admin backup');
            
            if (format) {
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'adventure-directory-data-' + new Date().toISOString().split('T')[0] + '.json';
                link.click();
                URL.revokeObjectURL(url);
                alert('JSON data exported! Check your downloads folder.');
            } else {
                const htmlContent = document.documentElement.outerHTML;
                const htmlBlob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(htmlBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'adventure-directory-admin-backup-' + new Date().toISOString().split('T')[0] + '.html';
                link.click();
                URL.revokeObjectURL(url);
                alert('Full admin backup exported! You can open this HTML file anytime to continue editing.');
            }
        }
        
        function quickExportJSON() {
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'data-' + new Date().toISOString().split('T')[0] + '.json';
            link.click();
            URL.revokeObjectURL(url);
            alert('JSON file downloaded! This contains all your listing data.');
        }
        
        // Download JSON backup (same as quickExportJSON but with different naming)
        function downloadJSON() {
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'nelson-county-listings-' + new Date().toISOString().split('T')[0] + '.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            // Update status AFTER download completes
            setTimeout(() => {
                updateSyncStatus(true, ' JSON backup downloaded');
            }, 100);
        }
        
        document.getElementById('listingModal').addEventListener('click', function(e) {
            if (e.target === this) closeModal();
        });
        
        // Keyboard shortcut: Cmd+S (Mac) or Ctrl+S (Windows) to save listing
        document.addEventListener('keydown', function(e) {
            // Check if modal is open
            const modal = document.getElementById('listingModal');
            if (!modal || !modal.classList.contains('active')) {
                return;
            }
            
            // Check if Cmd+S (Mac) or Ctrl+S (Windows) is pressed
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const isSaveShortcut = (isMac && e.metaKey && e.key === 's') || (!isMac && e.ctrlKey && e.key === 's');
            
            if (isSaveShortcut) {
                // Prevent default browser save dialog
                e.preventDefault();
                e.stopPropagation();
                
                // Trigger form submission (which calls saveListing via onsubmit)
                const form = document.getElementById('listingForm');
                if (form) {
                    // Validate form first
                    if (form.checkValidity()) {
                        // Use requestSubmit() if available (triggers onsubmit handler and validation)
                        // Otherwise, create a synthetic submit event and call saveListing directly
                        if (typeof form.requestSubmit === 'function') {
                            form.requestSubmit();
                        } else {
                            // Fallback: Create synthetic event and call saveListing directly
                            const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                            // Call saveListing directly with the event
                            saveListing(submitEvent);
                        }
                    } else {
                        // If form is invalid, show validation errors
                        form.reportValidity();
                    }
                }
            }
        });
        
        // Auto-populate Google Maps directions link when address changes
        const addressInput = document.getElementById('listingAddress');
        const directionsLinkInput = document.getElementById('listingDirectionsLink');
        
        if (addressInput && directionsLinkInput) {
            addressInput.addEventListener('input', function() {
                const address = this.value.trim();
                if (address) {
                    // Generate Google Maps directions link
                    const encodedAddress = encodeURIComponent(address);
                    const googleMapsUrl = 'https://www.google.com/maps/search/?api=1&query=' + encodedAddress;
                    // Only auto-populate if directions field is empty
                    if (!directionsLinkInput.value.trim()) {
                        directionsLinkInput.value = googleMapsUrl;
                    }
                }
            });
            
            // Also populate on blur if address exists but directions link is empty
            addressInput.addEventListener('blur', function() {
                const address = this.value.trim();
                if (address && !directionsLinkInput.value.trim()) {
                    const encodedAddress = encodeURIComponent(address);
                    const googleMapsUrl = 'https://www.google.com/maps/search/?api=1&query=' + encodedAddress;
                    directionsLinkInput.value = googleMapsUrl;
                }
            });
        }
        
        // Auto-generate and display slug when listing name changes
        const listingNameInput = document.getElementById('listingName');
        const listingSlugInput = document.getElementById('listingSlug');
        
        if (listingNameInput && listingSlugInput) {
            listingNameInput.addEventListener('input', function() {
                const name = this.value.trim();
                // Only auto-generate slug if slug field is empty or matches a previously auto-generated slug
                // This allows users to manually set a slug if they want
                const currentSlug = listingSlugInput.value.trim();
                const autoGeneratedSlug = slugify(name);
                
                // If slug is empty, or if it matches what would be auto-generated from the current name, update it
                if (!currentSlug || currentSlug === autoGeneratedSlug || currentSlug === slugify(listingNameInput.defaultValue || '')) {
                    listingSlugInput.value = autoGeneratedSlug;
                }
            });
            
            // Also update on blur if slug is empty
            listingNameInput.addEventListener('blur', function() {
                const name = this.value.trim();
                const currentSlug = listingSlugInput.value.trim();
                if (name && !currentSlug) {
                    listingSlugInput.value = slugify(name);
                }
            });
        }
        
        window.switchTab = function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(function(btn) { btn.classList.remove('active'); });
            document.querySelectorAll('.tab-content').forEach(function(content) { content.classList.remove('active'); });
            
            const header = document.querySelector('.header');
            
            if (tab === 'admin') {
                document.querySelectorAll('.tab-btn')[0].classList.add('active');
                document.getElementById('adminTab').classList.add('active');
                header.style.display = 'block';
            } else if (tab === 'data') {
                document.querySelectorAll('.tab-btn')[1].classList.add('active');
                document.getElementById('dataTab').classList.add('active');
                header.style.display = 'block';
                renderDataTable();
            } else if (tab === 'settings') {
                document.querySelectorAll('.tab-btn')[2].classList.add('active');
                document.getElementById('settingsTab').classList.add('active');
                header.style.display = 'block';
                renderSettings();
            }
        }
        
        // ===========================================
        // SETTINGS MANAGEMENT FUNCTIONS
        // ===========================================
        function renderSettings() {
            renderTypesList();
            renderAreasList();
            renderAmenitiesList();
            renderCategoriesList();
        }
        
        function renderTypesList() {
            const container = document.getElementById('typesList');
            if (!container) return;
            
            // Sort types alphabetically
            const sortedTypes = data.filterOptions.types.slice().sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            container.innerHTML = sortedTypes.map(function(type) {
                const index = data.filterOptions.types.indexOf(type);
                return '<div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #f8f9fa; border-radius: 4px; margin-bottom: 8px;">' +
                    '<span>' + type + '</span>' +
                    '<button onclick="removeType(' + index + ')" style="background: #ffcccc; color: #000; border: none; padding: 4px 12px; border-radius: 18px; cursor: pointer; font-size: 12px;">Remove</button>' +
                    '</div>';
            }).join('');
        }
        
        function renderAreasList() {
            const container = document.getElementById('areasList');
            if (!container) return;
            
            // Sort areas alphabetically
            const sortedAreas = data.filterOptions.areas.slice().sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            container.innerHTML = sortedAreas.map(function(area) {
                const index = data.filterOptions.areas.indexOf(area);
                return '<div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #f8f9fa; border-radius: 4px; margin-bottom: 8px;">' +
                    '<span>' + area + '</span>' +
                    '<button onclick="removeArea(' + index + ')" style="background: #ffcccc; color: #000; border: none; padding: 4px 12px; border-radius: 18px; cursor: pointer; font-size: 12px;">Remove</button>' +
                    '</div>';
            }).join('');
        }
        
        function renderAmenitiesList() {
            const container = document.getElementById('amenitiesList');
            if (!container) return;
            
            // Sort amenities alphabetically
            const sortedAmenities = data.filterOptions.amenities.slice().sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            container.innerHTML = sortedAmenities.map(function(amenity) {
                const index = data.filterOptions.amenities.indexOf(amenity);
                return '<div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #f8f9fa; border-radius: 4px;">' +
                    '<span>' + amenity + '</span>' +
                    '<button onclick="removeAmenity(' + index + ')" style="background: #ffcccc; color: #000; border: none; padding: 4px 12px; border-radius: 18px; cursor: pointer; font-size: 12px;">Remove</button>' +
                    '</div>';
            }).join('');
        }
        
        function addType() {
            const input = document.getElementById('newTypeInput');
            const value = input.value.trim();
            if (!value) return;
            
            if (data.filterOptions.types.indexOf(value) === -1) {
                data.filterOptions.types.push(value);
                saveFilterOptions();
                renderTypesList();
                updateTypeDropdown();
                input.value = '';
            } else {
                alert('This type already exists.');
            }
        }
        
        function removeType(index) {
            const confirmed = confirm('Remove Filter Type: "' + data.filterOptions.types[index] + '"\n\n' +
                                    'This will remove it from filter options but will not affect existing listings.\n\n' +
                                    'Click OK to remove this filter type\n' +
                                    'Click Cancel to keep it');
            if (confirmed) {
                data.filterOptions.types.splice(index, 1);
                saveFilterOptions();
                renderTypesList();
                updateTypeDropdown();
            }
        }
        
        function addArea() {
            const input = document.getElementById('newAreaInput');
            const value = input.value.trim();
            if (!value) return;
            
            if (data.filterOptions.areas.indexOf(value) === -1) {
                data.filterOptions.areas.push(value);
                saveFilterOptions();
                renderAreasList();
                updateAreaDropdown();
                input.value = '';
            } else {
                alert('This area already exists.');
            }
        }
        
        function removeArea(index) {
            const confirmed = confirm('Remove Filter Area: "' + data.filterOptions.areas[index] + '"\n\n' +
                                    'This will remove it from filter options but will not affect existing listings.\n\n' +
                                    'Click OK to remove this filter area\n' +
                                    'Click Cancel to keep it');
            if (confirmed) {
                data.filterOptions.areas.splice(index, 1);
                saveFilterOptions();
                renderAreasList();
                updateAreaDropdown();
            }
        }
        
        function addAmenity() {
            const input = document.getElementById('newAmenityInput');
            const value = input.value.trim();
            if (!value) return;
            
            if (data.filterOptions.amenities.indexOf(value) === -1) {
                data.filterOptions.amenities.push(value);
                saveFilterOptions();
                renderAmenitiesList();
                updateAmenitiesCheckboxes();
                input.value = '';
            } else {
                alert('This amenity already exists.');
            }
        }
        
        function removeAmenity(index) {
            const confirmed = confirm('Remove Filter Amenity: "' + data.filterOptions.amenities[index] + '"\n\n' +
                                    'This will remove it from filter options but will not affect existing listings.\n\n' +
                                    'Click OK to remove this filter amenity\n' +
                                    'Click Cancel to keep it');
            if (confirmed) {
                data.filterOptions.amenities.splice(index, 1);
                saveFilterOptions();
                renderAmenitiesList();
                updateAmenitiesCheckboxes();
            }
        }
        
        function renderCategoriesList() {
            const container = document.getElementById('categoriesList');
            if (!container) return;
            
            // Get all category keys and sort by name
            const categoryKeys = Object.keys(TYPE_CATEGORIES).slice().sort(function(a, b) {
                const nameA = (TYPE_CATEGORIES[a].name || '').toLowerCase();
                const nameB = (TYPE_CATEGORIES[b].name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            container.innerHTML = categoryKeys.map(function(categoryKey) {
                const category = TYPE_CATEGORIES[categoryKey];
                const displayName = (category.emoji || '') + ' ' + (category.name || categoryKey);
                const escapedKey = categoryKey.replace(/'/g, "\\'");
                return '<div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #f8f9fa; border-radius: 4px; margin-bottom: 8px;">' +
                    '<span>' + escapeHtml(displayName) + '</span>' +
                    '<button onclick="removeCategory(\'' + escapedKey + '\')" style="background: #ffcccc; color: #000; border: none; padding: 4px 12px; border-radius: 18px; cursor: pointer; font-size: 12px;">Remove</button>' +
                    '</div>';
            }).join('');
        }
        
        function addCategory() {
            const input = document.getElementById('newCategoryInput');
            const categoryName = input.value.trim();
            if (!categoryName) return;
            
            // Check if category name already exists
            const existingCategory = Object.keys(TYPE_CATEGORIES).find(function(key) {
                return TYPE_CATEGORIES[key].name && TYPE_CATEGORIES[key].name.toLowerCase() === categoryName.toLowerCase();
            });
            
            if (existingCategory) {
                alert('A category with this name already exists.');
                return;
            }
            
            // Prompt for emoji
            const emoji = prompt('Enter an emoji for this category (optional):', '');
            const finalEmoji = emoji ? emoji.trim() : '';
            
            // Create category key from name (lowercase, replace spaces with hyphens)
            const categoryKey = categoryName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            
            // Check if key already exists
            if (TYPE_CATEGORIES[categoryKey]) {
                alert('A category with this key already exists. Please use a different name.');
                return;
            }
            
            // Add new category
            TYPE_CATEGORIES[categoryKey] = {
                emoji: finalEmoji,
                name: categoryName,
                description: categoryName + ' listings',
                icon: 'icon-default',
                types: []
            };
            
            saveCategoriesToStorage(TYPE_CATEGORIES);
            renderCategoriesList();
            updateCategoryDropdown();
            input.value = '';
        }
        
        function removeCategory(categoryKey) {
            const category = TYPE_CATEGORIES[categoryKey];
            if (!category) return;
            
            const confirmed = confirm('Remove Category: "' + (category.name || categoryKey) + '"\n\n' +
                                    'This will remove the category from filter options.\n\n' +
                                    'Click OK to remove this category\n' +
                                    'Click Cancel to keep it');
            if (confirmed) {
                delete TYPE_CATEGORIES[categoryKey];
                saveCategoriesToStorage(TYPE_CATEGORIES);
                renderCategoriesList();
                updateCategoryDropdown();
            }
        }
        
        // ===========================================
        // ICON MAPPING MANAGEMENT FUNCTIONS
        // ===========================================
        
        // List of available icon classes
        const AVAILABLE_ICONS = [
            'icon-wine', 'icon-beer', 'icon-spirits', 'icon-cocktail', 'icon-coffee', 'icon-tea',
            'icon-restaurant', 'icon-bakery', 'icon-cheese', 'icon-chocolate', 'icon-museum', 'icon-art',
            'icon-gallery', 'icon-hiking', 'icon-cycling', 'icon-activity', 'icon-kayaking', 'icon-spa',
            'icon-wellness', 'icon-shopping', 'icon-market', 'icon-concert', 'icon-theater', 'icon-cinema',
            'icon-festival', 'icon-hotel', 'icon-lodging', 'icon-transport', 'icon-train', 'icon-boat',
            'icon-scenic', 'icon-viewpoint', 'icon-park', 'icon-garden', 'icon-beach', 'icon-history',
            'icon-culture', 'icon-architecture', 'icon-local', 'icon-tour', 'icon-workshop', 'icon-class',
            'icon-food', 'icon-cidery', 'icon-indoor', 'icon-attraction', 'icon-farm', 'icon-outdoor',
            'icon-default'
        ];
        
        function renderIconMappings() {
            const container = document.getElementById('iconsList');
            if (!container) return;
            
            // Get sorted list of type-icon mappings
            const mappings = Object.keys(ICON_MAPPINGS).map(function(type) {
                return { type: type, icon: ICON_MAPPINGS[type] };
            }).sort(function(a, b) {
                return a.type.localeCompare(b.type);
            });
            
            if (mappings.length === 0) {
                container.innerHTML = '<p style="color: #6c757d; padding: 20px; text-align: center;">No icon mappings found. Click "Add New Mapping" to create one.</p>';
                return;
            }
            
            // Create a temporary container to build the HTML safely
            const tempContainer = document.createElement('div');
            
            mappings.forEach(function(mapping, index) {
                const iconOptions = AVAILABLE_ICONS.map(function(icon) {
                    return '<option value="' + icon + '"' + (icon === mapping.icon ? ' selected' : '') + '>' + icon.replace('icon-', '') + '</option>';
                }).join('');
                
                // Escape type for HTML display only
                const escapedTypeForHTML = mapping.type.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                
                const item = document.createElement('div');
                item.className = 'icon-mapping-item';
                item.setAttribute('data-type', mapping.type); // Store actual type in data attribute
                item.style.cssText = 'display: flex; align-items: center; gap: 15px; padding: 15px; background: #ffffff; border: 1px solid #dee2e6; border-radius: 8px;';
                
                item.innerHTML = '<div style="flex: 1;">' +
                    '<div style="font-weight: 600; color: #212529; margin-bottom: 5px;">' + escapedTypeForHTML + '</div>' +
                    '<div style="font-size: 12px; color: #6c757d;">Type</div>' +
                    '</div>' +
                    '<div style="width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">' +
                    '<span class="badge-type ' + mapping.icon + '" style="width: 24px; height: 24px; display: inline-block;"></span>' +
                    '</div>' +
                    '<div style="flex: 1;">' +
                    '<select class="icon-select" style="width: 100%; padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 14px;">' +
                    iconOptions +
                    '</select>' +
                    '</div>' +
                    '<button class="remove-icon-mapping-btn" style="background: #ffcccc; color: #000; border: none; padding: 8px 16px; border-radius: 18px; cursor: pointer; font-size: 14px;">Remove</button>';
                
                tempContainer.appendChild(item);
            });
            
            container.innerHTML = '';
            container.appendChild(tempContainer);
            
            // Attach event listeners after rendering
            container.querySelectorAll('.icon-select').forEach(function(select) {
                select.addEventListener('change', function() {
                    const item = this.closest('.icon-mapping-item');
                    const type = item.getAttribute('data-type');
                    const iconClass = this.value;
                    updateIconMapping(type, iconClass);
                });
            });
            
            container.querySelectorAll('.remove-icon-mapping-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    const item = this.closest('.icon-mapping-item');
                    const type = item.getAttribute('data-type');
                    removeIconMapping(type);
                });
            });
        }
        
        window.updateIconMapping = function updateIconMapping(type, iconClass) {
            if (!type || !iconClass) return;
            
            ICON_MAPPINGS[type] = iconClass;
            saveIconMappingsToStorage(ICON_MAPPINGS);
            
            // Re-render to show updated icon
            renderIconMappings();
            
            // Update preview if we have listings displayed
            if (data && data.listings) {
                renderListings(data.listings);
                if (typeof renderPreview === 'function') {
                    renderPreview(data.listings);
                }
            }
        };
        
        window.addIconMapping = function addIconMapping() {
            const type = prompt('Enter the listing type name:');
            if (!type || !type.trim()) return;
            
            const trimmedType = type.trim();
            if (ICON_MAPPINGS[trimmedType]) {
                alert('This type already has an icon mapping. Use the edit function to change it.');
                return;
            }
            
            // Default to icon-default
            ICON_MAPPINGS[trimmedType] = 'icon-default';
            saveIconMappingsToStorage(ICON_MAPPINGS);
            renderIconMappings();
            
            // Scroll to the new mapping
            setTimeout(function() {
                const item = document.querySelector('.icon-mapping-item[data-type="' + trimmedType + '"]');
                if (item) {
                    item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    item.style.background = '#fff3cd';
                    setTimeout(function() {
                        item.style.background = '#ffffff';
                    }, 2000);
                }
            }, 100);
        };
        
        window.removeIconMapping = function removeIconMapping(type) {
            if (!type) return;
            
            const confirmed = confirm('Remove icon mapping for type: "' + type + '"\n\n' +
                                    'This will remove the custom mapping. The type will use the default icon.\n\n' +
                                    'Click OK to remove this mapping\n' +
                                    'Click Cancel to keep it');
            if (confirmed) {
                delete ICON_MAPPINGS[type];
                saveIconMappingsToStorage(ICON_MAPPINGS);
                renderIconMappings();
                
                // Update preview if we have listings displayed
                if (data && data.listings) {
                    renderListings(data.listings);
                    if (typeof renderPreview === 'function') {
                        renderPreview(data.listings);
                    }
                }
            }
        };
        
        window.filterIconMappings = function filterIconMappings() {
            const searchTerm = document.getElementById('iconMappingSearch').value.toLowerCase().trim();
            const items = document.querySelectorAll('.icon-mapping-item');
            
            items.forEach(function(item) {
                const type = item.dataset.type.toLowerCase();
                const iconSelect = item.querySelector('.icon-select');
                const icon = iconSelect ? iconSelect.value.toLowerCase() : '';
                const matches = !searchTerm || type.indexOf(searchTerm) > -1 || icon.indexOf(searchTerm) > -1;
                item.style.display = matches ? 'flex' : 'none';
            });
        };
        
        window.resetIconMappingsToDefaults = function resetIconMappingsToDefaults() {
            const confirmed = confirm('Reset all icon mappings to defaults?\n\n' +
                                    'This will replace all current mappings with the default set.\n\n' +
                                    'Click OK to reset\n' +
                                    'Click Cancel to keep current mappings');
            if (confirmed) {
                ICON_MAPPINGS = JSON.parse(JSON.stringify(DEFAULT_ICON_MAPPINGS));
                saveIconMappingsToStorage(ICON_MAPPINGS);
                renderIconMappings();
                
                // Update preview if we have listings displayed
                if (data && data.listings) {
                    renderListings(data.listings);
                    if (typeof renderPreview === 'function') {
                        renderPreview(data.listings);
                    }
                }
            }
        };
        
        window.exportIconMappings = function exportIconMappings() {
            const dataStr = JSON.stringify(ICON_MAPPINGS, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'icon-mappings-' + new Date().toISOString().split('T')[0] + '.json';
            link.click();
            URL.revokeObjectURL(url);
        };
        
        window.importIconMappings = function importIconMappings(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported && typeof imported === 'object') {
                        const confirmed = confirm('Import icon mappings?\n\n' +
                                                'This will replace all current mappings with the imported ones.\n\n' +
                                                'Click OK to import\n' +
                                                'Click Cancel to cancel');
                        if (confirmed) {
                            ICON_MAPPINGS = imported;
                            saveIconMappingsToStorage(ICON_MAPPINGS);
                            renderIconMappings();
                            
                            // Update preview if we have listings displayed
                            if (data && data.listings) {
                                renderListings(data.listings);
                                if (typeof renderPreview === 'function') {
                                    renderPreview(data.listings);
                                }
                            }
                            
                            alert('Icon mappings imported successfully!');
                        }
                    } else {
                        alert('Invalid file format. Please import a valid JSON file.');
                    }
                } catch (err) {
                    alert('Error importing file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        };
        
        function saveFilterOptions() {
            // Save to localStorage
            localStorage.setItem('nelsonCounty_filterOptions', JSON.stringify(data.filterOptions));
        }
        
        // ===========================================
        // CATEGORY MANAGEMENT FUNCTIONS
        // ===========================================
        function renderCategories() {
            const container = document.getElementById('categoriesList');
            if (!container) return;
            
            container.innerHTML = Object.keys(TYPE_CATEGORIES).map(function(categoryKey) {
                const category = TYPE_CATEGORIES[categoryKey];
                const typesHtml = category.types.map(function(type, typeIndex) {
                    return '<div style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: #f8f9fa; border-radius: 4px; margin: 4px 0;">' +
                        '<span style="flex: 1;">' + type + '</span>' +
                        '<button onclick="removeTypeFromCategory(\'' + categoryKey + '\', ' + typeIndex + ')" style="background: #ffcccc; color: #000; border: none; padding: 4px 10px; border-radius: 18px; cursor: pointer; font-size: 12px;">Remove</button>' +
                        '</div>';
                }).join('');
                
                return '<div style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px;">' +
                    '<div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">' +
                    '<div style="width: 60px; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 24px; text-align: center; background: #f8f9fa;">' + category.emoji + '</div>' +
                    '<input type="text" id="categoryName_' + categoryKey + '" value="' + category.name + '" style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;" onchange="updateCategory(\'' + categoryKey + '\')" placeholder="Category Name" />' +
                    '</div>' +
                    '<div style="margin-bottom: 15px;">' +
                    '<textarea id="categoryDesc_' + categoryKey + '" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; min-height: 60px;" onchange="updateCategory(\'' + categoryKey + '\')" placeholder="Category description">' + category.description + '</textarea>' +
                    '</div>' +
                    '<div style="margin-bottom: 15px;">' +
                    '<label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Types in this category:</label>' +
                    '<div id="categoryTypes_' + categoryKey + '" style="max-height: 200px; overflow-y: auto; margin-bottom: 10px;">' + typesHtml + '</div>' +
                    '<div style="display: flex; gap: 10px;">' +
                    '<input type="text" id="newTypeForCategory_' + categoryKey + '" placeholder="Add type..." style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;" onkeypress="if(event.key===\'Enter\') addTypeToCategory(\'' + categoryKey + '\')" />' +
                    '<button onclick="addTypeToCategory(\'' + categoryKey + '\')" class="btn btn-success" style="padding: 8px 16px;">Add</button>' +
                    '</div>' +
                    '</div>' +
                    '</div>';
            }).join('');
        }
        
        window.updateCategory = function updateCategory(categoryKey) {
            const category = TYPE_CATEGORIES[categoryKey];
            if (!category) return;
            
            category.name = document.getElementById('categoryName_' + categoryKey).value.trim();
            category.description = document.getElementById('categoryDesc_' + categoryKey).value.trim();
            
            // Note: Icons are set in DEFAULT_TYPE_CATEGORIES and not editable
            // If icon is missing, preserve it from defaults or use category key as fallback
            if (!category.icon && DEFAULT_TYPE_CATEGORIES[categoryKey]) {
                category.icon = DEFAULT_TYPE_CATEGORIES[categoryKey].icon || 'icon-default';
            }
            
            saveCategoriesToStorage(TYPE_CATEGORIES);
            renderCategories();
            
            // Refresh admin filters and listings to show updated category info
            if (data && data.listings) {
                populateAdminFilters();
                renderListings(data.listings);
            }
        };
        
        window.addTypeToCategory = function addTypeToCategory(categoryKey) {
            const input = document.getElementById('newTypeForCategory_' + categoryKey);
            const value = input.value.trim();
            if (!value) return;
            
            const category = TYPE_CATEGORIES[categoryKey];
            if (!category) return;
            
            if (category.types.indexOf(value) === -1) {
                category.types.push(value);
                saveCategoriesToStorage(TYPE_CATEGORIES);
                renderCategories();
                input.value = '';
            } else {
                alert('This type already exists in this category.');
            }
        };
        
        window.removeTypeFromCategory = function removeTypeFromCategory(categoryKey, typeIndex) {
            const category = TYPE_CATEGORIES[categoryKey];
            if (!category) return;
            
            const confirmed = confirm('Remove type "' + category.types[typeIndex] + '" from category "' + category.name + '"?\n\nThis will affect how listings are categorized.');
            if (confirmed) {
                category.types.splice(typeIndex, 1);
                saveCategoriesToStorage(TYPE_CATEGORIES);
                renderCategories();
            }
        };
        
        window.resetCategoriesToDefaults = function resetCategoriesToDefaults() {
            if (confirm('Reset all categories to default values? This will overwrite all your customizations.')) {
                TYPE_CATEGORIES = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES));
                saveCategoriesToStorage(TYPE_CATEGORIES);
                renderCategories();
                alert('Categories reset to defaults.');
            }
        };
        
        window.exportCategories = function exportCategories() {
            const blob = new Blob([JSON.stringify(TYPE_CATEGORIES, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'categories-' + new Date().toISOString().split('T')[0] + '.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        };
        
        window.importCategories = function importCategories(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported && typeof imported === 'object') {
                        if (confirm('Import categories? This will overwrite your current categories.')) {
                            TYPE_CATEGORIES = imported;
                            saveCategoriesToStorage(TYPE_CATEGORIES);
                            renderCategories();
                            alert('Categories imported successfully.');
                        }
                    } else {
                        alert('Invalid categories file.');
                    }
                } catch (error) {
                    alert('Error importing categories: ' + error.message);
                }
            };
            reader.readAsText(file);
        };
        
        function updateCategoryDropdown() {
            const select = document.getElementById('listingCategory');
            if (!select) return;
            
            const currentValue = select.value;
            const categoryKeys = Object.keys(TYPE_CATEGORIES);
            const categoryKeysSet = new Set(categoryKeys);
            
            // Build options list with all categories from TYPE_CATEGORIES
            let optionsHtml = '<option value="">Select Category</option>' +
                categoryKeys.map(function(categoryKey) {
                    const category = TYPE_CATEGORIES[categoryKey];
                    return '<option value="' + escapeHtml(categoryKey) + '">' + escapeHtml(category.emoji || '') + ' ' + escapeHtml(category.name) + '</option>';
                }).join('');
            
            // If current value exists but isn't in TYPE_CATEGORIES, add it to preserve custom categories from Google Sheets
            if (currentValue && currentValue.trim() && !categoryKeysSet.has(currentValue)) {
                optionsHtml += '<option value="' + escapeHtml(currentValue) + '">' + escapeHtml(currentValue) + ' (from Google Sheets)</option>';
                console.log(' Adding custom category to dropdown:', currentValue);
            }
            
            select.innerHTML = optionsHtml;
            select.value = currentValue; // This will now work even for custom categories
        }
        
        function updateTypeDropdown() {
            const select = document.getElementById('listingType');
            if (!select) return;
            
            // Ensure data is initialized
            if (typeof data === 'undefined' || !data || !data.filterOptions || !data.filterOptions.types) {
                console.warn('Data not initialized yet, skipping updateTypeDropdown');
                return;
            }
            
            const currentValue = select.value;
            // Sort types alphabetically
            const sortedTypes = data.filterOptions.types.slice().sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            // Build options list, preserving the current value if it's not in filterOptions.types
            const typesSet = new Set(sortedTypes);
            let optionsHtml = '<option value="">Select Type</option>' +
                sortedTypes.map(function(type) {
                    return '<option value="' + escapeHtml(type) + '">' + escapeHtml(type) + '</option>';
                }).join('');
            
            // If current value exists but isn't in the standard types, add it to preserve user input
            if (currentValue && currentValue.trim() && !typesSet.has(currentValue)) {
                optionsHtml += '<option value="' + escapeHtml(currentValue) + '">' + escapeHtml(currentValue) + '</option>';
            }
            
            select.innerHTML = optionsHtml;
            select.value = currentValue; // This will now work even for custom types
            
            // Update category dropdown when type changes
            updateCategoryDropdown();
        }
        
        function updateAreaDropdown() {
            const select = document.getElementById('listingArea');
            if (!select) return;
            
            // Ensure data is initialized
            if (typeof data === 'undefined' || !data || !data.filterOptions || !data.filterOptions.areas) {
                console.warn('Data not initialized yet, skipping updateAreaDropdown');
                return;
            }
            
            const currentValue = select.value;
            // Sort areas alphabetically
            const sortedAreas = data.filterOptions.areas.slice().sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            select.innerHTML = '<option value="">Select Area</option>' +
                sortedAreas.map(function(area) {
                    return '<option value="' + escapeHtml(area) + '">' + escapeHtml(area) + '</option>';
                }).join('');
            select.value = currentValue;
        }
        
        function updateAmenitiesCheckboxes() {
            renderAmenitiesCheckboxes();
        }

        async function fetchImageKitUploadParams() {
            const urlWithQuery = GOOGLE_APPS_SCRIPT_URL + '?action=' + encodeURIComponent(IMAGEKIT_AUTH_ACTION) + '&t=' + Date.now();
            
            try {
                console.log('Fetching ImageKit params via GET from:', urlWithQuery);
                const response = await fetch(urlWithQuery, { method: 'GET' });
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GET request failed with status', response.status, 'Response:', errorText);
                    throw new Error('HTTP ' + response.status + ': ' + errorText.substring(0, 200));
                }
                
                let json;
                try {
                    const responseText = await response.text();
                    console.log('GET response text:', responseText.substring(0, 500));
                    json = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('Failed to parse GET response as JSON:', parseError);
                    throw new Error('Invalid JSON response from server');
                }
                
                if (!json || json.success === false) {
                    throw new Error((json && json.error) || 'Failed to fetch ImageKit upload params');
                }
                const data = json.data || json;
                if (!data || !data.token || !data.signature || !data.expire) {
                    console.error('Missing required fields in response:', data);
                    throw new Error('Invalid ImageKit params response (missing fields). Got: ' + JSON.stringify(Object.keys(data || {})));
                }
                console.log('ImageKit params fetched successfully via GET');
                return data;
            } catch (getError) {
                console.warn('GET request for ImageKit params failed, falling back to POST:', getError);
                
                try {
                    console.log('Fetching ImageKit params via POST from:', GOOGLE_APPS_SCRIPT_URL);
                    const response = await fetch(GOOGLE_APPS_SCRIPT_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: 'action=' + encodeURIComponent(IMAGEKIT_AUTH_ACTION)
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('POST request failed with status', response.status, 'Response:', errorText);
                        throw new Error('HTTP ' + response.status + ': ' + errorText.substring(0, 200));
                    }
                    
                    let json;
                    try {
                        const responseText = await response.text();
                        console.log('POST response text:', responseText.substring(0, 500));
                        json = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error('Failed to parse POST response as JSON:', parseError);
                        throw new Error('Invalid JSON response from server');
                    }
                    
                    if (!json || json.success === false) {
                        throw new Error((json && json.error) || 'Failed to fetch ImageKit upload params');
                    }
                    const data = json.data || json;
                    if (!data || !data.token || !data.signature || !data.expire) {
                        console.error('Missing required fields in POST response:', data);
                        throw new Error('Invalid ImageKit params response (missing fields). Got: ' + JSON.stringify(Object.keys(data || {})));
                    }
                    console.log('ImageKit params fetched successfully via POST');
                    return data;
                } catch (postError) {
                    console.error('Both GET and POST failed. POST error:', postError);
                    throw new Error('Failed to fetch ImageKit upload params: ' + (postError.message || postError));
                }
            }
        }
        
        // Generate AI description for an image using OpenAI API
        async function generateImageDescription(imageUrl) {
            try {
                // Use Google Apps Script to call OpenAI API (to avoid exposing API key)
                // Action: 'generateImageDescription'
                if (!GOOGLE_APPS_SCRIPT_URL || GOOGLE_APPS_SCRIPT_URL.includes('YOUR_SCRIPT_ID')) {
                    console.warn('Google Apps Script URL not configured, skipping AI description generation');
                    return null;
                }
                
                console.log('Calling Google Apps Script to generate description for:', imageUrl);
                
                // Use GET request with query parameters to avoid CORS issues with POST
                // Google Apps Script handles GET requests better for CORS
                const params = new URLSearchParams({
                    action: 'generateImageDescription',
                    imageUrl: imageUrl,
                    t: Date.now().toString() // Cache busting
                });
                
                const requestUrl = GOOGLE_APPS_SCRIPT_URL + '?' + params.toString();
                console.log('Request URL:', requestUrl);
                
                let response;
                try {
                    response = await fetch(requestUrl, {
                        method: 'GET',
                        mode: 'cors',
                        redirect: 'follow' // Follow redirects
                    });
                } catch (fetchError) {
                    // Check if it's a rate limit error
                    if (fetchError.message && fetchError.message.includes('429')) {
                        throw new Error('Google Apps Script rate limit exceeded. Please wait a minute and try again.');
                    }
                    throw fetchError;
                }
                
                console.log('Response status:', response.status, response.statusText);
                console.log('Response URL:', response.url); // Log final URL after redirects
                
                // Check for rate limiting (429)
                if (response.status === 429) {
                    throw new Error('Google Apps Script rate limit exceeded (429). Please wait a minute and try again.');
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response error text:', errorText);
                    throw new Error('Failed to generate description: HTTP ' + response.status + ' - ' + errorText);
                }
                
                const responseText = await response.text();
                console.log('Response text (first 1000 chars):', responseText.substring(0, 1000));
                console.log('Full response length:', responseText.length);
                
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('Failed to parse JSON response:', parseError);
                    console.error('Raw response:', responseText);
                    throw new Error('Invalid JSON response from server: ' + responseText.substring(0, 200));
                }
                
                console.log('Parsed result:', JSON.stringify(result, null, 2));
                
                if (result.success && result.description) {
                    console.log(' Description successfully generated, length:', result.description.length);
                    console.log('Description preview:', result.description.substring(0, 100) + '...');
                    return result.description;
                } else {
                    console.error(' Description generation failed. Full result:', JSON.stringify(result, null, 2));
                    const errorMsg = result.error || 'Failed to generate description. Response: ' + JSON.stringify(result);
                    console.error('Error message:', errorMsg);
                    
                    // Check if it's an API key configuration error
                    if (errorMsg.includes('No AI API key') || errorMsg.includes('GEMINI_API_KEY') || errorMsg.includes('OPENAI_API_KEY')) {
                        console.error(' API KEY CONFIGURATION ISSUE DETECTED');
                        console.error('Please check Google Apps Script Script Properties for:');
                        console.error('1. Property name: GEMINI_API_KEY (case-sensitive, must be exact)');
                        console.error('2. Property value: Your Gemini API key (starts with AIza...)');
                        console.error('3. Available properties:', result.error && result.error.includes('Available properties:') ? result.error.split('Available properties:')[1] : 'Not shown');
                    }
                    
                    throw new Error(errorMsg);
                }
            } catch (error) {
                console.error('Error generating image description:', error);
                console.error('Error stack:', error.stack);
                // Fallback: try direct OpenAI API if API key is configured (not recommended for production)
                if (OPENAI_API_KEY) {
                    try {
                        const response = await fetch(OPENAI_API_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer ' + OPENAI_API_KEY
                            },
                            body: JSON.stringify({
                                model: 'gpt-4o',
                                messages: [
                                    {
                                        role: 'user',
                                        content: [
                                            {
                                                type: 'text',
                                                text: 'Describe this image in detail for use as an alt text or meta description. Keep it concise (50-150 words), descriptive, and SEO-friendly. Focus on what is visible in the image.'
                                            },
                                            {
                                                type: 'image_url',
                                                image_url: { url: imageUrl }
                                            }
                                        ]
                                    }
                                ],
                                max_tokens: 200
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error('OpenAI API error: ' + response.status);
                        }
                        
                        const data = await response.json();
                        if (data.choices && data.choices[0] && data.choices[0].message) {
                            return data.choices[0].message.content.trim();
                        }
                    } catch (directError) {
                        console.error('Direct OpenAI API call failed:', directError);
                        return null;
                    }
                }
                return null;
            }
        }

        // Update ImageKit file metadata (description)
        // fileId is optional - if provided, will be used directly instead of searching by path
        async function updateImageKitMetadata(imageUrl, description, fileId = null) {
            try {
                if (!GOOGLE_APPS_SCRIPT_URL || GOOGLE_APPS_SCRIPT_URL.includes('YOUR_SCRIPT_ID')) {
                    console.warn('Google Apps Script URL not configured, skipping ImageKit metadata update');
                    return;
                }
                
                if (!description || !description.trim()) {
                    console.warn('Empty description provided, skipping ImageKit metadata update');
                    return;
                }
                
                // Extract file path from ImageKit URL
                // ImageKit URLs look like: https://ik.imagekit.io/OE/folder/file.jpg
                // Or filePath from API: /folder/file.jpg
                let filePath = null;
                if (imageUrl.includes('ik.imagekit.io')) {
                    try {
                        const urlObj = new URL(imageUrl);
                        // URL structure: https://ik.imagekit.io/OE/folder/file.jpg
                        // Pathname will be: /OE/folder/file.jpg
                        // We need: /folder/file.jpg (remove the /OE part)
                        const pathname = urlObj.pathname;
                        const pathParts = pathname.split('/').filter(p => p); // Remove empty parts
                        
                        // Remove the first part (usually the ImageKit ID like 'OE')
                        if (pathParts.length > 1) {
                            filePath = '/' + pathParts.slice(1).join('/');
                        } else {
                            filePath = pathname;
                        }
                        
                        // Remove query string if present
                        filePath = filePath.split('?')[0];
                    } catch (urlError) {
                        // Fallback to old method
                        const urlParts = imageUrl.split('/');
                        filePath = '/' + urlParts.slice(4).join('/').split('?')[0];
                    }
                } else if (imageUrl.startsWith('/')) {
                    // Already a file path
                    filePath = imageUrl.split('?')[0];
                }
                
                if (!filePath) {
                    console.error('Could not extract file path from URL:', imageUrl);
                    throw new Error('Could not extract file path from ImageKit URL: ' + imageUrl);
                }
                
                console.log('Updating ImageKit metadata:');
                console.log('  - Image URL:', imageUrl);
                console.log('  - File Path:', filePath);
                console.log('  - Description length:', description.length);
                console.log('  - Description preview:', description.substring(0, 100) + '...');
                
                // Use GET request with query parameters to avoid CORS issues
                const params = new URLSearchParams({
                    action: 'updateImageKitMetadata',
                    filePath: filePath,
                    imageUrl: imageUrl,
                    customMetadata: JSON.stringify({ description: description }),
                    t: Date.now().toString()
                });
                
                // If we have fileId, pass it directly to avoid search
                if (fileId) {
                    params.append('fileId', fileId);
                    console.log('  - Using fileId directly:', fileId);
                }
                
                const requestUrl = GOOGLE_APPS_SCRIPT_URL + '?' + params.toString();
                console.log('Request URL (first 200 chars):', requestUrl.substring(0, 200) + '...');
                
                const response = await fetch(requestUrl, {
                    method: 'GET',
                    mode: 'cors'
                });
                
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response error:', errorText);
                    throw new Error('Failed to update ImageKit metadata: HTTP ' + response.status + ' - ' + errorText);
                }
                
                const responseText = await response.text();
                console.log('Response text:', responseText);
                
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('Failed to parse response:', parseError);
                    throw new Error('Invalid JSON response: ' + responseText.substring(0, 200));
                }
                
                if (result.success) {
                    console.log(' ImageKit metadata updated successfully:', result);
                } else {
                    console.error(' ImageKit metadata update failed:', result);
                    throw new Error(result.error || 'Failed to update ImageKit metadata');
                }
            } catch (error) {
                console.error(' Error updating ImageKit metadata:', error);
                console.error('Error stack:', error.stack);
                throw error;
            }
        }
        
        async function uploadImageToImageKit(file, onProgress) {
            let token, expire, signature, folder;
            
            try {
                console.log('Fetching ImageKit upload parameters...');
                const params = await fetchImageKitUploadParams();
                token = params.token;
                expire = params.expire;
                signature = params.signature;
                folder = params.folder;
                console.log('ImageKit upload parameters fetched successfully');
            } catch (error) {
                console.error('Failed to fetch ImageKit upload parameters:', error);
                throw new Error('Failed to get upload credentials: ' + (error.message || error));
            }

            const form = new FormData();
            form.append('file', file);
            form.append('fileName', file.name);
            form.append('token', token);
            form.append('expire', expire);
            form.append('signature', signature);
            form.append('publicKey', IMAGEKIT_PUBLIC_KEY);
            form.append('useUniqueFileName', 'true');
            if (folder) form.append('folder', folder);

            const uploadUrl = 'https://upload.imagekit.io/api/v1/files/upload';
            const xhr = new XMLHttpRequest();
            
            // Set timeout to 60 seconds for large files
            xhr.timeout = 60000;

            const uploadPromise = new Promise(function(resolve, reject) {
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === XMLHttpRequest.DONE) {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                const responseText = xhr.responseText;
                                console.log('ImageKit upload response:', responseText);
                                
                                if (!responseText || responseText.trim() === '') {
                                    reject(new Error('Empty response from ImageKit'));
                                    return;
                                }
                                
                                let responseData;
                                try {
                                    responseData = JSON.parse(responseText);
                                } catch (parseError) {
                                    console.error('Failed to parse ImageKit response:', parseError, 'Response:', responseText);
                                    reject(new Error('Invalid response format from ImageKit: ' + responseText.substring(0, 100)));
                                    return;
                                }
                                
                                // Check if response indicates an error
                                if (responseData.error) {
                                    reject(new Error(responseData.error || 'ImageKit upload failed'));
                                    return;
                                }
                                
                                // Ensure we have a URL or filePath
                                if (!responseData.url && !responseData.filePath) {
                                    reject(new Error('No URL returned from ImageKit. Response: ' + JSON.stringify(responseData)));
                                    return;
                                }
                                
                                resolve(responseData);
                            } catch (error) {
                                console.error('Error processing ImageKit response:', error);
                                reject(error);
                            }
                        } else {
                            let errorMessage = 'ImageKit upload failed with status ' + xhr.status;
                            try {
                                const errorResponse = JSON.parse(xhr.responseText);
                                if (errorResponse.message || errorResponse.error) {
                                    errorMessage = errorResponse.message || errorResponse.error;
                                }
                            } catch (e) {
                                errorMessage = xhr.responseText || errorMessage;
                            }
                            reject(new Error(errorMessage));
                        }
                    }
                };
                xhr.onerror = function() {
                    reject(new Error('Network error while uploading to ImageKit'));
                };
                xhr.ontimeout = function() {
                    reject(new Error('Upload timeout - please check your internet connection'));
                };
            });

            if (typeof onProgress === 'function') {
                xhr.upload.onprogress = function(event) {
                    if (event.lengthComputable) {
                        const percent = Math.round((event.loaded / event.total) * 100);
                        onProgress(percent);
                    }
                };
            }

            xhr.open('POST', uploadUrl);
            xhr.send(form);

            return uploadPromise;
        }

        // Convert URL image to File object for ImageKit upload
        async function urlToFile(imageUrl, fileName) {
            try {
                const response = await fetch(imageUrl);
                if (!response.ok) {
                    throw new Error('Failed to fetch image: ' + response.status);
                }
                const blob = await response.blob();
                const file = new File([blob], fileName || 'image.jpg', { type: blob.type || 'image/jpeg' });
                return file;
            } catch (error) {
                console.error('Error converting URL to file:', error);
                throw new Error('Failed to download image from URL: ' + error.message);
            }
        }
        
        // Auto-upload URL images to ImageKit
        async function autoUploadImageUrl(inputId, imageUrl) {
            if (!imageUrl || !imageUrl.trim()) return false;
            
            const url = imageUrl.trim();
            // Check if it's a URL (http/https) and not already ImageKit or base64
            if (url.startsWith('http://') || url.startsWith('https://')) {
                // Check if it's already an ImageKit URL
                if (url.includes('ik.imagekit.io') || url.includes('imagekit.io')) {
                    return false; // Already ImageKit, no need to upload
                }
                
                // Check if it's base64
                if (url.startsWith('data:image/')) {
                    return false; // Base64, no need to upload
                }
                
                const input = document.getElementById(inputId);
                if (!input) return false;
                
                // Show uploading state
                const originalValue = input.value;
                input.disabled = true;
                input.value = 'Uploading from URL...';
                
                try {
                    // Extract filename from URL or use default
                    const urlParts = url.split('/');
                    const urlFileName = urlParts[urlParts.length - 1].split('?')[0] || 'image.jpg';
                    const fileName = urlFileName || 'image.jpg';
                    
                    console.log('Downloading image from URL:', url);
                    const file = await urlToFile(url, fileName);
                    
                    console.log('Uploading to ImageKit...');
                    const result = await uploadImageToImageKit(file);
                    
                    const imageKitUrl = result.url || result.filePath || '';
                    if (imageKitUrl) {
                        input.value = imageKitUrl;
                        console.log('Image uploaded successfully. New URL:', imageKitUrl);
                        return true;
                    } else {
                        throw new Error('No URL returned from upload');
                    }
                } catch (error) {
                    console.error('Error uploading image from URL:', error);
                    input.value = originalValue; // Restore original URL on error
                    alert('Failed to upload image from URL: ' + (error.message || 'Unknown error') + '\n\nOriginal URL kept.');
                    return false;
                } finally {
                    input.disabled = false;
                }
            }
            return false;
        }

        function initImageUploadButtons() {
            document.querySelectorAll('.btn-upload-image').forEach(function(button) {
                // Skip if already initialized (check for data attribute)
                if (button.dataset.uploadInitialized === 'true') {
                    return;
                }
                
                // Mark as initialized
                button.dataset.uploadInitialized = 'true';
                
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const targetId = button.dataset.target;
                    if (!targetId) {
                        console.error('Upload button missing data-target attribute');
                        alert('Error: Upload button configuration issue. Please refresh the page.');
                        return;
                    }
                    
                    const input = document.getElementById(targetId);
                    if (!input) {
                        console.error('Input field not found: ' + targetId);
                        alert('Error: Cannot find target input field: ' + targetId);
                        return;
                    }

                    const filePicker = document.createElement('input');
                    filePicker.type = 'file';
                    filePicker.accept = 'image/*';
                    filePicker.style.display = 'none';
                    
                    // Append to body temporarily (some browsers need this)
                    document.body.appendChild(filePicker);

                    filePicker.onchange = async function(event) {
                        console.log('File picker changed, files:', event.target.files);
                        
                        if (!filePicker.files || !filePicker.files.length || !filePicker.files[0]) {
                            console.log('No file selected');
                            document.body.removeChild(filePicker);
                            return;
                        }
                        
                        const file = filePicker.files[0];
                        console.log('Selected file:', file.name, file.size, 'bytes');

                        button.disabled = true;
                        const originalText = button.textContent;
                        button.textContent = 'Uploading...';

                                try {
                                    console.log('Starting upload to ImageKit...');
                                    const result = await uploadImageToImageKit(file);
                                    console.log('Upload successful, result:', result);
                                    
                                    const imageUrl = result.url || result.filePath || '';
                                    const fileId = result.fileId || null; // Store fileId from upload response
                                    if (imageUrl) {
                                        input.value = imageUrl;
                                        
                                        // Store fileId as a data attribute for later use
                                        if (fileId) {
                                            input.dataset.imagekitFileId = fileId;
                                            console.log('Stored fileId for later use:', fileId);
                                        }
                                        
                                        // Reset button text
                                        button.textContent = 'Upload';
                                        
                                        // Upload successful
                                        alert(' Image uploaded successfully!\n\nURL: ' + imageUrl + '\n\nClick "Generate AI Description" to create a description.');
                            } else {
                                throw new Error('No URL returned from upload');
                            }
                        } catch (error) {
                            console.error('ImageKit upload error:', error);
                            const errorMsg = error.message || 'Unknown error occurred';
                            alert('Image upload failed: ' + errorMsg + '\n\nPlease check the browser console for details.');
                        } finally {
                            button.disabled = false;
                            button.textContent = originalText;
                            // Clean up file picker
                            if (filePicker.parentNode) {
                                document.body.removeChild(filePicker);
                            }
                        }
                    };

                    // Handle cancel
                    filePicker.oncancel = function() {
                        console.log('File picker cancelled');
                        setTimeout(function() {
                            if (filePicker.parentNode) {
                                document.body.removeChild(filePicker);
                            }
                        }, 100);
                    };

                    try {
                        filePicker.click();
                    } catch (clickError) {
                        console.error('Error clicking file picker:', clickError);
                        alert('Error opening file picker. Please try again.');
                        if (filePicker.parentNode) {
                            document.body.removeChild(filePicker);
                        }
                    }
                });
            });
            
            // Add event listeners for "Generate AI Description" buttons
            document.querySelectorAll('.btn-generate-desc').forEach(function(btn) {
                // Skip if already initialized
                if (btn.dataset.generateInitialized === 'true') {
                    return;
                }
                btn.dataset.generateInitialized = 'true';
                
                btn.addEventListener('click', async function() {
                    const imageFieldId = btn.dataset.image;
                    const descFieldId = btn.dataset.desc;
                    
                    const imageField = document.getElementById(imageFieldId);
                    const descField = document.getElementById(descFieldId);
                    
                    if (!imageField || !descField) {
                        alert('Error: Could not find image or description field.');
                        return;
                    }
                    
                    const imageUrl = imageField.value.trim();
                    
                    if (!imageUrl) {
                        alert('Please upload an image first before generating a description.');
                        return;
                    }
                    
                    if (!imageUrl.includes('ik.imagekit.io')) {
                        alert('Please upload an image to ImageKit first. External URLs are not supported for AI description generation.');
                        return;
                    }
                    
                    // Get stored fileId if available
                    const fileId = imageField.dataset.imagekitFileId || null;
                    
                    // Disable button and show loading
                    const originalText = btn.textContent;
                    btn.disabled = true;
                    btn.textContent = 'Generating...';
                    btn.style.opacity = '0.6';
                    
                    try {
                        console.log('Generating AI description for image:', imageUrl);
                        const description = await generateImageDescription(imageUrl);
                        console.log('Description generated:', description ? 'Yes (' + description.length + ' chars)' : 'No');
                        
                        if (description && description.trim()) {
                            descField.value = description;
                            console.log('Description saved to field:', descFieldId, 'Value length:', description.length);
                            
                            // Trigger input event to ensure form recognizes the change
                            descField.dispatchEvent(new Event('input', { bubbles: true }));
                            descField.dispatchEvent(new Event('change', { bubbles: true }));
                            
                            // Update ImageKit metadata with the description
                            try {
                                console.log('Updating ImageKit metadata with description...');
                                if (fileId) {
                                    await updateImageKitMetadata(imageUrl, description, fileId);
                                } else {
                                    await updateImageKitMetadata(imageUrl, description);
                                }
                                console.log('ImageKit metadata updated successfully');
                            } catch (metadataError) {
                                console.warn('Failed to update ImageKit metadata:', metadataError);
                                // Don't fail if metadata update fails
                            }
                            
                            // Focus the description field
                            setTimeout(function() {
                                descField.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                descField.focus();
                            }, 100);
                            
                            alert(' Description generated and saved!\n\nLength: ' + description.length + ' characters');
                        } else {
                            console.warn('No description was generated (description is null/empty)');
                            alert(' Could not generate description. Check console for details.\n\nMake sure GEMINI_API_KEY or OPENAI_API_KEY is configured in Google Apps Script.');
                        }
                    } catch (descError) {
                        console.error('Failed to generate image description:', descError);
                        console.error('Error details:', descError.message, descError.stack);
                        alert(' Error generating description:\n\n' + descError.message + '\n\nCheck browser console for more details.');
                    } finally {
                        // Re-enable button
                        btn.disabled = false;
                        btn.textContent = originalText;
                        btn.style.opacity = '1';
                    }
                });
            });
            
            // Add event listeners for manual description input
            // This will sync manual changes to ImageKit metadata
            ['listingImage1Desc', 'listingImage2Desc', 'listingImage3Desc'].forEach(function(descFieldId) {
                const descField = document.getElementById(descFieldId);
                if (!descField) return;
                
                // Skip if already initialized
                if (descField.dataset.metadataInitialized === 'true') {
                    return;
                }
                descField.dataset.metadataInitialized = 'true';
                
                // Get the corresponding image input field ID
                const imageFieldId = descFieldId.replace('Desc', '');
                const imageField = document.getElementById(imageFieldId);
                
                if (!imageField) {
                    console.warn('Could not find corresponding image field for:', descFieldId);
                    return;
                }
                
                // Update ImageKit metadata when description field loses focus (blur)
                // This works for both new and existing listings - even days later!
                descField.addEventListener('blur', async function() {
                    const description = descField.value.trim();
                    const imageUrl = imageField.value.trim();
                    
                    // Only update if both description and image URL are present
                    if (description && imageUrl) {
                        // Only update if the image URL is from ImageKit
                        if (imageUrl.includes('ik.imagekit.io')) {
                            console.log(' Updating ImageKit metadata for existing image:');
                            console.log('  - Image URL:', imageUrl.substring(0, 60) + '...');
                            console.log('  - Description length:', description.length);
                            console.log('  - Description preview:', description.substring(0, 50) + '...');
                            
                            // Try to get fileId from the image input's data attribute (if stored during upload)
                            // For existing listings loaded from Google Sheets, this might be null,
                            // but updateImageKitMetadata will search by filePath instead
                            const storedFileId = imageField.dataset.imagekitFileId || null;
                            if (storedFileId) {
                                console.log('  - Using stored fileId:', storedFileId);
                            } else {
                                console.log('  - No stored fileId - will search ImageKit by file path');
                            }
                            
                            try {
                                await updateImageKitMetadata(imageUrl, description, storedFileId);
                                console.log(' ImageKit metadata updated successfully!');
                                console.log('   The description has been saved to ImageKit and will persist.');
                            } catch (error) {
                                console.error(' Failed to update ImageKit metadata:', error);
                                console.error('   This might happen if the image was deleted from ImageKit or the URL is incorrect.');
                                // Don't show alert - just log it (user can check console if needed)
                            }
                        } else {
                            console.log(' Image URL is not from ImageKit, skipping metadata update:', imageUrl);
                        }
                    } else if (imageUrl && !description) {
                        // If image URL exists but description is empty, user might have deleted it
                        // We could optionally clear the ImageKit description, but for now we'll skip
                        console.log(' Description field is empty - skipping ImageKit update');
                    }
                });
            });
            
            // Add auto-upload functionality for URL images
            ['listingImage1', 'listingImage2', 'listingImage3'].forEach(function(imageId) {
                const input = document.getElementById(imageId);
                if (input && !input.dataset.urlUploadInitialized) {
                    input.dataset.urlUploadInitialized = 'true';
                    
                    // Auto-upload on blur (when user leaves the field)
                    input.addEventListener('blur', async function(e) {
                        const url = this.value.trim();
                        if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
                            // Check if it's already ImageKit or base64
                            if (!url.includes('ik.imagekit.io') && !url.includes('imagekit.io') && !url.startsWith('data:image/')) {
                                // Ask user if they want to upload
                                const shouldUpload = confirm('This appears to be an external image URL. Would you like to upload it to ImageKit and replace it with the ImageKit URL?');
                                if (shouldUpload) {
                                    await autoUploadImageUrl(imageId, url);
                                }
                            }
                        }
                    });
                }
            });
        }
        
        // Icon mapping function - uses shared icon mappings from localStorage
        // Changes made here will sync to front page automatically
        function getIconClass(type, listing) {
            if (!type) return 'icon-default';
            
            // Get the category for this type
            const categoryKey = getCategoryForType(type, listing);
            if (categoryKey && TYPE_CATEGORIES[categoryKey] && TYPE_CATEGORIES[categoryKey].icon) {
                return TYPE_CATEGORIES[categoryKey].icon;
            }
            
            // Fallback to default icon
            return 'icon-default';
        }
        
        function renderPreview(filteredListings) {
            const listings = filteredListings || data.listings;
            const grid = document.getElementById('previewGrid');
            grid.innerHTML = '';
            
            // Populate filter dropdowns
            populatePreviewFilters();
            
            // Update results count
            document.getElementById('previewResultsCount').textContent = 'Showing ' + listings.length + ' listing' + (listings.length !== 1 ? 's' : '');
            
            listings.forEach(function(listing) {
                const card = document.createElement('div');
                card.className = 'flip-card';
                
                let flipBackTimeout = null;
                
                card.onclick = function(e) {
                    // Don't flip if clicking on links or buttons inside
                    if (e.target.tagName === 'A' || e.target.tagName === 'BUTTON' || e.target.closest('a') || e.target.closest('button')) {
                        return;
                    }
                    
                    // Close all other flipped cards
                    document.querySelectorAll('.flip-card.flipped').forEach(function(otherCard) {
                        if (otherCard !== card) {
                            otherCard.classList.remove('flipped');
                        }
                    });
                    
                    this.classList.toggle('flipped');
                };
                
                const inner = document.createElement('div');
                inner.className = 'flip-card-inner';
                
                const front = document.createElement('div');
                front.className = 'flip-card-front';
                
                // Create scrollable image container
                const imgContainer = document.createElement('div');
                imgContainer.className = 'card-front-image-scroll';
                imgContainer.style.cssText = 'position: relative; width: 100%; height: 240px; overflow-x: auto; overflow-y: hidden; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; scrollbar-width: none;';
                imgContainer.style.setProperty('-ms-overflow-style', 'none');
                
                const imgWrapper = document.createElement('div');
                imgWrapper.style.cssText = 'position: absolute; top: 0; left: 0; width: auto; height: 100%; display: flex;';
                
                // Count images
                const imageCount = (listing.image1 ? 1 : 0) + (listing.image2 ? 1 : 0) + (listing.image3 ? 1 : 0);
                
                // Add image1 if it exists
                if (listing.image1) {
                    const img1 = document.createElement('img');
                    img1.src = getAdminImageUrl(listing.image1);
                    img1.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    img1.onerror = function() {
                        this.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    };
                    imgWrapper.appendChild(img1);
                }
                
                // Add image2 if it exists
                if (listing.image2) {
                    const img2 = document.createElement('img');
                    img2.src = getAdminImageUrl(listing.image2);
                    img2.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    img2.onerror = function() {
                        this.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    };
                    imgWrapper.appendChild(img2);
                }
                
                // Add image3 if it exists
                if (listing.image3) {
                    const img3 = document.createElement('img');
                    img3.src = getAdminImageUrl(listing.image3);
                    img3.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    img3.onerror = function() {
                        this.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    };
                    imgWrapper.appendChild(img3);
                }
                
                // If no images, add fallback
                if (imageCount === 0) {
                    const img = document.createElement('img');
                    img.src = 'https://via.placeholder.com/400x400?text=No+Image';
                    img.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 240px; object-fit: cover; display: block; border-radius: 12px; flex-shrink: 0; scroll-snap-align: start;';
                    imgWrapper.appendChild(img);
                }
                
                // Set wrapper and image widths to accommodate all images side by side
                if (imageCount > 1) {
                    // Wait for container to have dimensions, then set wrapper and image widths
                    setTimeout(function() {
                        const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                        if (containerWidth > 0) {
                            imgWrapper.style.width = (containerWidth * imageCount) + 'px';
                            // Set each image to be exactly the container width
                            const images = imgWrapper.querySelectorAll('img');
                            images.forEach(function(img) {
                                img.style.width = containerWidth + 'px';
                                img.style.minWidth = containerWidth + 'px';
                                img.style.maxWidth = containerWidth + 'px';
                                img.style.height = '240px';
                            });
                        }
                    }, 10);
                }
                
                imgContainer.appendChild(imgWrapper);
                front.appendChild(imgContainer);
                
                // Add scroll arrows if there are multiple images
                if (imageCount > 1) {
                    const totalImages = imageCount;
                    
                    // Function to get current index based on scroll position
                    const getCurrentIndex = function() {
                        const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                        if (containerWidth === 0) return 0;
                        const scrollLeft = imgContainer.scrollLeft || 0;
                        // Round to nearest index
                        return Math.round(scrollLeft / containerWidth);
                    };
                    
                    // Single right arrow that cycles forward through images
                    const rightArrow = document.createElement('div');
                    rightArrow.className = 'scroll-arrow scroll-arrow-right';
                    
                    rightArrow.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                        if (containerWidth === 0) return;
                        
                        let currentIndex = getCurrentIndex();
                        // Cycle forward (next image)
                        currentIndex = (currentIndex + 1) % totalImages;
                        imgContainer.scrollTo({ left: currentIndex * containerWidth, behavior: 'smooth' });
                    });
                    
                    // Append to front so it doesn't scroll with images
                    front.appendChild(rightArrow);
                }
                
                // Add card content below images
                const cardContent = document.createElement('div');
                cardContent.style.cssText = 'padding: 20px 0px 0px 0px;';
                
                // Get category name for display
                const categoryKey = getCategoryForType(listing.type, listing);
                const categoryName = categoryKey && TYPE_CATEGORIES && TYPE_CATEGORIES[categoryKey] ? TYPE_CATEGORIES[categoryKey].name : '';
                const categoryHTML = categoryName ? 
                    '<div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">' + categoryName + '</div>' : '';
                
                cardContent.innerHTML = 
                    categoryHTML +
                    '<h3 style="font-size: 20px; margin-bottom: 10px; color: var(--text-primary);">' + listing.name + '</h3>' +
                    '<div style="display: flex; gap: 8px; margin-bottom: 10px;">' +
                    '<span class="badge-type ' + getIconClass(listing.type, listing) + '" data-type="' + listing.type + '" onclick="filterByBadge(event, \'type\', \'' + listing.type + '\')">' + listing.type + '</span>' +
                    '<span class="badge-area" data-area="' + listing.area + '" onclick="filterByBadge(event, \'area\', \'' + listing.area + '\')">' + listing.area + '</span>' +
                    '</div>' +
                    '<p style="font-size: 14px; color: var(--text-secondary); line-height: 1.5;">' + listing.description.substring(0, 100) + '...</p>';
                
                front.appendChild(cardContent);
                
                const back = document.createElement('div');
                back.className = 'flip-card-back';
                
                // Build description sections with labels for back of card
                const backDescriptionHTML = listing.description && listing.description.trim() ? 
                    '<div style="margin-bottom: 15px;">' +
                    '<h4 style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Description</h4>' +
                    '<p style="font-size: 14px; color: var(--text-secondary); line-height: 1.6; white-space: pre-wrap; margin: 0;">' + listing.description + '</p>' +
                    '</div>' : '';
                
                const backDetailedDescriptionHTML = listing.detailedDescription && listing.detailedDescription.trim() ? 
                    '<div style="margin-bottom: 15px;">' +
                    '<h4 style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Detailed Description</h4>' +
                    '<p style="font-size: 14px; color: var(--text-secondary); line-height: 1.6; white-space: pre-wrap; margin: 0;">' + listing.detailedDescription + '</p>' +
                    '</div>' : '';
                
                back.innerHTML = 
                    '<button class="flip-close-btn" onclick="event.stopPropagation(); this.closest(\'.flip-card\').classList.remove(\'flipped\');">&times;</button>' +
                    '<h3 style="font-size: 22px; margin-bottom: 12px; color: var(--text-primary);">' + listing.name + '</h3>' +
                    backDescriptionHTML +
                    backDetailedDescriptionHTML;
                
                inner.appendChild(front);
                inner.appendChild(back);
                card.appendChild(inner);
                grid.appendChild(card);
            });
        }
        
        let currentTypeFilter = '';
        
        function closeAllFlippedCards() {
            document.querySelectorAll('.flip-card.flipped').forEach(function(card) {
                card.classList.remove('flipped');
            });
        }
        
        function filterByBadge(event, filterType, value) {
            event.stopPropagation(); // Prevent card flip
            
            if (filterType === 'type') {
                currentTypeFilter = value;
                
                // Update button active states
                document.querySelectorAll('#previewTab .type-filter-btn').forEach(function(btn) {
                    btn.classList.remove('active');
                    if (btn.dataset.type === value) {
                        btn.classList.add('active');
                    }
                });
            } else if (filterType === 'area') {
                document.getElementById('previewAreaFilter').value = value;
            }
            
            filterPreview();
        }
        
        function filterPreview() {
            const searchTerm = document.getElementById('previewSearchInput').value.toLowerCase().trim();
            const areaFilter = document.getElementById('previewAreaFilter').value;
            const amenityFilter = document.getElementById('previewAmenityFilter').value;
            
            const filtered = data.listings.filter(function(listing) {
                // Search text
                const searchableText = [
                    listing.name,
                    listing.slug,
                    listing.type,
                    listing.area,
                    listing.description,
                    listing.detailedDescription,
                    listing.amenities.join(' ')
                ].join(' ').toLowerCase();
                
                const matchesSearch = !searchTerm || searchableText.indexOf(searchTerm) > -1;
                const matchesType = !currentTypeFilter || listing.type === currentTypeFilter;
                const matchesArea = !areaFilter || listing.area === areaFilter;
                const matchesAmenity = !amenityFilter || listing.amenities.indexOf(amenityFilter) > -1;
                
                return matchesSearch && matchesType && matchesArea && matchesAmenity;
            });
            
            renderPreview(filtered);
        }
        
        function clearPreviewFilters() {
            document.getElementById('previewSearchInput').value = '';
            document.getElementById('previewAreaFilter').value = '';
            document.getElementById('previewAmenityFilter').value = '';
            currentTypeFilter = '';
            
            // Reset quick filter buttons
            document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
                btn.classList.remove('active');
                if (btn.dataset.type === '') {
                    btn.classList.add('active');
                }
            });
            
            renderPreview();
        }
        
        // Table sort and filter state
        let tableSortField = 'name';
        let tableSortDirection = 'asc';
        let tableFilters = {};
        
        function renderDataTable() {
            const tbody = document.getElementById('dataTableBody');
            tbody.innerHTML = '';
            
            // Get filter values
            const filterInputs = document.querySelectorAll('.data-table .filter-input, .data-table .filter-select');
            tableFilters = {};
            filterInputs.forEach(function(input) {
                const field = input.getAttribute('data-filter');
                const value = input.value.trim();
                if (value) {
                    tableFilters[field] = value;
                }
            });
            
            // Apply filters
            let filteredListings = data.listings.filter(function(listing) {
                for (let field in tableFilters) {
                    const filterValue = tableFilters[field].toLowerCase();
                    let listingValue = '';
                    
                    if (field === 'featured') {
                        listingValue = String(listing.featured || false).toLowerCase();
                        if (filterValue !== listingValue) return false;
                    } else if (field === 'amenities') {
                        listingValue = (Array.isArray(listing.amenities) ? listing.amenities.join(', ') : '').toLowerCase();
                        if (listingValue.indexOf(filterValue) === -1) return false;
                    } else if (field === 'category' || field === 'type' || field === 'area') {
                        listingValue = String(listing[field] || '').toLowerCase();
                        if (filterValue !== listingValue) return false;
                    } else {
                        // Special handling for fields that can be filtered by presence
                        const presenceFields = ['customHtml', 'image1', 'image2', 'image3', 'website', 'phone', 'address'];
                        if (presenceFields.indexOf(field) > -1 && filterValue === 'has') {
                            // Filter for listings that have this field (non-empty)
                            const fieldValue = String(listing[field] || '').trim();
                            if (!fieldValue) return false;
                        } else if (presenceFields.indexOf(field) > -1 && filterValue === 'empty') {
                            // Filter for listings that don't have this field (empty)
                            const fieldValue = String(listing[field] || '').trim();
                            if (fieldValue) return false;
                        } else {
                            // Normal text search
                        listingValue = String(listing[field] || '').toLowerCase();
                        if (listingValue.indexOf(filterValue) === -1) return false;
                        }
                    }
                }
                return true;
            });
            
            // Apply sorting
            const sortedListings = filteredListings.slice().sort(function(a, b) {
                let aValue = a[tableSortField];
                let bValue = b[tableSortField];
                
                // Handle different data types
                if (tableSortField === 'featured') {
                    aValue = aValue ? 1 : 0;
                    bValue = bValue ? 1 : 0;
                } else if (tableSortField === 'amenities') {
                    aValue = Array.isArray(aValue) ? aValue.join(', ') : '';
                    bValue = Array.isArray(bValue) ? bValue.join(', ') : '';
                } else {
                    aValue = (aValue || '').toString().toLowerCase();
                    bValue = (bValue || '').toString().toLowerCase();
                }
                
                let result = 0;
                if (aValue < bValue) result = -1;
                else if (aValue > bValue) result = 1;
                
                return tableSortDirection === 'asc' ? result : -result;
            });
            
            sortedListings.forEach(function(listing, originalIndex) {
                // Find the original index in the unsorted array for data manipulation
                const index = data.listings.indexOf(listing);
                const safe = (value) => (value === undefined || value === null) ? '' : value;
                const safeArray = (value) => Array.isArray(value) ? value : [];
                
                const row = document.createElement('tr');
                row.setAttribute('data-index', index);
                
                // Build category dropdown options
                // Include all categories from TYPE_CATEGORIES
                const categoryKeys = Object.keys(TYPE_CATEGORIES);
                const categoryKeysSet = new Set(categoryKeys);
                let categoryOptions = '<option value="">Select Category</option>' +
                    categoryKeys.map(function(categoryKey) {
                        const category = TYPE_CATEGORIES[categoryKey];
                        const isSelected = safe(listing.category) === categoryKey;
                        return '<option value="' + escapeHtml(categoryKey) + '" ' + (isSelected ? 'selected' : '') + '>' + escapeHtml(category.emoji || '') + ' ' + escapeHtml(category.name) + '</option>';
                    }).join('');
                
                // If this listing has a custom category not in TYPE_CATEGORIES, add it to the dropdown
                const listingCategory = safe(listing.category);
                if (listingCategory && listingCategory.trim() !== '' && !categoryKeysSet.has(listingCategory)) {
                    categoryOptions += '<option value="' + escapeHtml(listingCategory) + '" selected>' + escapeHtml(listingCategory) + ' (from Google Sheets)</option>';
                    console.log(' Adding custom category to table dropdown:', listingCategory, 'for listing:', listing.name);
                }
                
                row.innerHTML = 
                    '<td class="cell-id"><input type="text" value="' + safe(listing.id) + '" data-field="id" /></td>' +
                    '<td class="cell-name"><input type="text" value="' + safe(listing.name) + '" data-field="name" /></td>' +
                    '<td class="cell-slug"><input type="text" value="' + safe(listing.slug) + '" data-field="slug" placeholder="auto" /></td>' +
                    '<td class="cell-type"><select data-field="type">' +
                        data.filterOptions.types.map(function(t) { return '<option value="' + t + '" ' + (safe(listing.type) === t ? 'selected' : '') + '>' + t + '</option>'; }).join('') +
                    '</select></td>' +
                    '<td class="cell-category"><select data-field="category">' + categoryOptions + '</select></td>' +
                    '<td class="cell-area"><select data-field="area">' +
                        data.filterOptions.areas.map(function(a) { return '<option value="' + a + '" ' + (safe(listing.area) === a ? 'selected' : '') + '>' + a + '</option>'; }).join('') +
                    '</select></td>' +
                    '<td class="cell-description"><textarea data-field="description">' + safe(listing.description) + '</textarea></td>' +
                    '<td class="cell-description-detailed"><textarea data-field="detailedDescription">' + safe(listing.detailedDescription) + '</textarea></td>' +
                    '<td class="cell-custom-html"><textarea data-field="customHtml" style="font-family: \'SFMono-Regular\', Menlo, Monaco, Consolas, \'Liberation Mono\', \'Courier New\', monospace;">' + safe(listing.customHtml) + '</textarea></td>' +
                    '<td class="cell-image"><input type="text" value="' + safe(listing.image1) + '" data-field="image1" placeholder="Image URL or base64" /></td>' +
                    '<td class="cell-image-desc"><textarea data-field="image1Desc" rows="2" style="width: 100%; padding: 4px; font-size: 12px; resize: vertical;">' + safe(listing.image1Desc) + '</textarea></td>' +
                    '<td class="cell-image"><input type="text" value="' + safe(listing.image2) + '" data-field="image2" placeholder="Image URL or base64" /></td>' +
                    '<td class="cell-image-desc"><textarea data-field="image2Desc" rows="2" style="width: 100%; padding: 4px; font-size: 12px; resize: vertical;">' + safe(listing.image2Desc) + '</textarea></td>' +
                    '<td class="cell-image"><input type="text" value="' + safe(listing.image3) + '" data-field="image3" placeholder="Image URL or base64" /></td>' +
                    '<td class="cell-image-desc"><textarea data-field="image3Desc" rows="2" style="width: 100%; padding: 4px; font-size: 12px; resize: vertical;">' + safe(listing.image3Desc) + '</textarea></td>' +
                    '<td class="cell-website"><input type="text" value="' + safe(listing.website) + '" data-field="website" placeholder="www.example.com or https://..." /></td>' +
                    '<td class="cell-phone"><input type="tel" value="' + safe(listing.phone) + '" data-field="phone" /></td>' +
                    '<td class="cell-address"><input type="text" value="' + safe(listing.address) + '" data-field="address" /></td>' +
                    '<td class="cell-author"><input type="text" value="' + safe(listing.authorName) + '" data-field="authorName" placeholder="Author name" /></td>' +
                    '<td class="cell-date"><input type="date" value="' + safe(listing.publishedDate) + '" data-field="publishedDate" /></td>' +
                    '<td class="cell-date"><input type="date" value="' + safe(listing.modifiedDate) + '" data-field="modifiedDate" /></td>' +
                    '<td class="cell-directions"><input type="url" value="' + safe(listing.directionsLink) + '" data-field="directionsLink" placeholder="https://..." /></td>' +
                    '<td class="cell-amenities"><textarea data-field="amenities">' + safeArray(listing.amenities).join(', ') + '</textarea></td>' +
                    '<td class="cell-featured"><input type="checkbox" ' + (listing.featured ? 'checked' : '') + ' data-field="featured" /></td>' +
                    '<td class="cell-actions">' +
                        '<button class="btn-table-delete" onclick="deleteFromTable(' + index + ')" style="background: ' + (deleteConfirmId === listing.id ? '#dc2626' : '#E3795C') + ';">' +
                        (deleteConfirmId === listing.id ? 'Confirm?' : 'Delete') +
                        '</button>' +
                    '</td>';
                tbody.appendChild(row);
            });
            
            // Update sort indicators
            document.querySelectorAll('.data-table th.sortable').forEach(function(th) {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.getAttribute('data-sort') === tableSortField) {
                    th.classList.add('sort-' + tableSortDirection);
                }
            });
            
            // Populate filter dropdowns
            updateTableFilterDropdowns();
        }
        
        function updateTableFilterDropdowns() {
            if (!data || !data.listings) return;
            
            // Type filter dropdown
            const typeFilter = document.querySelector('.data-table select[data-filter="type"]');
            if (typeFilter && (!typeFilter.dataset.populated || typeFilter.options.length <= 1)) {
                // Clear existing options except "All"
                while (typeFilter.options.length > 1) {
                    typeFilter.remove(1);
                }
                const uniqueTypes = [...new Set(data.listings.map(l => l.type).filter(t => t))].sort();
                uniqueTypes.forEach(function(type) {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    typeFilter.appendChild(option);
                });
                typeFilter.dataset.populated = 'true';
            }
            
            // Area filter dropdown
            const areaFilter = document.querySelector('.data-table select[data-filter="area"]');
            if (areaFilter && (!areaFilter.dataset.populated || areaFilter.options.length <= 1)) {
                // Clear existing options except "All"
                while (areaFilter.options.length > 1) {
                    areaFilter.remove(1);
                }
                const uniqueAreas = [...new Set(data.listings.map(l => l.area).filter(a => a))].sort();
                uniqueAreas.forEach(function(area) {
                    const option = document.createElement('option');
                    option.value = area;
                    option.textContent = area;
                    areaFilter.appendChild(option);
                });
                areaFilter.dataset.populated = 'true';
            }
            
            // Category filter dropdown
            const categoryFilter = document.querySelector('.data-table select[data-filter="category"]');
            if (categoryFilter && (!categoryFilter.dataset.populated || categoryFilter.options.length <= 1)) {
                // Clear existing options except "All"
                while (categoryFilter.options.length > 1) {
                    categoryFilter.remove(1);
                }
                const uniqueCategories = [...new Set(data.listings.map(l => l.category).filter(c => c))].sort();
                uniqueCategories.forEach(function(category) {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = TYPE_CATEGORIES && TYPE_CATEGORIES[category] ? 
                        TYPE_CATEGORIES[category].emoji + ' ' + TYPE_CATEGORIES[category].name : category;
                    categoryFilter.appendChild(option);
                });
                categoryFilter.dataset.populated = 'true';
            }
        }
        
        function clearTableFilters() {
            // Clear all filter inputs
            const filterInputs = document.querySelectorAll('.data-table .filter-input');
            filterInputs.forEach(function(input) {
                input.value = '';
            });
            
            // Clear all filter selects (set to "All" or empty)
            const filterSelects = document.querySelectorAll('.data-table .filter-select');
            filterSelects.forEach(function(select) {
                select.value = '';
            });
            
            // Clear the tableFilters object
            tableFilters = {};
            
            // Re-render the table with cleared filters
            renderDataTable();
        }
        
        // Add event listeners for sorting and filtering after DOM is ready
        setTimeout(function() {
            // Sort functionality
            document.addEventListener('click', function(e) {
                if (e.target.closest('.data-table th.sortable')) {
                    const th = e.target.closest('.data-table th.sortable');
                    const sortField = th.getAttribute('data-sort');
                    
                    if (tableSortField === sortField) {
                        // Toggle direction
                        tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        tableSortField = sortField;
                        tableSortDirection = 'asc';
                    }
                    
                    renderDataTable();
                }
            });
            
            // Filter functionality
            document.addEventListener('input', function(e) {
                if (e.target.matches('.data-table .filter-input, .data-table .filter-select')) {
                    renderDataTable();
                }
            });
            
            // Filter functionality for change events (for select dropdowns)
            document.addEventListener('change', function(e) {
                if (e.target.matches('.data-table .filter-select')) {
                    renderDataTable();
                }
            });
        }, 100);
        
        function saveTableChanges() {
            const rows = Array.from(document.querySelectorAll('#dataTableBody tr'));
            let changeCount = 0;
            
            rows.forEach(function(row) {
                const index = parseInt(row.getAttribute('data-index'));
                const listing = data.listings[index];
                
                // Get all input fields
                const inputs = row.querySelectorAll('[data-field]');
                inputs.forEach(function(input) {
                    const field = input.getAttribute('data-field');
                    let newValue;
                    
                    if (input.type === 'checkbox') {
                        newValue = input.checked;
                    } else if (field === 'amenities') {
                        // Convert comma-separated string to array
                        newValue = input.value.split(',').map(function(a) { return a.trim(); }).filter(function(a) { return a.length > 0; });
                    } else if (field === 'category') {
                        // Handle category: empty string means no override (undefined), otherwise use the value
                        newValue = input.value.trim() || undefined;
                    } else {
                        newValue = input.value;
                    }
                    
                    // Compare arrays properly for amenities
                    if (field === 'amenities') {
                        if (JSON.stringify(listing[field]) !== JSON.stringify(newValue)) {
                            listing[field] = newValue;
                            changeCount++;
                        }
                    } else if (field === 'category') {
                        // Compare category properly (handle undefined vs empty string)
                        const currentCategory = listing[field] || undefined;
                        const newCategory = newValue || undefined;
                        if (currentCategory !== newCategory) {
                            listing[field] = newCategory;
                            changeCount++;
                        }
                    } else if (listing[field] !== newValue) {
                        listing[field] = newValue;
                        if (field === 'directionsLink') {
                            listing.googleMapsUrl = newValue;
                        }
                        changeCount++;
                    }
                });
            });
            
            // Update all views
            applyFilterOptionCleanup();
            renderListings();
            
            // Changes saved locally only - user must click "Save All to Google Sheets" to sync
            if (changeCount > 0) {
                showUnsavedChangesBadge();
                alert('Table updated! ' + changeCount + ' field(s) changed locally.\n\n Click "Save All to Google Sheets" to sync changes.');
            } else {
                alert('No changes detected.');
            }
        }
        
        function deleteFromTable(index) {
            const listing = data.listings[index];
            
            // Check if this is the confirmation click
            if (deleteConfirmId === listing.id) {
                // Confirmed - delete it
                data.listings.splice(index, 1);
                deleteConfirmId = null;
                if (deleteConfirmTimeout) clearTimeout(deleteConfirmTimeout);
                
                applyFilterOptionCleanup();
                renderDataTable();
                renderListings();
                
                showUnsavedChangesBadge();
                alert('Deleted: ' + listing.name);
            } else {
                // First click - set confirmation needed
                deleteConfirmId = listing.id;
                
                // Clear any existing timeout
                if (deleteConfirmTimeout) clearTimeout(deleteConfirmTimeout);
                
                // Re-render to update button text
                renderDataTable();
                
                // Reset after 3 seconds
                deleteConfirmTimeout = setTimeout(function() {
                    deleteConfirmId = null;
                    renderDataTable();
                }, 3000);
            }
        }
        
        window.downloadCSV = function downloadCSV() {
            try {
                const escapeCsv = function(value) {
                    const str = value === undefined || value === null ? '' : String(value);
                    if (str === '') return '';
                    return '"' + str.replace(/"/g, '""') + '"';
                };
                
                const joinList = function(arr) {
                    if (!arr || !arr.length) return '';
                    return arr.join('; ');
                };
                
                const headers = [
                    'id', 'name', 'slug', 'type', 'category', 'area', 'description', 'detailedDescription', 'customHtml',
                    'image1', 'image1Desc', 'image1FileId',
                    'image2', 'image2Desc', 'image2FileId',
                    'image3', 'image3Desc', 'image3FileId',
                    'website', 'phone', 'address',
                    'authorName', 'publishedDate', 'modifiedDate', 'directionsLink',
                    'amenities', 'featured', 'googleMapsUrl'
                ];
                
                const rows = data.listings.map(function(listing) {
                    const safeAmenities = joinList(listing.amenities || []);
                    return [
                        escapeCsv(listing.id || ''),
                        escapeCsv(listing.name || ''),
                        escapeCsv(listing.slug || ''),
                        escapeCsv(listing.type || ''),
                        escapeCsv(listing.category || ''),
                        escapeCsv(listing.area || ''),
                        escapeCsv(listing.description || ''),
                        escapeCsv(listing.detailedDescription || ''),
                        escapeCsv(listing.customHtml || ''),
                        escapeCsv(listing.image1 || ''),
                        escapeCsv(listing.image1Desc || ''),
                        escapeCsv(listing.image1FileId || ''),
                        escapeCsv(listing.image2 || ''),
                        escapeCsv(listing.image2Desc || ''),
                        escapeCsv(listing.image2FileId || ''),
                        escapeCsv(listing.image3 || ''),
                        escapeCsv(listing.image3Desc || ''),
                        escapeCsv(listing.image3FileId || ''),
                        escapeCsv(listing.website || ''),
                        escapeCsv(listing.phone || ''),
                        escapeCsv(listing.address || ''),
                        escapeCsv(listing.authorName || ''),
                        escapeCsv(listing.publishedDate || ''),
                        escapeCsv(listing.modifiedDate || ''),
                        escapeCsv(listing.directionsLink || ''),
                        escapeCsv(safeAmenities),
                        escapeCsv(listing.featured ? 'true' : 'false'),
                        escapeCsv(listing.googleMapsUrl || listing.directionsLink || '')
                    ].join(',');
                });
                
                const csv = [headers.join(',')].concat(rows).join('\n');
                
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'listings-' + new Date().toISOString().split('T')[0] + '.csv';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                // Update status AFTER download completes
                // Use setTimeout to ensure download has started
                setTimeout(() => {
                    updateSyncStatus(true, ' CSV backup downloaded');
                }, 100);
            } catch (error) {
                console.error('Error downloading CSV:', error);
                updateSyncStatus(false, ' CSV download failed');
                alert('Error downloading CSV: ' + error.message);
            }
        }
        
        function handleCSVUpload(event) {
            try {
                console.log('CSV upload started');
                const file = event.target.files[0];
                if (!file) {
                    console.log('No file selected');
                    return;
                }
                
                console.log('Reading file:', file.name);
                const reader = new FileReader();
                
                reader.onerror = function(error) {
                    console.error('File read error:', error);
                    alert('Error reading file: ' + error);
                };
                
                reader.onload = function(e) {
                    try {
                        console.log('File loaded, parsing CSV with header mapping...');
                        const text = e.target.result;
                        const parsed = parseCSV(text);
                        
                        if (!parsed || !parsed.headers || parsed.headers.length === 0) {
                            alert('CSV file is missing a header row. Please include column names in the first row of the CSV.');
                            return;
                        }
                        
                        console.log('Detected headers:', parsed.headers);
                        
                        const newListings = parsed.dataRows
                            .map(function(row, index) {
                                const listing = mapCSVRowToListing(row);
                                if (!listing.name && !listing.id) {
                                    console.warn('Skipping row', index + 2, '- missing required name/id field', row);
                                    return null;
                                }
                                return listing;
                            })
                            .filter(Boolean);
                        
                        console.log('Parsed listings:', newListings.length);
                        
                        if (newListings.length === 0) {
                            alert('No valid listings found in CSV file. Please verify the column names match the expected headers (e.g., "name", "type", "area").');
                            return;
                        }
                        
                        const confirmed = confirm('Upload CSV with ' + newListings.length + ' listings?\n\n' +
                                                ' This will replace all current listings with the CSV data.\n\n' +
                                                'Click OK to upload CSV and replace all current listings\n' +
                                                'Click Cancel to keep current listings unchanged');
                        if (confirmed) {
                            const existingFilterOptions = (data && data.filterOptions) ? data.filterOptions : (initialData.filterOptions || { types: [], areas: [], amenities: [] });
                            const sanitizedFilterOptions = sanitizeFilterOptions(existingFilterOptions, newListings);
                            
                            if (!data) {
                                data = { listings: [], filterOptions: { types: [], areas: [], amenities: [] } };
                            }
                            
                            // Create a map of existing listings by ID for date preservation
                            const existingListingsMap = {};
                            if (data.listings && Array.isArray(data.listings)) {
                                data.listings.forEach(function(existing) {
                                    if (existing && existing.id) {
                                        existingListingsMap[existing.id] = existing;
                                    }
                                });
                            }
                            
                            data.listings = newListings.map(function(listing) {
                                // Preserve existing dates if CSV doesn't have them
                                if (listing.id && existingListingsMap[listing.id]) {
                                    const existing = existingListingsMap[listing.id];
                                    // Only preserve dates if CSV date is undefined (not provided)
                                    if (listing.publishedDate === undefined && existing.publishedDate) {
                                        listing.publishedDate = existing.publishedDate;
                                    }
                                    if (listing.modifiedDate === undefined && existing.modifiedDate) {
                                        listing.modifiedDate = existing.modifiedDate;
                                    }
                                }
                                // Convert undefined to empty string for consistency
                                if (listing.publishedDate === undefined) listing.publishedDate = '';
                                if (listing.modifiedDate === undefined) listing.modifiedDate = '';
                                return sanitizeListing(listing);
                            });
                            data.filterOptions = sanitizedFilterOptions;
                            data.sheetHeaders = sanitizeSheetHeaders(parsed.headers || (data && data.sheetHeaders));
                            
                            applyFilterOptionCleanup(sanitizedFilterOptions);
                            updateTableHeaderLabelsFromSheet(data.sheetHeaders);
                            applyFilterOptionCleanup(sanitizedFilterOptions);
                            updateTableHeaderLabelsFromSheet(data.sheetHeaders);
                            renderDataTable();
                            renderListings();
                            updateStats();
                            showUnsavedChangesBadge();
                            
                            // CSV imported locally only - user must click "Save All to Google Sheets" to sync
                            alert('CSV uploaded successfully! ' + newListings.length + ' listings imported locally.\n\n Click "Save All to Google Sheets" to sync changes.');
                        }
                        
                        // Reset file input
                        event.target.value = '';
                        
                    } catch (parseError) {
                        console.error('Error parsing CSV:', parseError);
                        alert('Error parsing CSV file: ' + parseError.message);
                    }
                };
                
                reader.readAsText(file);
                
            } catch (error) {
                console.error('Error in handleCSVUpload:', error);
                alert('Error uploading CSV: ' + error.message);
            }
        }
        
        window.addEventListener("DOMContentLoaded", async function() {
            // Small delay to ensure everything is ready (especially important when script is external)
            await new Promise(resolve => setTimeout(resolve, 100));
            await loadDataFromGoogleSheets();
            
            // Diagnostic: Check which types don't have categories assigned
            checkUnassignedTypes();
            
            const nameInput = document.getElementById('listingName');
            const slugInput = document.getElementById('listingSlug');
            if (nameInput && slugInput) {
                const updateManualFlag = () => {
                    const autoSlug = slugify(nameInput.value);
                    slugInput.dataset.manual = (slugInput.value && slugInput.value !== autoSlug) ? 'true' : 'false';
                };
                
                const maybeAutoUpdateSlug = () => {
                    if (slugInput.dataset.manual !== 'true') {
                        slugInput.value = slugify(nameInput.value);
                    }
                    updateManualFlag();
                };
                
                updateManualFlag();
                
                nameInput.addEventListener('input', maybeAutoUpdateSlug);
                slugInput.addEventListener('input', updateManualFlag);
                slugInput.addEventListener('blur', () => {
                    if (!slugInput.value) {
                        slugInput.dataset.manual = 'false';
                        slugInput.value = slugify(nameInput.value);
                    }
                });
            }
            
            // Initialize form dropdowns with dynamic options
            updateTypeDropdown();
            updateAreaDropdown();
            renderAmenitiesCheckboxes();
            renderListings();
            updateStats();
            populateAdminFilters();
            populatePreviewFilters();
            initImageUploadButtons();
            
            const backToTopBtn = document.getElementById('backToTopBtn');
            if (backToTopBtn) {
                backToTopBtn.addEventListener('click', function() {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });

                window.addEventListener('scroll', function() {
                    if (window.scrollY > 400) {
                        backToTopBtn.classList.remove('hidden');
                    } else {
                        backToTopBtn.classList.add('hidden');
                    }
                });
            }
            
            // Add event listeners to quick filter buttons in admin tab
            // Skip category buttons (they have data-category attribute) - they have their own handlers
            document.querySelectorAll('#adminTab .type-filter-btn:not([data-category])').forEach(function(btn) {
                // Only handle buttons without data-category (like "All Types" button)
                // Category buttons are handled by their own onclick handlers set in renderAdminTypeFilterButtons
                
                // Remove any existing onclick handlers to avoid conflicts
                btn.onclick = null;
                
                btn.addEventListener('click', function() {
                    // Check if this is the "All Types" button
                    if (this.dataset.type === '' && !this.dataset.category) {
                        filterAdminByType('');
                    } else {
                        // Legacy individual type button (shouldn't exist with category system)
                        const type = this.dataset.type || '';
                        filterAdminByType(type);
                    }
                });
            });
        });
        
        // ===========================================
        // GITHUB INTEGRATION FUNCTIONS
        // ===========================================
        async function saveToGitHub() {
            const token = document.getElementById('githubToken').value.trim();
            const username = document.getElementById('githubUsername').value.trim();
            const repo = document.getElementById('githubRepo').value.trim();
            const path = document.getElementById('githubPath').value.trim();
            const statusDiv = document.getElementById('githubStatus');
            
            // Validation
            if (!token) {
                statusDiv.textContent = ' Please enter your GitHub token';
                statusDiv.style.color = '#dc3545';
                return;
            }
            if (!username || !repo || !path) {
                statusDiv.textContent = ' Please fill in all fields';
                statusDiv.style.color = '#dc3545';
                return;
            }
            
            try {
                statusDiv.textContent = ' Saving to GitHub...';
                statusDiv.style.color = '#ffc107';
                
                // Get your data object (this already exists in your admin panel)
                const jsonData = data;
                
                // Convert to base64 (required by GitHub API)
                let content;
                try {
                    content = btoa(JSON.stringify(jsonData, null, 2));
                } catch (e) {
                    // If btoa fails due to special characters, use UTF-8 encoding
                    const jsonString = JSON.stringify(jsonData, null, 2);
                    content = btoa(unescape(encodeURIComponent(jsonString)));
                }
                
                // Check if file exists to get SHA (required for updates)
                const getUrl = `https://api.github.com/repos/${username}/${repo}/contents/${path}`;
                let sha = null;
                
                try {
                    const getRes = await fetch(getUrl, {
                        headers: { 
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });
                    
                    if (getRes.ok) {
                        const fileData = await getRes.json();
                        sha = fileData.sha;
                    }
                } catch (e) {
                    console.log('File does not exist yet, will create new file');
                }
                
                // Commit the file
                const commitMessage = `Update from admin panel - ${new Date().toISOString()}`;
                const putRes = await fetch(getUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        message: commitMessage,
                        content: content,
                        sha: sha
                    })
                });
                
                if (putRes.ok) {
                    const result = await putRes.json();
                    statusDiv.textContent = ' Successfully saved to GitHub!';
                    statusDiv.style.color = '#28a745';
                    
                    // Save config to localStorage so user doesn't have to re-enter
                    localStorage.setItem('github_username', username);
                    localStorage.setItem('github_repo', repo);
                    localStorage.setItem('github_path', path);
                    
                    console.log('File saved at:', result.content.html_url);
                } else {
                    const error = await putRes.json();
                    console.error('GitHub API Error:', error);
                    statusDiv.textContent = ` Error: ${error.message}`;
                    statusDiv.style.color = '#dc3545';
                }
                
            } catch (error) {
                console.error('Save to GitHub error:', error);
                statusDiv.textContent = ` Error: ${error.message}`;
                statusDiv.style.color = '#dc3545';
            }
        }
        
        function downloadJSON() {
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'adventure-directory-data-' + new Date().toISOString().split('T')[0] + '.json';
            link.click();
            URL.revokeObjectURL(url);
            
            const statusDiv = document.getElementById('githubStatus');
            if (statusDiv) {
                statusDiv.textContent = ' JSON file downloaded!';
                statusDiv.style.color = '#28a745';
                setTimeout(() => { statusDiv.textContent = ''; }, 3000);
            }
        }
        
        // Load saved GitHub config from localStorage on page load
        document.addEventListener('DOMContentLoaded', function() {
            const savedUsername = localStorage.getItem('github_username');
            const savedRepo = localStorage.getItem('github_repo');
            const savedPath = localStorage.getItem('github_path');
            
            if (savedUsername) document.getElementById('githubUsername').value = savedUsername;
            if (savedRepo) document.getElementById('githubRepo').value = savedRepo;
            if (savedPath) document.getElementById('githubPath').value = savedPath;
        });
        
        // ===========================================        // GOOGLE OAUTH AUTHENTICATION
        // ===========================================
        //  TESTING: Set to false to disable Google OAuth temporarily
        // Set to true to re-enable authentication
        const ENABLE_GOOGLE_AUTH = false; //  Change to false to skip login
        
        //  CONFIGURATION: Google OAuth Client ID
        // Get this from: https://console.cloud.google.com/apis/credentials
        // 1. Create OAuth 2.0 Client ID
        // 2. Application type: Web application
        // 3. Authorized JavaScript origins: Add your domain (e.g., https://yourdomain.com)
        // 4. Authorized redirect URIs: Add your domain
        const GOOGLE_OAUTH_CLIENT_ID = '1087570888908-4g9jboc2hoi1dl9t9qs5hmnak6ct1t24.apps.googleusercontent.com';
        
        //  AUTHORIZED EMAILS: List of Google email addresses that can access the admin panel
        // SECURITY NOTE: For better security, move this list to your Google Apps Script
        // and fetch it via an API call instead of storing it in the client code.
        const AUTHORIZED_EMAILS = [
            'ernest@oddplusevenstudio.com',
            // Add more authorized emails here (one per line, comma-separated)
            // Example: 'admin@example.com',
            // Example: 'user@example.com',
            // Example: 'team-member@example.com',
        ];
        
        // Parse JWT token to get user info
        function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (e) {
                console.error('Error parsing JWT:', e);
                return null;
            }
        }
        
        // Handle Google OAuth callback
        function handleCredentialResponse(response) {
            const errorDiv = document.getElementById('loginError');
            const errorText = document.getElementById('loginErrorText');
            
            try {
                // Parse the JWT token
                const payload = parseJwt(response.credential);
                
                if (!payload || !payload.email) {
                    throw new Error('Invalid token - missing email');
                }
                
                const userEmail = payload.email;
                const userName = payload.name || userEmail;
                
                console.log('Google Sign-In successful:', userEmail);
                
                // Check if email is authorized
                if (AUTHORIZED_EMAILS.includes(userEmail)) {
                    // Authorized - hide login overlay
                document.getElementById('loginOverlay').style.display = 'none';
                
                    // Store session info
                sessionStorage.setItem('adminLoggedIn', 'true');
                    sessionStorage.setItem('adminEmail', userEmail);
                    sessionStorage.setItem('adminName', userName);
                    
                    // Show success message briefly
                    const overlay = document.getElementById('loginOverlay');
                    const overlayContent = overlay.querySelector('div');
                    overlayContent.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #22c55e; font-size: 48px; margin-bottom: 20px;"></div>
                            <h2 style="color: #4E6B52; margin: 0 0 10px 0;">Welcome, ${userName}!</h2>
                            <p style="color: #6c757d; margin: 0;">Loading admin panel...</p>
                        </div>
                    `;
                    
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 1000);
                
            } else {
                    // Not authorized
                    errorText.textContent = `Access denied. ${userEmail} is not authorized to access this admin panel.`;
                errorDiv.style.display = 'block';
                
                // Shake animation
                const overlay = document.getElementById('loginOverlay');
                overlay.style.animation = 'shake 0.5s';
                setTimeout(() => { overlay.style.animation = ''; }, 500);
                    
                    // Log the unauthorized attempt
                    console.warn('Unauthorized access attempt:', userEmail);
                }
            } catch (error) {
                console.error('Error processing Google Sign-In:', error);
                errorText.textContent = 'Authentication failed. Please try again.';
                errorDiv.style.display = 'block';
            }
        }
        
        // Initialize Google Sign-In
        let initAttempts = 0;
        const MAX_INIT_ATTEMPTS = 50; // 5 seconds max wait
        
        function initializeGoogleSignIn() {
            initAttempts++;
            const loadingMessage = document.getElementById('loadingMessage');
            const errorDiv = document.getElementById('loginError');
            const errorText = document.getElementById('loginErrorText');
            const buttonContainer = document.getElementById('googleSignInContainer');
            const fallbackContainer = document.getElementById('fallbackButtonContainer');
            
            console.log('Initializing Google Sign-In, attempt:', initAttempts);
            console.log('Client ID:', GOOGLE_OAUTH_CLIENT_ID);
            console.log('Google object:', typeof google !== 'undefined' ? 'exists' : 'missing');
            
            // Check if Client ID is configured (check for undefined, empty, or placeholder)
            if (!GOOGLE_OAUTH_CLIENT_ID || 
                GOOGLE_OAUTH_CLIENT_ID === 'YOUR_CLIENT_ID.apps.googleusercontent.com' ||
                GOOGLE_OAUTH_CLIENT_ID.trim() === '') {
                if (loadingMessage) loadingMessage.style.display = 'none';
                errorText.innerHTML = `
                    <strong> Configuration Required:</strong><br>
                    Google OAuth Client ID is not configured or is invalid.<br>
                    <small>See line ~5393 in index-sheets.html<br>
                    Replace 'YOUR_CLIENT_ID.apps.googleusercontent.com' with your actual Client ID from Google Cloud Console</small>
                `;
                errorDiv.style.display = 'block';
                // Show fallback button
                if (fallbackContainer) {
                    fallbackContainer.style.display = 'block';
                }
                return;
            }
            
            // Wait for Google Identity Services to load
            if (typeof google !== 'undefined' && google.accounts && google.accounts.id) {
                try {
                    if (loadingMessage) loadingMessage.style.display = 'none';
                    
                    console.log(' Google Identity Services loaded, initializing...');
                    console.log(' Current origin:', window.location.origin);
                    console.log(' Client ID:', GOOGLE_OAUTH_CLIENT_ID);
                    
                    // Validate Client ID format before calling Google API
                    if (!GOOGLE_OAUTH_CLIENT_ID.includes('.apps.googleusercontent.com')) {
                        throw new Error('Invalid Client ID format. Must end with .apps.googleusercontent.com');
                    }
                    
                    google.accounts.id.initialize({
                        client_id: GOOGLE_OAUTH_CLIENT_ID,
                        callback: handleCredentialResponse,
                        auto_select: false,
                        cancel_on_tap_outside: true
                    });
                    
                    console.log(' Google Sign-In initialized successfully');
                    console.log(' Rendering button...');
                    
                    // Clear container first
                    buttonContainer.innerHTML = '';
                    
                    // Render the sign-in button
                    google.accounts.id.renderButton(
                        buttonContainer,
                        {
                            theme: 'filled_blue',
                            size: 'large',
                            width: 300,
                            text: 'signin_with',
                            type: 'standard'
                        }
                    );
                    
                    console.log(' Google Sign-In button rendered successfully!');
                    console.log(' Everything looks good! The button should be visible now.');
                    
                    // Hide fallback button and loading message
                    if (fallbackContainer) fallbackContainer.style.display = 'none';
                    if (loadingMessage) loadingMessage.style.display = 'none';
                    
                } catch (error) {
                    console.error(' Error rendering Google Sign-In button:', error);
                    console.error('Error details:', {
                        message: error.message,
                        name: error.name,
                        stack: error.stack,
                        origin: window.location.origin,
                        clientId: GOOGLE_OAUTH_CLIENT_ID
                    });
                    
                    if (loadingMessage) loadingMessage.style.display = 'none';
                    
                    // Show fallback button
                    if (fallbackContainer) {
                        fallbackContainer.style.display = 'block';
                        errorText.innerHTML = `
                            <strong> Error loading Google button:</strong><br>
                            ${error.message || 'Unknown error'}<br>
                            <small>This usually means your domain isn't authorized yet or Google hasn't updated (can take 1-5 minutes).<br>
                            Check the browser console (F12) for more details.<br>
                            Click the button below to try manual sign-in.</small>
                        `;
                        errorDiv.style.display = 'block';
                    } else {
                        errorText.innerHTML = `
                            <strong> Error loading Google Sign-In:</strong><br>
                            ${error.message || 'Unknown error'}<br>
                            <small>Check your browser console for more details.</small>
                        `;
                        errorDiv.style.display = 'block';
                    }
                }
            } else {
                // Retry after a short delay if Google Identity Services hasn't loaded yet
                if (initAttempts < MAX_INIT_ATTEMPTS) {
                    if (loadingMessage) {
                        loadingMessage.textContent = `Loading sign-in button... (${initAttempts}/${MAX_INIT_ATTEMPTS})`;
                    }
                    setTimeout(initializeGoogleSignIn, 100);
                } else {
                    // Timeout - Google script failed to load, show fallback
                    console.error('Google Identity Services failed to load after', MAX_INIT_ATTEMPTS, 'attempts');
                    if (loadingMessage) loadingMessage.style.display = 'none';
                    
                    // Always show fallback button if Google's button doesn't load
                    if (fallbackContainer) {
                        fallbackContainer.style.display = 'block';
                        const currentOrigin = window.location.origin;
                        errorText.innerHTML = `
                            <strong> Google Sign-In script didn't load:</strong><br>
                            <strong>Your current domain:</strong> <code style="background: #f8f9fa; padding: 2px 6px; border-radius: 3px;">${currentOrigin}</code><br>
                            <br>
                            <strong>To fix:</strong><br>
                            1. Go to: <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color: #4285f4;">Google Cloud Console  Credentials</a><br>
                            2. Click your OAuth 2.0 Client ID<br>
                            3. Under "Authorized JavaScript origins", click "+ ADD URI"<br>
                            4. Add: <code style="background: #f8f9fa; padding: 2px 6px; border-radius: 3px;">${currentOrigin}</code><br>
                            5. Also add: <code style="background: #f8f9fa; padding: 2px 6px; border-radius: 3px;">http://localhost</code> (for local testing)<br>
                            6. Under "Authorized redirect URIs", add the same URLs<br>
                            7. Click "SAVE"<br>
                            8. Wait 1-2 minutes, then refresh this page<br>
                            <br>
                            <strong>Click the button below to try manual sign-in:</strong>
                        `;
                        errorDiv.style.display = 'block';
                    } else {
                        errorText.innerHTML = `
                            <strong> Failed to load Google Sign-In:</strong><br>
                            Google Identity Services script did not load.<br>
                            <small>Please check your internet connection and try refreshing the page.</small>
                        `;
                        errorDiv.style.display = 'block';
                    }
                }
            }
        }
        
        // Fallback function to trigger Google Sign-In manually
        // Make it globally accessible for onclick handlers
        window.triggerGoogleSignIn = function triggerGoogleSignIn() {
            console.log('Triggering manual Google Sign-In');
            console.log('Client ID:', GOOGLE_OAUTH_CLIENT_ID);
            console.log('Google object:', typeof google !== 'undefined' ? 'exists' : 'missing');
            
            // Check if Client ID is configured
            if (!GOOGLE_OAUTH_CLIENT_ID || GOOGLE_OAUTH_CLIENT_ID === 'YOUR_CLIENT_ID.apps.googleusercontent.com') {
                alert(' Google OAuth Client ID is not configured.\n\nPlease set GOOGLE_OAUTH_CLIENT_ID in the code.');
                return;
            }
            
            // Try to use the One Tap prompt if available
            if (typeof google !== 'undefined' && google.accounts && google.accounts.id) {
                try {
                    // First, ensure Google is initialized with our Client ID
                    google.accounts.id.initialize({
                        client_id: GOOGLE_OAUTH_CLIENT_ID,
                        callback: handleCredentialResponse,
                        auto_select: false,
                        cancel_on_tap_outside: true
                    });
                    
                    // Try to show One Tap prompt
                    google.accounts.id.prompt((notification) => {
                        console.log('One Tap notification:', notification);
                        if (notification.isNotDisplayed() || notification.isSkippedMoment()) {
                            // One Tap failed, try popup using renderButton
                            const buttonContainer = document.getElementById('googleSignInContainer');
                            if (buttonContainer) {
                                buttonContainer.innerHTML = '';
                                google.accounts.id.renderButton(
                                    buttonContainer,
                                    {
                                        theme: 'filled_blue',
                                        size: 'large',
                                        width: '100%',
                                        text: 'signin_with',
                                        type: 'standard',
                                        click_listener: function() {
                                            // This will trigger the callback
                                        }
                                    }
                                );
                                // Click the button programmatically
                                const button = buttonContainer.querySelector('div[role="button"]');
                                if (button) {
                                    button.click();
                                } else {
                                    // Fallback: redirect to OAuth
                                    window.location.href = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${GOOGLE_OAUTH_CLIENT_ID}&redirect_uri=${encodeURIComponent(window.location.origin + window.location.pathname)}&response_type=token&scope=openid%20profile%20email&nonce=${Date.now()}`;
                                }
                            } else {
                                // Fallback: redirect to OAuth
                                window.location.href = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${GOOGLE_OAUTH_CLIENT_ID}&redirect_uri=${encodeURIComponent(window.location.origin + window.location.pathname)}&response_type=token&scope=openid%20profile%20email&nonce=${Date.now()}`;
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error with One Tap:', error);
                    // Fallback: redirect to OAuth popup
                    window.location.href = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${GOOGLE_OAUTH_CLIENT_ID}&redirect_uri=${encodeURIComponent(window.location.origin + window.location.pathname)}&response_type=token&scope=openid%20profile%20email&nonce=${Date.now()}`;
                }
            } else {
                const currentOrigin = window.location.origin;
                alert(' Google OAuth Client ID is not configured.\n\nPlease set GOOGLE_OAUTH_CLIENT_ID in the code.');
            }
        };
        
        // Check if user is already logged in
        window.addEventListener('load', function() {
            //  TESTING: Skip authentication if disabled
            if (!ENABLE_GOOGLE_AUTH) {
                console.log(' Google OAuth disabled for testing - skipping login');
                // Set flag in localStorage for immediate hiding on next page load
                localStorage.setItem('skipAuth', 'true');
                const overlay = document.getElementById('loginOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
                document.body.classList.add('logged-in');
                return; // Skip all auth checks
            } else {
                // Auth is enabled, clear the skip flag
                localStorage.removeItem('skipAuth');
            }
            
            const isLoggedIn = sessionStorage.getItem('adminLoggedIn');
            const adminEmail = sessionStorage.getItem('adminEmail');
            
            // Check if running from file:// protocol (won't work with Google OAuth)
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Get current origin for helpful error messages
            const currentOrigin = window.location.origin;
            const currentHost = window.location.host;
            
            if (isFileProtocol) {
                const errorDiv = document.getElementById('loginError');
                const errorText = document.getElementById('loginErrorText');
                const loadingMessage = document.getElementById('loadingMessage');
                const fallbackContainer = document.getElementById('fallbackButtonContainer');
                
                if (loadingMessage) loadingMessage.style.display = 'none';
                errorText.innerHTML = `
                    <strong> File Protocol Detected:</strong><br>
                    Google OAuth doesn't work with file:// protocol.<br>
                    <strong>Solution:</strong> Run a local web server:<br>
                    <code style="background: #f8f9fa; padding: 4px 8px; border-radius: 4px; display: block; margin: 10px 0;">
                        python3 -m http.server 8000
                    </code>
                    Then open: <code>http://localhost:8000/index-sheets.html</code>
                `;
                errorDiv.style.display = 'block';
                
                // Show fallback button that explains the issue
                if (fallbackContainer) {
                    fallbackContainer.innerHTML = `
                        <button disabled style="width: 100%; background: #ccc; color: #666; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: not-allowed;">
                            Sign in with Google (Not Available - Use Local Server)
                        </button>
                    `;
                    fallbackContainer.style.display = 'block';
                }
                return;
            }
            
            // If logged in but no email (old password-based login), force logout
            if (isLoggedIn === 'true' && !adminEmail) {
                console.log('Detected old password-based session. Forcing logout for Google OAuth.');
                sessionStorage.clear();
                localStorage.removeItem('adminLoggedIn');
                // Fall through to show login
            }
            
            // Check if properly logged in with Google OAuth
            if (isLoggedIn === 'true' && adminEmail) {
                document.getElementById('loginOverlay').style.display = 'none';
            } else {
                // Initialize Google Sign-In when page loads
                // Wait a bit for the page to fully render
                setTimeout(function() {
                    initializeGoogleSignIn();
                    // Update diagnostics after a moment
                    setTimeout(updateDiagnostics, 1000);
                }, 500);
            }
        });
        
        // Test and diagnostic functions
        function testGoogleSignIn() {
            console.log(' Testing Google Sign-In configuration...');
            const origin = window.location.origin;
            const clientId = GOOGLE_OAUTH_CLIENT_ID;
            
            console.log(' Current origin:', origin);
            console.log(' Client ID:', clientId);
            console.log(' Google script loaded:', typeof google !== 'undefined' ? ' Yes' : ' No');
            
            if (typeof google !== 'undefined' && google.accounts && google.accounts.id) {
                try {
                    google.accounts.id.initialize({
                        client_id: clientId,
                        callback: function(response) {
                            console.log(' Test successful! Got credential response');
                            alert(' Test successful! Google Sign-In is working.\n\nIf you see this, your configuration is correct!');
                        },
                        auto_select: false
                    });
                    
                    // Try to render a test button
                    const testDiv = document.createElement('div');
                    document.body.appendChild(testDiv);
                    
                    google.accounts.id.renderButton(testDiv, {
                        theme: 'filled_blue',
                        size: 'large',
                        text: 'signin_with'
                    });
                    
                    console.log(' Test button rendered - configuration is correct!');
                    alert(' Test successful! Google Sign-In button rendered.\n\nYour configuration is working correctly!\n\nIf you still don\'t see the button on the login screen, wait 1-2 minutes for Google\'s servers to update.');
                    
                    // Remove test button
                    setTimeout(() => testDiv.remove(), 5000);
                } catch (error) {
                    console.error(' Test failed:', error);
                    alert(' Test failed: ' + error.message + '\n\nThis usually means:\n1. Your domain isn\'t authorized yet (wait 1-5 minutes)\n2. Or there\'s a configuration issue\n\nCheck the console for details.');
                }
            } else {
                alert(' Google Identity Services script not loaded.\n\nCheck:\n1. Your internet connection\n2. Browser console for errors\n3. That the script tag is in the HTML');
            }
        }
        
        function checkOAuthConfig() {
            const origin = window.location.origin;
            const clientId = GOOGLE_OAUTH_CLIENT_ID;
            
            const config = {
                origin: origin,
                clientId: clientId,
                googleLoaded: typeof google !== 'undefined',
                buttonContainer: document.getElementById('googleSignInContainer') ? 'exists' : 'missing',
                authorizedEmails: AUTHORIZED_EMAILS.length
            };
            
            console.log(' OAuth Configuration Check:', config);
            
            let message = ' OAuth Configuration:\n\n';
            message += `Domain: ${origin}\n`;
            message += `Client ID: ${clientId.substring(0, 20)}...\n`;
            message += `Google Script: ${config.googleLoaded ? ' Loaded' : ' Not loaded'}\n`;
            message += `Button Container: ${config.buttonContainer}\n`;
            message += `Authorized Emails: ${config.authorizedEmails}\n\n`;
            
            if (config.googleLoaded) {
                message += ' Google script is loaded\n';
            } else {
                message += ' Google script not loaded - check internet connection\n';
            }
            
            message += `\nMake sure "${origin}" is added to Google Cloud Console  Authorized JavaScript origins`;
            
            alert(message);
            console.log('Full config:', config);
        }
        
        // Update diagnostic info on load
        function updateDiagnostics() {
            const diagSection = document.getElementById('diagnosticSection');
            if (diagSection) {
                document.getElementById('diagOrigin').textContent = window.location.origin;
                document.getElementById('diagClientId').textContent = GOOGLE_OAUTH_CLIENT_ID.substring(0, 30) + '...';
                document.getElementById('diagGoogleLoaded').textContent = typeof google !== 'undefined' ? ' Yes' : ' No';
                document.getElementById('diagContainer').textContent = document.getElementById('googleSignInContainer') ? ' Found' : ' Missing';
                
                const status = typeof google !== 'undefined' && document.getElementById('googleSignInContainer') ? ' Ready' : ' Waiting...';
                document.getElementById('diagStatus').textContent = status;
                
                // Show diagnostic section
                diagSection.style.display = 'block';
            }
        }
        
        // Logout function
        window.logout = function logout() {
            // Revoke Google token if available
            if (typeof google !== 'undefined' && google.accounts) {
                google.accounts.id.disableAutoSelect();
            }
            
            // Clear session data
            sessionStorage.removeItem('adminLoggedIn');
            sessionStorage.removeItem('adminEmail');
            sessionStorage.removeItem('adminName');
            localStorage.removeItem('adminLoggedIn');
            
            // Reload page to show login screen
            location.reload();
        }
        
        // Ensure all functions are available immediately
        console.log(' admin.js loaded successfully');
        console.log(' Functions available:', {
            reloadFromSheets: typeof window.reloadFromSheets,
            saveAllToSheets: typeof window.saveAllToSheets,
            downloadCSV: typeof window.downloadCSV,
            openAddModal: typeof window.openAddModal,
            logout: typeof window.logout,
            switchTab: typeof window.switchTab,
            filterAdminByType: typeof window.filterAdminByType,
            closeModal: typeof window.closeModal
        });
    </script>
    
    <script>
        // Fallback: If critical functions fail to load, show error after 2 seconds
        window.addEventListener('load', function() {
            setTimeout(function() {
                // Check if critical functions exist
                if (typeof initializeGoogleSignIn === 'undefined') {
            const errorDiv = document.getElementById('loginError');
                    const errorText = document.getElementById('loginErrorText');
                    const loadingMessage = document.getElementById('loadingMessage');
                    
                    if (loadingMessage) loadingMessage.style.display = 'none';
                    if (errorDiv && errorText) {
                        errorText.innerHTML = `
                            <strong> JavaScript Error:</strong><br>
                            Critical functions failed to load. Please check the browser console for errors.
                        `;
                errorDiv.style.display = 'block';
                    }
                }
            }, 2000);
        });
        
        // Google Maps functionality
        let map = null;
        let markers = [];
        let markerCluster = null;
        let mapVisible = true; // Start visible
        let infoWindow = null;
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function fixEncoding(text) {
            if (!text) return '';
            return text.replace(//g, "'").replace(/"/g, '"').replace(/"/g, '"');
        }
        
        function normalizeImageUrl(url) {
            if (!url) return '';
            // If it's a base64 image, return as is
            if (url.startsWith('data:image/')) return url;
            // If it's a relative path, make it absolute
            if (url.startsWith('/')) return url;
            // If it's a full URL, return as is
            if (url.startsWith('http://') || url.startsWith('https://')) return url;
            // Otherwise, assume it's an ImageKit URL
            return url;
        }
        
        function initMap() {
            // Check if map element exists
            const mapElement = document.getElementById('map');
            if (!mapElement) {
                console.log('Map element not found yet, retrying...');
                setTimeout(initMap, 100);
                return;
            }
            
            // Check if Google Maps API is loaded
            if (typeof google === 'undefined' || typeof google.maps === 'undefined' || typeof google.maps.Map === 'undefined') {
                console.log('Google Maps API not loaded yet, retrying...');
                // Retry after a short delay
                setTimeout(initMap, 100);
                return;
            }
            
            if (!map) {
                try {
                    // Initialize Google Map centered on Nelson County, VA
                    map = new google.maps.Map(mapElement, {
                        center: { lat: 37.8, lng: -79.0 },
                        zoom: 10,
                        mapTypeControl: false,
                        zoomControl: true,
                        zoomControlOptions: {
                            position: google.maps.ControlPosition ? google.maps.ControlPosition.RIGHT_TOP : 1
                        },
                        streetViewControl: false,
                        fullscreenControl: false,
                        keyboardShortcuts: false,
                        gestureHandling: 'cooperative',
                        styles: [
                            // Hide all points of interest
                            {
                                featureType: "poi",
                                elementType: "labels",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "poi.business",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "poi",
                                stylers: [{ visibility: "off" }]
                            },
                            // Hide transit
                            {
                                featureType: "transit",
                                elementType: "labels",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "transit.station",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "transit.line",
                                stylers: [{ visibility: "off" }]
                            },
                            // Simplify administrative boundaries
                            {
                                featureType: "administrative",
                                elementType: "geometry.stroke",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "administrative.locality",
                                elementType: "labels",
                                stylers: [{ visibility: "simplified" }]
                            },
                            {
                                featureType: "administrative.neighborhood",
                                elementType: "labels",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "administrative.land_parcel",
                                stylers: [{ visibility: "off" }]
                            },
                            // Hide minor/local roads and their labels
                            {
                                featureType: "road.local",
                                elementType: "labels",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "road.local",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "road",
                                elementType: "labels.text.fill",
                                stylers: [{ visibility: "simplified" }]
                            },
                            // Hide water labels
                            {
                                featureType: "water",
                                elementType: "labels",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "water",
                                elementType: "labels.text",
                                stylers: [{ visibility: "off" }]
                            },
                            // Natural features
                            {
                                featureType: "landscape.natural",
                                stylers: [
                                    { color: "#E1F3C9" }
                                ]
                            },
                            {
                                featureType: "water",
                                stylers: [
                                    { color: "#CAE8F2" }
                                ]
                            }
                        ]
                    });
                    
                    // Apply rounded corners to zoom controls after map loads
                    setTimeout(() => {
                        const mapContainer = document.getElementById('map');
                        if (mapContainer) {
                            const buttons = mapContainer.querySelectorAll('button');
                            buttons.forEach(button => {
                                if (button.getAttribute('aria-label') && button.getAttribute('aria-label').includes('Zoom')) {
                                    button.style.borderRadius = '16px';
                                }
                            });
                            
                            const zoomControls = mapContainer.querySelectorAll('[aria-label*="Zoom"]');
                            zoomControls.forEach(control => {
                                const parent = control.closest('div[style*="position"]');
                                if (parent) {
                                    parent.style.borderRadius = '16px';
                                    parent.style.overflow = 'hidden';
                                }
                            });
                        }
                    }, 500);
                    
                    // Also apply on map idle event
                    map.addListener('idle', () => {
                        const mapContainer = document.getElementById('map');
                        if (mapContainer) {
                            const buttons = mapContainer.querySelectorAll('button');
                            buttons.forEach(button => {
                                if (button.getAttribute('aria-label') && button.getAttribute('aria-label').includes('Zoom')) {
                                    button.style.borderRadius = '16px';
                                }
                                const parent = button.parentElement;
                                if (parent && parent.style.position === 'absolute') {
                                    parent.style.borderRadius = '16px';
                                    parent.style.overflow = 'hidden';
                                }
                            });
                        }
                    });
                    
                    // Create single info window to reuse
                    infoWindow = new google.maps.InfoWindow();
                } catch (e) {
                    console.error('Error initializing map:', e);
                    setTimeout(function() {
                        if (!map) {
                            initMap();
                        }
                    }, 500);
                }
            }
        }
        
        function updateMapMarkers(listings) {
            if (!map) return;
            
            // Clear existing clusterer if it exists
            if (markerCluster) {
                markerCluster.clearMarkers();
                markerCluster = null;
            }
            
            // Clear existing markers
            markers.forEach(function(marker) {
                marker.setMap(null);
            });
            markers = [];
            
            // Create bounds
            var bounds = new google.maps.LatLngBounds();
            var markersToAdd = [];
            var geocodeCount = 0;
            var totalListings = listings.length;
            
            // Add markers for each listing
            listings.forEach(function(listing) {
                geocodeAddress(listing.address, function(lat, lng) {
                    if (lat && lng) {
                        var position = { lat: lat, lng: lng };
                        
                        // Create custom marker icon (SVG)
                        var markerIcon = {
                            path: 'M 12,2 C 8.1340068,2 5,5.1340068 5,9 c 0,5.25 7,13 7,13 0,0 7,-7.75 7,-13 0,-3.8659932 -3.134007,-7 -7,-7 z',
                            fillColor: '#E3795C',
                            fillOpacity: 1,
                            strokeColor: '#ffffff',
                            strokeWeight: 2,
                            scale: 1.5,
                            anchor: new google.maps.Point(12, 22)
                        };
                        
                        // Create marker
                        var marker = new google.maps.Marker({
                            position: position,
                            icon: markerIcon,
                            title: fixEncoding(listing.name),
                            animation: google.maps.Animation.DROP
                        });
                        
                        // Create popup content
                        var imageUrl = listing.image1 ? normalizeImageUrl(listing.image1) : 'https://via.placeholder.com/400x400?text=No+Image';
                        var cardWidth = (window.innerWidth < 969) ? 120 : 200;
                        var cardHeight = cardWidth; // Square
                        var fontSize = (window.innerWidth < 969) ? 12 : 14;
                        var gradientHeight = (window.innerWidth < 969) ? 50 : 60;
                        var simpleContent = '<div style="padding: 0 12px 16px 12px !important; margin: 0 !important; text-align: center; cursor: pointer; width: ' + cardWidth + 'px; height: ' + cardHeight + 'px; position: relative; overflow: hidden; border-radius: 12px; line-height: 0; font-size: 0; background-image: url(\'' + imageUrl + '\'); background-size: cover !important; background-position: center center !important; background-repeat: no-repeat !important; display: flex; flex-direction: column; justify-content: flex-end; border: 4px solid #ffffff; outline: 0; box-sizing: border-box; min-width: ' + cardWidth + 'px; min-height: ' + cardHeight + 'px;" onclick="if(window.filterByListingName) filterByListingName(\'' + escapeHtml(fixEncoding(listing.name)).replace(/'/g, "\\'") + '\'); if(window.google && window.google.maps) google.maps.event.trigger(map, \'click\');">' + 
                            '<div style="position: absolute; bottom: 0; left: 0; right: 0; height: ' + gradientHeight + 'px; background: linear-gradient(to top, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0)); pointer-events: none; z-index: 1; margin: 0; padding: 0;"></div>' +
                            '<div style="font-size: ' + fontSize + 'px; font-weight: 600; color: #ffffff; line-height: 1.1; padding: 0 10px 18px 10px; margin: 0; position: relative; z-index: 2; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">' + escapeHtml(fixEncoding(listing.name)) + '</div>' +
                            '</div>';
                        
                        // Add click listener to show info window
                        marker.addListener('click', function() {
                            infoWindow.setContent(simpleContent);
                            infoWindow.open(map, marker);
                        });
                        
                        markers.push(marker);
                        markersToAdd.push(marker);
                        bounds.extend(position);
                    }
                    
                    geocodeCount++;
                    // When all geocoding is done, add markers to map
                    if (geocodeCount === totalListings) {
                        // Add markers directly to map (no clustering for now)
                        markersToAdd.forEach(function(marker) {
                            marker.setMap(map);
                        });
                        
                        // Fit bounds with animation if there are markers
                        if (markers.length > 0) {
                            setTimeout(function() {
                                map.fitBounds(bounds);
                                
                                // Limit max zoom
                                var listener = google.maps.event.addListener(map, "idle", function() {
                                    if (map.getZoom() > 13) map.setZoom(13);
                                    google.maps.event.removeListener(listener);
                                });
                            }, 500);
                        }
                    }
                });
            });
        }
        
        // Simple geocoding function (uses approximate coordinates for demo)
        function geocodeAddress(address, callback) {
            if (!address) {
                callback(37.8 + (Math.random() - 0.5) * 0.1, -79.0 + (Math.random() - 0.5) * 0.1);
                return;
            }
            
            // Approximate coordinates for Nelson County area locations
            var locations = {
                'Roseland': [37.8167, -79.0833],
                'Montebello': [37.8500, -79.1333],
                'Wintergreen': [37.9167, -79.0000],
                'Afton': [38.0333, -78.8333],
                'Lovingston': [37.7667, -78.8667],
                'Nellysford': [37.9000, -78.8833]
            };
            
            // Try to match address to known locations
            for (var loc in locations) {
                if (address.includes(loc)) {
                    var coords = locations[loc];
                    // Add small random offset for multiple locations in same area
                    var lat = coords[0] + (Math.random() - 0.5) * 0.02;
                    var lng = coords[1] + (Math.random() - 0.5) * 0.02;
                    callback(lat, lng);
                    return;
                }
            }
            
            // Default to center of Nelson County with random offset
            callback(37.8 + (Math.random() - 0.5) * 0.1, -79.0 + (Math.random() - 0.5) * 0.1);
        }
        
        function toggleMap() {
            var container = document.getElementById('mapContainer');
            var toggleIcon = document.getElementById('mapToggleIcon');
            var toggleText = container ? container.querySelector('.map-toggle-text') : null;
            
            if (!container || !toggleIcon) return;
            
            if (mapVisible) {
                container.classList.add('map-collapsed');
                // Change to plus icon
                toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M12 5v14m7-7H5"></path>';
                // Change text to "Open Map"
                if (toggleText) toggleText.textContent = 'Open Map';
                mapVisible = false;
            } else {
                container.classList.remove('map-collapsed');
                // Change to X icon
                toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>';
                // Change text to "Close Map"
                if (toggleText) toggleText.textContent = 'Close Map';
                mapVisible = true;
                // Trigger resize to fix display issues
                setTimeout(function() {
                    if (map) google.maps.event.trigger(map, 'resize');
                }, 100);
            }
        }
    </script>
    
    </div> <!-- End main-container -->
    
    <!-- Flip Overlay -->
    <div id="flipOverlay"></div>

</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

