<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- FRAMERs CODE ADDON - Adventure Directory -->
    <!-- This code addon displays an interactive directory of listings with filtering, search, and map integration -->
    <!-- 
    SETUP INSTRUCTIONS:
    1. Add this code to a Framer Code Component
    2. Ensure Google Maps API key is valid (or update the key below)
    3. Data will load from GitHub automatically (configured in frontpage.js)
    4. For Framer CMS integration, modify the data source in frontpage.js to use Framer CMS API
    
    URL PARAMETER SUPPORT (for cross-origin iframe):
    To enable URL parameters like ?search=wine to work when this is embedded in Framer,
    add this code to your Framer page (in a Code Component or Override):
    
    <script>
    window.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'getUrlParams' && event.data.source === 'find-your-adventure') {
            var params = {};
            var searchParams = new URLSearchParams(window.location.search);
            for (var pair of searchParams.entries()) {
                params[pair[0]] = pair[1];
            }
            event.source.postMessage({
                type: 'urlParamsResponse',
                params: params
            }, '*');
        }
    });
    </script>
    -->
    
    <!-- Google Maps API - Replace with your own key if needed -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDysf1CQM7-kZd_mhDcBIhp92o7Tb6SmAQ&libraries=places&callback=initMap" async defer></script>
    <!-- Marker Clusterer Library -->
    <script src="https://unpkg.com/@googlemaps/js-marker-clusterer/dist/index.min.js"></script>
    
    <!-- Embedded CSS -->
    <style>

/* ========================================
   THEME COLORS - EDIT HERE TO CHANGE THEME
   ======================================== */
:root {
    /* Background Colors */
    --bg-primary: #ffffff;
    --bg-secondary: #ffffff;
    --bg-hover: #f8f9fa;
    --card-bg: #ffffff;
    
    /* Text Colors */
    --text-primary: #212529;
    --text-secondary: #6c757d;
    
    /* Border & Shadow */
    --border-color: #e8e8e8;
    --shadow: rgba(0, 0, 0, 0.08);
    --shadow-hover: rgba(0, 0, 0, 0.12);
    
    /* Primary Theme Color - FOREST GREEN */
    --theme-primary: #2d6a4f;
    --theme-primary-hover: #1b4332;
    --theme-primary-light: rgba(45, 106, 79, 0.1);
    
    /* Secondary Theme Color - DARK GRAY */
    --theme-secondary: #404040;
    --theme-secondary-hover: #2a2a2a;
    --theme-secondary-light: rgba(64, 64, 64, 0.1);
    
    /* Accent Color - Can be used for highlights */
    --accent-color: #D65052;
    --accent-hover: #c44448;
    --accent-light: rgba(214, 80, 82, 0.1);
    
    /* Clear/Reset Color - ORANGE */
    --clear-color: #ff8c42;
    --clear-hover: #ff7a29;
    --clear-light: rgba(255, 140, 66, 0.1);
    
    /* Icon Colors - URL encoded for SVG */
    --icon-primary: %23212529;
    --icon-secondary: %236c757d;
    --icon-on-badge: %231a1a1a;
    --icon-location: %23D65052;
    --icon-hover-light: %23ffffff;
    
    /* Badge Colors */
    --badge-type-bg: #ffffff;
    --badge-type-color: #212529;
    --badge-area-bg: #ffffff;
    --badge-area-color: #212529;
    --badge-featured-bg: #bbc236;
    --badge-featured-color: #ffffff;
    --icon-featured: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23ffffff' stroke-width='1.8' stroke-linejoin='round' stroke-linecap='round'%3E%3Cpolygon points='12 3 14.09 8.26 19.78 8.84 15.39 12.97 16.66 18.6 12 15.64 7.34 18.6 8.61 12.97 4.22 8.84 9.91 8.26 12 3'/%3E%3C/svg%3E");
            
            /* SVG Icon Definitions - All icons with stroke='currentColor' */
            --icon-wine: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M8 22h8'/%3E%3Cpath d='M7 10h10'/%3E%3Cpath d='M12 15v7'/%3E%3Cpath d='M12 15a5 5 0 0 0 5-5c0-2-.5-4-2-8H9c-1.5 4-2 6-2 8a5 5 0 0 0 5 5z'/%3E%3C/svg%3E");
            --icon-beer: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M17 11h1a3 3 0 0 1 0 6h-1'/%3E%3Cpath d='M9 12v6'/%3E%3Cpath d='M13 12v6'/%3E%3Cpath d='M14 7.5c-1 0-1.44.5-3 .5s-2-.5-3-.5-1.72.5-2.5.5a2.5 2.5 0 0 1 0-5c.78 0 1.5.5 2.5.5s2.22-.5 3.5-.5 2.5.5 3.5.5a2.5 2.5 0 0 1 0 5c-.78 0-1.5-.5-2.5-.5z'/%3E%3Cpath d='M5 8v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V8'/%3E%3C/svg%3E");
            --icon-spirits: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M8 2h8l.5 3h-9z'/%3E%3Cpath d='M7.5 5h9l1 12a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2z'/%3E%3Cpath d='M10 22v-3'/%3E%3Cpath d='M14 22v-3'/%3E%3C/svg%3E");
            --icon-cocktail: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 3l9 9v9'/%3E%3Cpath d='M21 3l-9 9'/%3E%3Cpath d='M3 3h18'/%3E%3Cpath d='M9 21h6'/%3E%3C/svg%3E");
            --icon-coffee: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M18 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z'/%3E%3Cpath d='M6 1v3'/%3E%3Cpath d='M10 1v3'/%3E%3Cpath d='M14 1v3'/%3E%3C/svg%3E");
            --icon-tea: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M18 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z'/%3E%3Cpath d='M6 1v2'/%3E%3Cpath d='M10 1v2'/%3E%3Cpath d='M14 1v2'/%3E%3Cpath d='M6 4v1'/%3E%3Cpath d='M10 4v1'/%3E%3Cpath d='M14 4v1'/%3E%3C/svg%3E");
            --icon-restaurant: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 2v7c0 1.1.9 2 2 2h0a2 2 0 0 0 2-2V2'/%3E%3Cpath d='M7 2v20'/%3E%3Cpath d='M21 15V2a5 5 0 0 0-5 5v8'/%3E%3Cpath d='M21 15v7'/%3E%3C/svg%3E");
            --icon-bakery: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M20 10c0-4.4-3.6-8-8-8s-8 3.6-8 8c0 .9.1 1.7.4 2.5L6 21h12l1.6-8.5c.3-.8.4-1.6.4-2.5z'/%3E%3Cpath d='M6 10h12'/%3E%3C/svg%3E");
            --icon-cheese: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m2 16 10 6V12L2 6z'/%3E%3Cpath d='m12 22 10-6V6l-10 6'/%3E%3Cpath d='M2 16V6l10-6 10 6v10'/%3E%3Ccircle cx='7' cy='13' r='1'/%3E%3Ccircle cx='17' cy='13' r='1'/%3E%3C/svg%3E");
            --icon-chocolate: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='3' rx='2'/%3E%3Cpath d='M3 9h18'/%3E%3Cpath d='M3 15h18'/%3E%3Cpath d='M9 3v18'/%3E%3Cpath d='M15 3v18'/%3E%3C/svg%3E");
            --icon-museum: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m3 21 18 0'/%3E%3Cpath d='M3 7v1a3 3 0 0 0 6 0V7'/%3E%3Cpath d='M9 21v-9'/%3E%3Cpath d='M15 7v1a3 3 0 0 0 6 0V7'/%3E%3Cpath d='M21 21v-9'/%3E%3Cpath d='M3 7h18L12 3z'/%3E%3C/svg%3E");
            --icon-art: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4'/%3E%3Cpolyline points='7 10 12 15 17 10'/%3E%3Cline x1='12' x2='12' y1='15' y2='3'/%3E%3C/svg%3E");
            --icon-gallery: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='3' rx='2' ry='2'/%3E%3Ccircle cx='9' cy='9' r='2'/%3E%3Cpath d='m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21'/%3E%3C/svg%3E");
            --icon-hiking: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M8.76,6.63a1.09,1.09,0,0,1,2,0l2.8,5.53v0L15,8.9a1,1,0,0,1,1.8,0L21,18H3Z'/%3E%3C/svg%3E");
            --icon-cycling: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='5.5' cy='17.5' r='3.5'/%3E%3Ccircle cx='18.5' cy='17.5' r='3.5'/%3E%3Cpath d='M15 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2z'/%3E%3Cpath d='m12 17.5-3.5-5.5L15 6'/%3E%3Cpath d='m12 6 3 5.5'/%3E%3C/svg%3E");
            --icon-activity: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3431 10.3431 9 12 9C13.6569 9 15 10.3431 15 12Z'/%3E%3Cpath d='M12 5V3'/%3E%3Cpath d='M17 7L19 5'/%3E%3Cpath d='M19 12H21'/%3E%3Cpath d='M17 17L19 19'/%3E%3Cpath d='M12 19V21'/%3E%3Cpath d='M7 17L5 19'/%3E%3Cpath d='M5 12H3'/%3E%3Cpath d='M5 5L7 7'/%3E%3C/svg%3E");
            --icon-kayaking: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 19v-3'/%3E%3Cpath d='M10 19v-3'/%3E%3Cpath d='M14 19v-3'/%3E%3Cpath d='M18 19v-3'/%3E%3Cpath d='M8 11V9'/%3E%3Cpath d='M16 11V9'/%3E%3Cpath d='M12 11V9'/%3E%3Cpath d='M2 15h20'/%3E%3Cpath d='M2 7a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v1.1c0 .2 0 .3-.1.5L20.4 13H3.6L2.1 8.6c-.1-.2-.1-.3-.1-.5z'/%3E%3C/svg%3E");
            --icon-spa: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 3a7 7 0 0 0-9 10h18a7 7 0 0 0-9-10z'/%3E%3Cpath d='M12 3v18'/%3E%3C/svg%3E");
            --icon-wellness: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.29 1.51 4.04 3 5.5l7 7z'/%3E%3C/svg%3E");
            --icon-shopping: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z'/%3E%3Cline x1='3' x2='21' y1='6' y2='6'/%3E%3Cpath d='M16 10a4 4 0 0 1-8 0'/%3E%3C/svg%3E");
            --icon-market: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 9 12 2l9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpolyline points='9 22 9 12 15 12 15 22'/%3E%3C/svg%3E");
            --icon-concert: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M9 18V5l12-2v13'/%3E%3Ccircle cx='6' cy='18' r='3'/%3E%3Ccircle cx='18' cy='16' r='3'/%3E%3C/svg%3E");
            --icon-theater: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 12a5 5 0 0 0 5 5 8 8 0 0 1 5 2 8 8 0 0 1 5-2 5 5 0 0 0 5-5V7h-5a8 8 0 0 0-5 2 8 8 0 0 0-5-2H2z'/%3E%3Cpath d='M6 11c1.5 0 3 .5 3 2-2 0-3 0-3-2z'/%3E%3Cpath d='M18 11c-1.5 0-3 .5-3 2 2 0 3 0 3-2z'/%3E%3C/svg%3E");
            --icon-cinema: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='3' rx='2'/%3E%3Cpath d='m16 10-4 4-4-4'/%3E%3C/svg%3E");
            --icon-festival: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M4 22h16'/%3E%3Cpath d='M6 18v-7'/%3E%3Cpath d='M10 18v-7'/%3E%3Cpath d='M14 18v-7'/%3E%3Cpath d='M18 18v-7'/%3E%3Cpath d='m4 11 2-2 2 2 2-2 2 2 2-2 2 2 2-2 2 2'/%3E%3Cpath d='M8 7V4c0-1.1.9-2 2-2h4a2 2 0 0 1 2 2v3'/%3E%3C/svg%3E");
            --icon-hotel: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 10h18V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2z'/%3E%3Cpath d='M21 14v8'/%3E%3Cpath d='M3 14v8'/%3E%3Cpath d='M3 14h18'/%3E%3C/svg%3E");
            --icon-lodging: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpolyline points='9 22 9 12 15 12 15 22'/%3E%3C/svg%3E");
            --icon-transport: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M19 17h2l.64-2.54c.24-.959.24-1.962 0-2.92l-1.07-4.27A3 3 0 0 0 17.66 5H4a2 2 0 0 0-2 2v10h2'/%3E%3Ccircle cx='6.5' cy='17.5' r='2.5'/%3E%3Ccircle cx='16.5' cy='17.5' r='2.5'/%3E%3C/svg%3E");
            --icon-train: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='16' height='16' x='4' y='3' rx='2'/%3E%3Cpath d='M4 11h16'/%3E%3Cpath d='M12 3v8'/%3E%3Cpath d='m8 19-2 3'/%3E%3Cpath d='m16 19 2 3'/%3E%3C/svg%3E");
            --icon-boat: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 21c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1 .6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1'/%3E%3Cpolyline points='7 4 2 9 7 14'/%3E%3Cpath d='M22 9 7 9 7 2 12 2z'/%3E%3C/svg%3E");
            --icon-scenic: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m8 2 1.88 1.88'/%3E%3Cpath d='M14.12 3.88 16 2'/%3E%3Cpath d='M9 7.13v-1a3.003 3.003 0 1 1 6 0v1'/%3E%3Cpath d='M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6'/%3E%3Cpath d='M12 20v-9'/%3E%3Cpath d='M6.53 9C4.6 8.8 3 7.1 3 5'/%3E%3Cpath d='M6 13H2'/%3E%3Cpath d='M3 21c0-2.1 1.7-3.9 3.8-4'/%3E%3Cpath d='M20.97 5c0 2.1-1.6 3.8-3.5 4'/%3E%3Cpath d='M22 13h-4'/%3E%3Cpath d='M17.2 17c2.1.1 3.8 1.9 3.8 4'/%3E%3C/svg%3E");
            --icon-viewpoint: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z'/%3E%3Ccircle cx='12' cy='12' r='3'/%3E%3C/svg%3E");
            --icon-park: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 22v-8.5'/%3E%3Cpath d='M7 12 3 8c-.6-.6-.9-1.3-.9-2 0-1.7 1.3-3 3-3 .7 0 1.4.3 2 .9l4 4 4-4c.6-.6 1.3-.9 2-.9 1.7 0 3 1.3 3 3 0 .7-.3 1.4-.9 2l-4 4'/%3E%3C/svg%3E");
            --icon-garden: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 22c-4.97 0-9-4.03-9-9 0-2.5 1-4.75 2.63-6.41 1.32.87 3.14.7 4.24-.4a3 3 0 0 1 4.24 0c1.1 1.1 2.92 1.27 4.24.4C19.97 8.25 21 10.5 21 13c0 4.97-4.03 9-9 9z'/%3E%3Cpath d='M12 2v7'/%3E%3C/svg%3E");
            --icon-beach: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M17.28 9.05a5.5 5.5 0 1 0-10.56 0A5.5 5.5 0 1 0 12 17.66a5.5 5.5 0 1 0 5.28-8.6z'/%3E%3Cpath d='M12 17.66 12 22'/%3E%3C/svg%3E");
            --icon-history: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpolyline points='12 6 12 12 16 14'/%3E%3C/svg%3E");
            --icon-culture: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M22 20v-9H2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2z'/%3E%3Cpath d='M18 11V4H6v7'/%3E%3Cpath d='m9 9 1.5-1.5'/%3E%3Cpath d='m15 9-1.5-1.5'/%3E%3C/svg%3E");
            --icon-architecture: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 21h18'/%3E%3Cpath d='M6 21V7'/%3E%3Cpath d='M10 21V7'/%3E%3Cpath d='M14 21V7'/%3E%3Cpath d='M18 21V7'/%3E%3Cpath d='M3 7h18L12 2 3 7z'/%3E%3C/svg%3E");
            --icon-local: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0z'/%3E%3Ccircle cx='12' cy='10' r='3'/%3E%3C/svg%3E");
            --icon-tour: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20'/%3E%3Cpath d='M2 12h20'/%3E%3C/svg%3E");
            --icon-workshop: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z'/%3E%3C/svg%3E");
            --icon-class: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20'/%3E%3C/svg%3E");
            --icon-food: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M18 8h1a4 4 0 0 1 0 8h-1'/%3E%3Cpath d='M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z'/%3E%3Cline x1='6' x2='6' y1='1' y2='4'/%3E%3Cline x1='10' x2='10' y1='1' y2='4'/%3E%3Cline x1='14' x2='14' y1='1' y2='4'/%3E%3C/svg%3E");
            --icon-cidery: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2C8.134 2 5 5.134 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.866-3.134-7-7-7z'/%3E%3Cpath d='M12 9v6'/%3E%3Ccircle cx='12' cy='9' r='1.5'/%3E%3C/svg%3E");
            --icon-indoor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpath d='M9 22V12h6v10'/%3E%3Ccircle cx='9' cy='9' r='1'/%3E%3Ccircle cx='15' cy='9' r='1'/%3E%3C/svg%3E");
            --icon-attraction: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolygon points='12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2'/%3E%3C/svg%3E");
            --icon-farm: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2v20'/%3E%3Cpath d='M12 2c-3 0-5 2-5 5s2 5 5 5 5-2 5-5-2-5-5-5z'/%3E%3Cpath d='M12 12c-2 0-4 1.5-4 3.5s2 3.5 4 3.5 4-1.5 4-3.5-2-3.5-4-3.5z'/%3E%3Cpath d='M12 18c-1.5 0-2.5 1-2.5 2s1 2 2.5 2 2.5-1 2.5-2-1-2-2.5-2z'/%3E%3C/svg%3E");
            --icon-default: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='12' y1='5' x2='12' y2='19'/%3E%3Cline x1='5' y1='12' x2='19' y2='12'/%3E%3C/svg%3E");
        }
        
        
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            max-width: 100vw;
        }
        html {
            overflow-x: hidden;
            overflow-y: auto;
            height: 100%;
            position: relative;
            scroll-padding-top: 0;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            overflow-y: auto;
            height: 100%;
            position: relative;
            scroll-padding-top: 0;
        }
        /* Ensure iframe content starts at top - add padding to account for sticky elements */
        .preview-container {
            padding-top: 0;
            scroll-margin-top: 0;
        }
        /* Only allow scrolling on specific elements that need it */
        .preview-sidebar .filter-content {
            overflow-y: auto;
        }
        
        /* SVG Icon Library */
        .icon-wine { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M8 2h8M12 2v20M7 2c0 4 1.5 8 5 10M17 2c0 4-1.5 8-5 10M12 12v0'/%3E%3Cellipse cx='12' cy='19' rx='3' ry='2'/%3E%3C/svg%3E"); }
        .icon-beer { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M17 11h1a3 3 0 0 1 0 6h-1M18 11V8a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v11a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-8'/%3E%3Cline x1='9' y1='11' x2='9' y2='17'/%3E%3Cline x1='13' y1='11' x2='13' y2='17'/%3E%3C/svg%3E"); }
        .icon-spirits { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M9 2h6l1 10a4 4 0 0 1-8 0L9 2z'/%3E%3Cline x1='12' y1='12' x2='12' y2='22'/%3E%3Cpath d='M8 22h8'/%3E%3C/svg%3E"); }
        .icon-cocktail { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M5 5l7 7v8M19 5l-7 7M5 5h14'/%3E%3Ccircle cx='12' cy='20' r='2'/%3E%3Cline x1='3' y1='3' x2='7' y2='7'/%3E%3C/svg%3E"); }
        .icon-coffee { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M17 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V8z'/%3E%3Cline x1='6' y1='1' x2='6' y2='4'/%3E%3Cline x1='10' y1='1' x2='10' y2='4'/%3E%3Cline x1='14' y1='1' x2='14' y2='4'/%3E%3C/svg%3E"); }
        .icon-tea { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M17 8h1a4 4 0 1 1 0 8h-1'/%3E%3Cpath d='M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V8z'/%3E%3Cpath d='M6 1v3M10 1v3M14 1v3' stroke-dasharray='1,2'/%3E%3C/svg%3E"); }
        .icon-restaurant { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 2v7c0 1.1.9 2 2 2h0a2 2 0 0 0 2-2V2M7 2v20M21 15V2v0a5 5 0 0 0-5 5v8'/%3E%3Cline x1='21' y1='15' x2='21' y2='22'/%3E%3C/svg%3E"); }
        .icon-bakery { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cellipse cx='12' cy='11' rx='7' ry='4'/%3E%3Cpath d='M12 7c-3.5 0-6 1.5-6 4v8c0 1 1.5 2 6 2s6-1 6-2v-8c0-2.5-2.5-4-6-4z'/%3E%3Cline x1='8' y1='14' x2='8' y2='14.01'/%3E%3Cline x1='12' y1='14' x2='12' y2='14.01'/%3E%3Cline x1='16' y1='14' x2='16' y2='14.01'/%3E%3C/svg%3E"); }
        .icon-cheese { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M2.4 10L12 3l9.6 7v8H2.4v-8z'/%3E%3Ccircle cx='8' cy='14' r='1.5'/%3E%3Ccircle cx='14' cy='13' r='1'/%3E%3Ccircle cx='11' cy='16' r='1'/%3E%3C/svg%3E"); }
        .icon-chocolate { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='4' y='4' width='16' height='16' rx='2'/%3E%3Cline x1='4' y1='12' x2='20' y2='12'/%3E%3Cline x1='12' y1='4' x2='12' y2='20'/%3E%3Cline x1='8' y1='4' x2='8' y2='12'/%3E%3Cline x1='16' y1='4' x2='16' y2='12'/%3E%3Cline x1='8' y1='12' x2='8' y2='20'/%3E%3Cline x1='16' y1='12' x2='16' y2='20'/%3E%3C/svg%3E"); }
        .icon-museum { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 21h18M4 21V10l8-7 8 7v11'/%3E%3Cline x1='8' y1='10' x2='8' y2='21'/%3E%3Cline x1='12' y1='10' x2='12' y2='21'/%3E%3Cline x1='16' y1='10' x2='16' y2='21'/%3E%3C/svg%3E"); }
        .icon-art { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='3' y='3' width='18' height='18' rx='2'/%3E%3Ccircle cx='8.5' cy='8.5' r='1.5'/%3E%3Cpath d='M21 15l-5-5L5 21'/%3E%3C/svg%3E"); }
        .icon-gallery { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='2' y='6' width='20' height='14' rx='2'/%3E%3Cpath d='M2 12h20M7 6V4a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2'/%3E%3Ccircle cx='9' cy='14' r='1'/%3E%3Cpath d='M2 20l4-4 4 4 4-6 6 6'/%3E%3C/svg%3E"); }
        .icon-hiking { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='10' cy='4' r='2'/%3E%3Cpath d='M7 22V12l-2 3'/%3E%3Cpath d='M7 8v4l6 2 1 6'/%3E%3Cpath d='M14 22v-8'/%3E%3Cpath d='M19 12l-3-6'/%3E%3Cpath d='M19 22V9'/%3E%3C/svg%3E"); }
        .icon-cycling { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='5.5' cy='17.5' r='3.5'/%3E%3Ccircle cx='18.5' cy='17.5' r='3.5'/%3E%3Cpath d='M12 5l3 7m-3-7l-3 7m3-7v0'/%3E%3Cpath d='M9 12L5.5 17.5M15 12l3.5 5.5'/%3E%3Ccircle cx='13' cy='4' r='1'/%3E%3C/svg%3E"); }
        .icon-activity { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='5.5' cy='17.5' r='3.5'/%3E%3Ccircle cx='18.5' cy='17.5' r='3.5'/%3E%3Cpath d='M12 5l3 7m-3-7l-3 7m3-7v0'/%3E%3Cpath d='M9 12L5.5 17.5M15 12l3.5 5.5'/%3E%3Ccircle cx='13' cy='4' r='1'/%3E%3C/svg%3E"); }
        .icon-kayaking { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 18h18'/%3E%3Cpath d='M2 12l1.5 6h17l1.5-6-10-6-10 6z'/%3E%3Ccircle cx='12' cy='7' r='1.5'/%3E%3C/svg%3E"); }
        .icon-spa { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 2C6.5 8 3 12 3 17a9 9 0 0 0 18 0c0-5-3.5-9-9-15z'/%3E%3Cpath d='M12 2v20'/%3E%3C/svg%3E"); }
        .icon-wellness { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z'/%3E%3C/svg%3E"); }
        .icon-shopping { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z'/%3E%3Cline x1='3' y1='6' x2='21' y2='6'/%3E%3Cpath d='M16 10a4 4 0 0 1-8 0'/%3E%3C/svg%3E"); }
        .icon-market { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpolyline points='9 22 9 12 15 12 15 22'/%3E%3C/svg%3E"); }
        .icon-concert { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M9 18V5l12-2v13'/%3E%3Ccircle cx='6' cy='18' r='3'/%3E%3Ccircle cx='18' cy='16' r='3'/%3E%3C/svg%3E"); }
        .icon-theater { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M7 2v20M17 2v20M2 12h20M2 7h5M2 17h5M17 7h5M17 17h5'/%3E%3C/svg%3E"); }
        .icon-cinema { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='2' y='7' width='20' height='15' rx='2'/%3E%3Cpolyline points='7 2 12 7 17 2 22 7'/%3E%3C/svg%3E"); }
        .icon-festival { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M4 12l8-8 8 8M4 22l8-8 8 8M12 4v16'/%3E%3Ccircle cx='12' cy='2' r='1'/%3E%3C/svg%3E"); }
        .icon-hotel { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='3' y='4' width='18' height='18' rx='2'/%3E%3Cpath d='M7 4v18M17 4v18M3 10h4M17 10h4M3 14h4M17 14h4M3 18h4M17 18h4'/%3E%3C/svg%3E"); }
        .icon-lodging { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpath d='M9 22V12h6v10'/%3E%3C/svg%3E"); }
        .icon-transport { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='1' y='3' width='15' height='13' rx='2'/%3E%3Cpath d='M16 8h5l3 3v5h-2.5'/%3E%3Ccircle cx='5.5' cy='18.5' r='2.5'/%3E%3Ccircle cx='18.5' cy='18.5' r='2.5'/%3E%3C/svg%3E"); }
        .icon-train { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect x='4' y='4' width='16' height='16' rx='2'/%3E%3Cpath d='M4 11h16M9 15h6M9 19l-2 2M15 19l2 2M12 4v3'/%3E%3C/svg%3E"); }
        .icon-boat { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M2 20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v0M2 20l8-8v-6h4v6l8 8M12 2v4'/%3E%3C/svg%3E"); }
        .icon-scenic { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 18l5-5 4 4 5-7 4 5v3H3v-0z'/%3E%3Ccircle cx='18' cy='8' r='2'/%3E%3Cpath d='M21 18H3'/%3E%3C/svg%3E"); }
        .icon-viewpoint { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Ccircle cx='12' cy='12' r='4'/%3E%3Cline x1='21.17' y1='8' x2='12' y2='12'/%3E%3Cline x1='3.95' y1='6.06' x2='12' y2='12'/%3E%3Cline x1='10.88' y1='21.94' x2='12' y2='12'/%3E%3C/svg%3E"); }
        .icon-park { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 2L7 12h10L12 2z'/%3E%3Cpath d='M5 14L2 22h20l-3-8H5z'/%3E%3Cline x1='12' y1='22' x2='12' y2='12'/%3E%3C/svg%3E"); }
        .icon-garden { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 22v-8m0 0c-3-2-7-2-7-8 0 0 3 0 7 4m0 4c3-2 7-2 7-8 0 0-3 0-7 4'/%3E%3Ccircle cx='12' cy='2' r='1'/%3E%3C/svg%3E"); }
        .icon-beach { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M12 3L7 12h10L12 3z'/%3E%3Cpath d='M7 12L2 22h20l-5-10'/%3E%3Cline x1='12' y1='3' x2='12' y2='12'/%3E%3C/svg%3E"); }
        .icon-history { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpolyline points='12 6 12 12 16 14'/%3E%3C/svg%3E"); }
        .icon-culture { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M2 3h20v18H2z'/%3E%3Cpath d='M2 9h20M2 15h20M9 3v18M15 3v18'/%3E%3C/svg%3E"); }
        .icon-architecture { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M3 21h18M6 21V7l6-4 6 4v14'/%3E%3Cline x1='9' y1='9' x2='9' y2='21'/%3E%3Cline x1='15' y1='9' x2='15' y2='21'/%3E%3C/svg%3E"); }
        .icon-local { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z'/%3E%3Ccircle cx='12' cy='10' r='3'/%3E%3C/svg%3E"); }
        .icon-tour { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20'/%3E%3Cpath d='M2 12h20'/%3E%3C/svg%3E"); }
        .icon-workshop { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z'/%3E%3C/svg%3E"); }
        .icon-class { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M4 19.5A2.5 2.5 0 0 1 6.5 17H20'/%3E%3Cpath d='M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z'/%3E%3C/svg%3E"); }
        .icon-cidery { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2C8.134 2 5 5.134 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.866-3.134-7-7-7z'/%3E%3Cpath d='M12 9v6'/%3E%3Ccircle cx='12' cy='9' r='1.5'/%3E%3C/svg%3E"); }
        .icon-indoor { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpath d='M9 22V12h6v10'/%3E%3Ccircle cx='9' cy='9' r='1'/%3E%3Ccircle cx='15' cy='9' r='1'/%3E%3C/svg%3E"); }
        .icon-attraction { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolygon points='12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2'/%3E%3C/svg%3E"); }
        .icon-farm { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2L3 7l9 5 9-5-9-5z'/%3E%3Cpath d='M3 17l9 5 9-5'/%3E%3Cpath d='M3 12l9 5 9-5'/%3E%3Ccircle cx='12' cy='7' r='1.5'/%3E%3Cpath d='M6 20h12'/%3E%3C/svg%3E"); }
        .icon-default { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cline x1='12' y1='8' x2='12' y2='12'/%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'/%3E%3C/svg%3E"); }

        /* Badge Styles */
        .icon-default { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cline x1='12' y1='8' x2='12' y2='12'/%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'/%3E%3C/svg%3E"); }
        
        /* ========================================
           ICON COLOR SYSTEM
           Icons adapt automatically to theme
        ======================================== */
        
        /* Light Mode - Make badge type icons soft grey */
        .badge-type::before {
            /* Convert black SVG icons to soft grey */
            filter: brightness(0) saturate(0%) invert(45%);
        }
        
        /* Light Mode - Filter buttons default to soft grey icons (but not category buttons) */
        .type-filter-btn:not(.category-filter-btn)::before {
            filter: brightness(0) saturate(0%) invert(45%);
        }
        /* Category buttons don't use filters - they use colored backgrounds */
        .category-filter-btn::before {
            filter: none !important;
        }
        
        /* Type-specific icon colors - Icons only */
        /* Hiking - Purple */
        .badge-type.icon-hiking::before,
        .type-filter-btn[data-type="Hiking"]::before {
            filter: brightness(0) saturate(100%) invert(25%) sepia(95%) saturate(2000%) hue-rotate(260deg) brightness(70%) contrast(130%);
        }
        .type-filter-btn[data-type="Hiking"]:hover::before,
        .type-filter-btn[data-type="Hiking"].active::before {
            background-color: #9333ea !important; /* Purple */
        }
        .type-filter-btn[data-type="Hiking"]:hover::after,
        .type-filter-btn[data-type="Hiking"].active::after {
            background-image: var(--icon-hiking) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Winery/Wine - Red/Burgundy */
        .badge-type.icon-wine::before,
        .type-filter-btn[data-type="Wine"]::before,
        .type-filter-btn[data-type="Winery"]::before {
            filter: brightness(0) saturate(100%) invert(15%) sepia(95%) saturate(5000%) hue-rotate(340deg) brightness(65%) contrast(130%);
        }
        .type-filter-btn[data-type="Wine"]:hover::before,
        .type-filter-btn[data-type="Wine"].active::before,
        .type-filter-btn[data-type="Winery"]:hover::before,
        .type-filter-btn[data-type="Winery"].active::before {
            background-color: #dc2626 !important; /* Red */
        }
        .type-filter-btn[data-type="Wine"]:hover::after,
        .type-filter-btn[data-type="Wine"].active::after,
        .type-filter-btn[data-type="Winery"]:hover::after,
        .type-filter-btn[data-type="Winery"].active::after {
            background-image: var(--icon-wine) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Brewery/Beer - Amber/Brown */
        .badge-type.icon-beer::before,
        .type-filter-btn[data-type="Beer"]::before,
        .type-filter-btn[data-type="Brewery"]::before {
            filter: brightness(0) saturate(100%) invert(45%) sepia(95%) saturate(800%) hue-rotate(20deg) brightness(85%) contrast(120%);
        }
        .type-filter-btn[data-type="Beer"]:hover::before,
        .type-filter-btn[data-type="Beer"].active::before,
        .type-filter-btn[data-type="Brewery"]:hover::before,
        .type-filter-btn[data-type="Brewery"].active::before {
            background-color: #d97706 !important; /* Amber/Brown */
        }
        .type-filter-btn[data-type="Beer"]:hover::after,
        .type-filter-btn[data-type="Beer"].active::after,
        .type-filter-btn[data-type="Brewery"]:hover::after,
        .type-filter-btn[data-type="Brewery"].active::after {
            background-image: var(--icon-beer) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Restaurant - Orange/Red */
        .badge-type.icon-restaurant::before,
        .type-filter-btn[data-type="Restaurant"]::before {
            filter: brightness(0) saturate(100%) invert(40%) sepia(95%) saturate(2000%) hue-rotate(350deg) brightness(80%) contrast(120%);
        }
        .type-filter-btn[data-type="Restaurant"]:hover::before,
        .type-filter-btn[data-type="Restaurant"].active::before {
            background-color: #ea580c !important; /* Orange/Red */
        }
        .type-filter-btn[data-type="Restaurant"]:hover::after,
        .type-filter-btn[data-type="Restaurant"].active::after {
            background-image: var(--icon-restaurant) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Lodging - Blue */
        .badge-type.icon-lodging::before,
        .badge-type.icon-hotel::before,
        .type-filter-btn[data-type="Lodging"]::before,
        .type-filter-btn[data-type="Hotel"]::before {
            filter: brightness(0) saturate(100%) invert(30%) sepia(95%) saturate(2000%) hue-rotate(200deg) brightness(85%) contrast(120%);
        }
        .type-filter-btn[data-type="Lodging"]:hover::before,
        .type-filter-btn[data-type="Lodging"].active::before {
            background-color: #2563eb !important; /* Blue */
        }
        .type-filter-btn[data-type="Lodging"]:hover::after,
        .type-filter-btn[data-type="Lodging"].active::after {
            background-image: var(--icon-lodging) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        .type-filter-btn[data-type="Hotel"]:hover::before,
        .type-filter-btn[data-type="Hotel"].active::before {
            background-color: #2563eb !important; /* Blue */
        }
        .type-filter-btn[data-type="Hotel"]:hover::after,
        .type-filter-btn[data-type="Hotel"].active::after {
            background-image: var(--icon-hotel) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Outdoor/Activity - Soft grey (default) */
        .badge-type.icon-activity::before,
        .badge-type.icon-outdoor::before,
        .type-filter-btn[data-type="Outdoor"]::before,
        .type-filter-btn[data-type="Activity"]::before,
        .type-filter-btn[data-type="Activities"]::before {
            filter: brightness(0) saturate(0%) invert(45%);
        }
        .type-filter-btn[data-type="Outdoor"]:hover::before,
        .type-filter-btn[data-type="Outdoor"].active::before,
        .type-filter-btn[data-type="Activity"]:hover::before,
        .type-filter-btn[data-type="Activity"].active::before,
        .type-filter-btn[data-type="Activities"]:hover::before,
        .type-filter-btn[data-type="Activities"].active::before {
            background-color: #F1F6F7 !important; /* Very soft grey-blue */
        }
        .type-filter-btn[data-type="Outdoor"]:hover::after,
        .type-filter-btn[data-type="Outdoor"].active::after,
        .type-filter-btn[data-type="Activity"]:hover::after,
        .type-filter-btn[data-type="Activity"].active::after,
        .type-filter-btn[data-type="Activities"]:hover::after,
        .type-filter-btn[data-type="Activities"].active::after {
            background-image: var(--icon-activity) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Coffee - Brown */
        .badge-type.icon-coffee::before,
        .type-filter-btn[data-type="Coffee"]::before {
            filter: brightness(0) saturate(100%) invert(35%) sepia(95%) saturate(500%) hue-rotate(15deg) brightness(75%) contrast(120%);
        }
        .type-filter-btn[data-type="Coffee"]:hover::before,
        .type-filter-btn[data-type="Coffee"].active::before {
            background-color: #92400e !important; /* Brown */
        }
        .type-filter-btn[data-type="Coffee"]:hover::after,
        .type-filter-btn[data-type="Coffee"].active::after {
            background-image: var(--icon-coffee) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Cidery - Amber */
        .badge-type.icon-cidery::before,
        .type-filter-btn[data-type="Cidery"]::before {
            filter: brightness(0) saturate(100%) invert(50%) sepia(95%) saturate(800%) hue-rotate(25deg) brightness(85%) contrast(120%);
        }
        .type-filter-btn[data-type="Cidery"]:hover::before,
        .type-filter-btn[data-type="Cidery"].active::before {
            background-color: #f59e0b !important; /* Amber */
        }
        .type-filter-btn[data-type="Cidery"]:hover::after,
        .type-filter-btn[data-type="Cidery"].active::after {
            background-image: var(--icon-cidery) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Indoor Activity - Gray/Blue */
        .badge-type.icon-indoor::before,
        .type-filter-btn[data-type="Indoor Activity"]::before {
            filter: brightness(0) saturate(100%) invert(35%) sepia(10%) saturate(500%) hue-rotate(200deg) brightness(75%) contrast(110%);
        }
        .type-filter-btn[data-type="Indoor Activity"]:hover::before,
        .type-filter-btn[data-type="Indoor Activity"].active::before {
            background-color: #64748b !important; /* Gray/Blue */
        }
        .type-filter-btn[data-type="Indoor Activity"]:hover::after,
        .type-filter-btn[data-type="Indoor Activity"].active::after {
            background-image: var(--icon-indoor) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Attraction - Orange/Yellow */
        .badge-type.icon-attraction::before,
        .type-filter-btn[data-type="Attraction"]::before {
            filter: brightness(0) saturate(100%) invert(55%) sepia(95%) saturate(2000%) hue-rotate(10deg) brightness(85%) contrast(120%);
        }
        .type-filter-btn[data-type="Attraction"]:hover::before,
        .type-filter-btn[data-type="Attraction"].active::before {
            background-color: #f97316 !important; /* Orange/Yellow */
        }
        .type-filter-btn[data-type="Attraction"]:hover::after,
        .type-filter-btn[data-type="Attraction"].active::after {
            background-image: var(--icon-attraction) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Farm & Orchard - Green/Brown */
        .badge-type.icon-farm::before,
        .type-filter-btn[data-type="Farm & Orchard"]::before {
            filter: brightness(0) saturate(100%) invert(45%) sepia(50%) saturate(600%) hue-rotate(60deg) brightness(75%) contrast(110%);
        }
        .type-filter-btn[data-type="Farm & Orchard"]:hover::before,
        .type-filter-btn[data-type="Farm & Orchard"].active::before {
            background-color: #65a30d !important; /* Green/Brown */
        }
        .type-filter-btn[data-type="Farm & Orchard"]:hover::after,
        .type-filter-btn[data-type="Farm & Orchard"].active::after {
            background-image: var(--icon-farm) !important;
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
        }
        
        /* Light Mode - Hover state for badges keeps icons dark */
        .badge-type:hover::before {
            filter: brightness(0) saturate(100%); /* Black icons on hover */
        }
        
        /* Dark Mode - Make all SVG icons light gray */
        :root.dark-mode .badge-type::before,
        :root.dark-mode .type-filter-btn::before {
            filter: brightness(0) invert(0.9); /* Light gray icons in dark mode */
        }
        
        /* Dark Mode - Hover states turn white, but colored backgrounds still apply */
        :root.dark-mode .badge-type:hover::before {
            filter: brightness(0) invert(1); /* White on hover */
        }
        
        /* Card info icons */
        :root.dark-mode .card-info-icon {
            filter: brightness(0) invert(0.9);
        }
        
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .btn-success { background: #E3795C; color: white; }
        .btn-success:hover { background: #D65052; transform: translateY(-2px); }
        .btn-primary { background: var(--theme-primary); color: white; }
        .btn-primary:hover { background: var(--theme-primary-hover); }
        .btn-secondary { background: #6b7280; color: white; }
        .btn-secondary:hover { background: #4b5563; }
        .btn-clear { background: var(--clear-color); color: white; }
        .btn-clear:hover { background: var(--clear-hover); transform: translateY(-2px); }
        
        .badge { padding: 4px 10px; border-radius: 20px; font-size: 12px; font-weight: 600; }
        .badge-type { background: #ffffff !important; color: #212529 !important; box-shadow: none !important; }
        .badge-area { background: #ffffff !important; color: #212529 !important; box-shadow: none !important; }
        .badge-featured { background: var(--badge-featured-bg); color: var(--badge-featured-color); }
        .card-featured-tag {
            position: absolute;
            top: 16px;
            left: 16px;
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 700;
            line-height: 1;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            background: var(--badge-featured-bg);
            color: var(--badge-featured-color);
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.16);
            z-index: 3;
        }
        :root.dark-mode .card-featured-tag {
            background: var(--badge-featured-bg);
            color: var(--badge-featured-color);
            border: none;
        }
        
        .preview-container { 
            width: 100%; 
            max-width: 1500px; 
            margin: 0 auto; 
            padding: 0; 
            padding-top: 0;
            transition: background-color 0.3s, color 0.3s;
            scroll-margin-top: 0;
            scroll-padding-top: 0;
        }
        
        .preview-header { text-align: left; margin-bottom: 40px; padding: 30px 30px 0 0; transition: color 0.3s; }
        .preview-header h1 { font-size: 32px; color: var(--text-primary); margin-bottom: 10px; transition: color 0.3s; }
        .preview-header p { font-size: 18px; color: var(--text-secondary); transition: color 0.3s; }
        
        /* Dark Mode Toggle Switch */
        .theme-toggle-container {
            padding: 15px 20px;
            border-top: 1px solid var(--border-color);
            background: var(--card-bg);
            flex-shrink: 0;
            margin-top: auto;
        }
        .theme-toggle-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        .theme-toggle-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .theme-toggle-label svg {
            width: 18px;
            height: 18px;
        }
        .theme-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 26px;
            flex-shrink: 0;
        }
        .theme-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .theme-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e5e7eb;
            transition: .3s;
            border-radius: 30px;
        }
        .theme-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input:checked + .theme-slider {
            background-color: var(--theme-primary);
        }
        input:checked + .theme-slider:before {
            transform: translateX(22px);
        }
        .theme-slider:hover {
            background-color: #d1d5db;
        }
        input:checked + .theme-slider:hover {
            background-color: #3d5441;
        }
        
        /* Dark mode adjustments for toggle */
        :root.dark-mode body .theme-toggle-container {
            background: #242424;
            border-top-color: #404040;
        }
        :root.dark-mode body .theme-toggle-label {
            color: #ffffff;
        }
        :root.dark-mode body .theme-slider {
            background-color: #404040;
        }
        :root.dark-mode body .theme-slider:hover {
            background-color: #4a4a4a;
        }
        
        /* Dark Mode Styles */
        :root.dark-mode body .preview-container { background: #1a1a1a; }
        :root.dark-mode body .preview-header h1 { color: #ffffff; }
        :root.dark-mode body .preview-header p { color: #9ca3af; }
        
        :root.dark-mode body .preview-sidebar { border-right: 1px solid #404040; }
        :root.dark-mode body .preview-filters { background: #2d2d2d; border-right: 1px solid #404040; }
        :root.dark-mode body .preview-filters h3 { background: #242424; color: #ffffff; border-bottom: 1px solid #404040; }
        
        :root.dark-mode body .filter-section.search-section { background: #242424; border-bottom: 2px solid #404040; }
        
        :root.dark-mode body .type-filter-btn {
            background: #242424;
            border-color: #404040;
            color: #9ca3af;
        }
        :root.dark-mode body .type-filter-btn svg {
            stroke: #9ca3af;
        }
        :root.dark-mode body .type-filter-btn:hover {
            background: #2d2d2d;
            border-color: var(--theme-primary);
            color: #ffffff;
        }
        :root.dark-mode body .type-filter-btn:hover svg {
            stroke: var(--theme-primary);
        }
        :root.dark-mode body .type-filter-btn.active {
            background: var(--theme-primary);
            border-color: var(--theme-primary);
            color: white;
        }
        :root.dark-mode body .type-filter-btn.active svg {
            stroke: white;
        }
        
        :root.dark-mode body .preview-filter-group label { color: #9ca3af; }
        :root.dark-mode body .preview-filter-group select {
            background-color: #242424;
            border-color: #404040;
            color: #ffffff;
        }
        :root.dark-mode body .preview-filter-group select:hover,
        :root.dark-mode body .preview-filter-group select:focus {
            background-color: #2d2d2d;
            border-color: var(--theme-primary);
        }
        
        :root.dark-mode body .btn-secondary {
            background: #404040;
            color: #ffffff;
            border-color: #404040;
        }
        :root.dark-mode body .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        :root.dark-mode body .preview-results { color: #9ca3af; }
        
        :root.dark-mode body .flip-card-front {
            background: #242424;
            border: 1px solid #404040;
        }
        :root.dark-mode body .flip-card:hover .flip-card-front {
            border-color: var(--theme-primary);
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
        }
        :root.dark-mode body .flip-card-front h3 { color: #ffffff !important; }
        :root.dark-mode body .flip-card-front p { color: #9ca3af !important; }
        
        :root.dark-mode body .flip-card-back {
            background: #2d2d2d;
            border: 1px solid #404040;
        }
        :root.dark-mode body .flip-card:hover .flip-card-back {
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
        }
        :root.dark-mode body .flip-card-back h3 { color: #ffffff !important; }
        :root.dark-mode body .flip-card-back p,
        :root.dark-mode body .flip-card-back span { color: #9ca3af !important; }
        :root.dark-mode body .flip-card-back strong { color: #ffffff !important; }
        
        :root.dark-mode body .filter-content::-webkit-scrollbar-thumb { background: #4a4a4a; }
        :root.dark-mode body .filter-content::-webkit-scrollbar-thumb:hover { background: #4b5563; }
        
        
        /* Apply icons from centralized library */
        .badge-type.icon-wine::before { background-image: var(--icon-wine); }
        .badge-type.icon-beer::before { background-image: var(--icon-beer); }
        .badge-type.icon-spirits::before { background-image: var(--icon-spirits); }
        .badge-type.icon-cocktail::before { background-image: var(--icon-cocktail); }
        .badge-type.icon-coffee::before { background-image: var(--icon-coffee); }
        .badge-type.icon-tea::before { background-image: var(--icon-tea); }
        .badge-type.icon-restaurant::before { background-image: var(--icon-restaurant); }
        .badge-type.icon-bakery::before { background-image: var(--icon-bakery); }
        .badge-type.icon-cheese::before { background-image: var(--icon-cheese); }
        .badge-type.icon-chocolate::before { background-image: var(--icon-chocolate); }
        .badge-type.icon-museum::before { background-image: var(--icon-museum); }
        .badge-type.icon-art::before { background-image: var(--icon-art); }
        .badge-type.icon-gallery::before { background-image: var(--icon-gallery); }
        .badge-type.icon-hiking::before { background-image: var(--icon-hiking); }
        .badge-type.icon-cycling::before { background-image: var(--icon-cycling); }
        .badge-type.icon-activity::before,
        .badge-type.icon-outdoor::before { background-image: var(--icon-activity); }
        .badge-type.icon-kayaking::before { background-image: var(--icon-kayaking); }
        .badge-type.icon-spa::before { background-image: var(--icon-spa); }
        .badge-type.icon-wellness::before { background-image: var(--icon-wellness); }
        .badge-type.icon-shopping::before { background-image: var(--icon-shopping); }
        .badge-type.icon-market::before { background-image: var(--icon-market); }
        .badge-type.icon-concert::before { background-image: var(--icon-concert); }
        .badge-type.icon-theater::before { background-image: var(--icon-theater); }
        .badge-type.icon-cinema::before { background-image: var(--icon-cinema); }
        .badge-type.icon-festival::before { background-image: var(--icon-festival); }
        .badge-type.icon-hotel::before { background-image: var(--icon-hotel); }
        .badge-type.icon-lodging::before { background-image: var(--icon-lodging); }
        .badge-type.icon-transport::before { background-image: var(--icon-transport); }
        .badge-type.icon-train::before { background-image: var(--icon-train); }
        .badge-type.icon-boat::before { background-image: var(--icon-boat); }
        .badge-type.icon-scenic::before { background-image: var(--icon-scenic); }
        .badge-type.icon-viewpoint::before { background-image: var(--icon-viewpoint); }
        .badge-type.icon-park::before { background-image: var(--icon-park); }
        .badge-type.icon-garden::before { background-image: var(--icon-garden); }
        .badge-type.icon-beach::before { background-image: var(--icon-beach); }
        .badge-type.icon-history::before { background-image: var(--icon-history); }
        .badge-type.icon-culture::before { background-image: var(--icon-culture); }
        .badge-type.icon-architecture::before { background-image: var(--icon-architecture); }
        .badge-type.icon-local::before { background-image: var(--icon-local); }
        .badge-type.icon-tour::before { background-image: var(--icon-tour); }
        .badge-type.icon-workshop::before { background-image: var(--icon-workshop); }
        .badge-type.icon-class::before { background-image: var(--icon-class); }
        .badge-type.icon-food::before { background-image: var(--icon-food); }
        .badge-type.icon-cidery::before { background-image: var(--icon-cidery); }
        .badge-type.icon-indoor::before { background-image: var(--icon-indoor); }
        .badge-type.icon-attraction::before { background-image: var(--icon-attraction); }
        .badge-type.icon-farm::before { background-image: var(--icon-farm); }
        .badge-type.icon-default::before { background-image: var(--icon-default); }
        
        /* Filter buttons use same icons */
        .type-filter-btn[data-type="Wine"]::before,
        .type-filter-btn[data-type="Winery"]::before { background-image: var(--icon-wine); }
        .type-filter-btn[data-type="Beer"]::before,
        .type-filter-btn[data-type="Brewery"]::before { background-image: var(--icon-beer); }
        .type-filter-btn[data-type="Spirits"]::before,
        .type-filter-btn[data-type="Distillery"]::before { background-image: var(--icon-spirits); }
        .type-filter-btn[data-type="Cocktails"]::before { background-image: var(--icon-cocktail); }
        .type-filter-btn[data-type="Coffee"]::before { background-image: var(--icon-coffee); }
        .type-filter-btn[data-type="Restaurant"]::before { background-image: var(--icon-restaurant); }
        .type-filter-btn[data-type="Hiking"]::before { background-image: var(--icon-hiking); }
        .type-filter-btn[data-type="Lodging"]::before { background-image: var(--icon-lodging); }
        .type-filter-btn[data-type="Outdoor"]::before,
        .type-filter-btn[data-type="Activity"]::before,
        .type-filter-btn[data-type="Activities"]::before { background-image: var(--icon-activity); }
        .type-filter-btn[data-type="Cidery"]::before { background-image: var(--icon-cidery); }
        .type-filter-btn[data-type="Indoor Activity"]::before { background-image: var(--icon-indoor); }
        .type-filter-btn[data-type="Attraction"]::before { background-image: var(--icon-attraction); }
        .type-filter-btn[data-type="Farm & Orchard"]::before { background-image: var(--icon-farm); }
        .type-filter-btn[data-type="Shopping"]::before { background-image: var(--icon-shopping); }
        .type-filter-btn[data-type="Hotel"]::before { background-image: var(--icon-hotel); }
        /* Category buttons (including All Types) don't use icon backgrounds - they use emojis */
        .type-filter-btn[data-type=""]:not(.category-filter-btn)::before { background-image: var(--icon-default); }
        .category-filter-btn[data-type=""]::before { background-image: none !important; }
        
        /* Dark mode - icons remain the same (currentColor adapts) */
        
        /* Hover states - icons turn white */
        .badge-type {
            background: transparent !important; /* Removed light green background */
            color: #212529 !important;
            padding: 0;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, letter-spacing 0.2s, box-shadow 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: none !important;
            line-height: 1;
        }
        .badge-type::before {
            content: '';
            width: 14px;
            height: 14px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: inline-block;
            flex-shrink: 0;
        }
        .badge-type:hover {
            background-color: transparent !important; /* Removed light green background on hover */
            color: #212529 !important;
            letter-spacing: 0.8px;
            box-shadow: none !important;
        }
        .badge-type:hover::before {
            filter: brightness(0) invert(0);
        }
        .badge-area {
            background: #ffffff !important;
            color: #212529 !important;
            padding: 0 0 0 20px !important;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            position: relative;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23D65052' stroke-width='1.5'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E") !important;
            background-repeat: no-repeat !important;
            background-position: 3px center !important;
            background-size: 12px 12px !important;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, letter-spacing 0.2s, box-shadow 0.2s;
            display: inline-flex;
            align-items: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: none !important;
            line-height: 1;
        }
        .badge-area:hover {
            background-color: #ffffff !important;
            color: #212529 !important;
            letter-spacing: 0.8px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23D65052' stroke-width='1.5'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E") !important;
            background-repeat: no-repeat !important;
            background-position: 3px center !important;
            background-size: 12px 12px !important;
            box-shadow: none !important;
        }
        :root.dark-mode body .badge-type {
            background-color: var(--theme-primary-light);
            color: #82b894;
        }
        :root.dark-mode body .badge-type:hover {
            background-color: var(--theme-primary);
            color: white;
        }
        :root.dark-mode body .badge-area {
            background-color: rgba(214, 80, 82, 0.2);
            color: #f09090;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23f09090' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E");
        }
        :root.dark-mode body .badge-area:hover {
            background-color: #D65052;
            color: white;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23ffffff' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E");
        }
        .badge-featured {
            background: var(--badge-featured-bg);
            color: var(--badge-featured-color);
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            line-height: 1;
        }
        .badge-featured::before {
            content: '';
            display: inline-block;
            width: 14px;
            height: 14px;
            background-image: var(--icon-featured);
            background-repeat: no-repeat;
            background-size: 14px 14px;
        }
        .badge-featured:hover {
            background-color: #a6ad2d;
            color: var(--badge-featured-color);
            transform: scale(1.05);
        }
        :root.dark-mode body .badge-featured {
            background-color: var(--badge-featured-bg);
            color: var(--badge-featured-color);
        }
        :root.dark-mode body .badge-featured:hover {
            background-color: #a6ad2d;
            color: var(--badge-featured-color);
        }
        
        /* Card Info Icons */
        .card-info-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }

        /* Hide contributor and created/updated meta rows on card backs (icon colors are unique to those rows) */
        .flip-card-back .card-info-item:has(svg[stroke="#4E6B52"]),
        .flip-card-back .card-info-item:has(svg[stroke="#6366f1"]) {
            display: none !important;
        }

        a.card-info-item:hover {
            opacity: 0.8;
        }
        a.card-info-item:hover .card-info-icon {
            background: var(--theme-primary);
        }
        a.card-info-item:hover .card-info-icon svg {
            stroke: white;
        }
        .card-info-icon {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
            background: transparent;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .card-info-icon svg {
            width: 18px;
            height: 18px;
            stroke: #D65052;
            transition: all 0.3s;
        }
        .card-info-text {
            flex: 1;
            font-size: 13px;
            line-height: 1.4;
            padding-top: 6px;
        }
        
        :root.dark-mode body .card-info-icon {
            background: transparent;
        }
        :root.dark-mode body .card-info-icon svg {
            stroke: #D65052;
        }
        :root.dark-mode body a.card-info-item:hover .card-info-icon {
            background: var(--theme-primary);
        }
        :root.dark-mode body a.card-info-item:hover .card-info-icon svg {
            stroke: white;
        }
        
        .preview-content-wrapper { 
            display: flex; 
            gap: 0; 
            align-items: flex-start; 
            max-width: 100vw;
            overflow-x: clip;
        }
        
        /* Smooth fade-in for grid container on load */
        #previewGrid {
            opacity: 0;
            transition: opacity 0.4s ease-out;
        }
        
        #previewGrid.grid-loaded {
            opacity: 1;
        }
        
        .preview-sidebar { 
            width: 280px; 
            flex-shrink: 0; 
            position: sticky !important; 
            top: 0 !important; 
            max-height: 100vh !important; 
            left: 0; 
            align-self: flex-start; 
            transition: all 0.3s; 
            z-index: 1000 !important;
            height: 100vh;
            overflow-y: auto;
        }
        .preview-sidebar.collapsed { width: 0; min-width: 0; overflow: hidden; }
        
        .sidebar-header {
            padding: 15px 20px 20px 20px;
            display: flex;
            justify-content: flex-start;
            border-bottom: none;
            background: var(--card-bg);
        }
        .sidebar-toggle-btn {
            background: white;
            color: var(--text-primary);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            transition: all 0.3s;
            padding: 0;
        }
        .sidebar-toggle-btn:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
            transform: scale(1.05);
        }
        .sidebar-toggle-btn svg {
            display: block;
            width: 24px;
            height: 24px;
        }
        
        .show-sidebar-btn {
            position: fixed !important;
            left: max(20px, calc((100vw - 1500px) / 2 + 20px)) !important;
            top: 15px !important;
            background: white !important;
            color: var(--text-primary) !important;
            border: none !important;
            width: 50px !important;
            height: 50px !important;
            border-radius: 50% !important;
            display: none;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15) !important;
            transition: all 0.3s;
            padding: 0 !important;
            margin: 0 !important;
            z-index: 2000 !important; /* Very high z-index to stay on top */
            pointer-events: auto !important;
            transform: none !important;
        }
        .show-sidebar-btn:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
            transform: scale(1.05);
        }
        .show-sidebar-btn svg {
            display: block;
        }
        /* Show sidebar button when sidebar is collapsed - make sure it's always visible */
        .preview-sidebar.collapsed ~ .preview-main .show-sidebar-btn,
        .preview-sidebar.collapsed + * .show-sidebar-btn,
        body:has(.preview-sidebar.collapsed) .show-sidebar-btn {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: fixed !important;
            left: max(20px, calc((100vw - 1500px) / 2 + 20px)) !important;
            top: 15px !important;
            z-index: 2000 !important;
        }
        
        /* Ensure show-sidebar-btn is never affected by grid or expanding cards */
        .show-sidebar-btn {
            z-index: 2000 !important; /* Very high z-index to stay on top of expanded cards (1001) */
            position: fixed !important; /* Always fixed to viewport, not affected by parent layouts */
            left: max(20px, calc((100vw - 1500px) / 2 + 20px)) !important;
            top: 15px !important;
            /* Prevent any parent transforms or layouts from affecting this */
            transform: none !important;
            margin: 0 !important;
            /* Ensure it's not clipped by parent containers */
            clip-path: none !important;
            clip: auto !important;
        }
        
        /* Prevent grid or expanding cards from affecting button */
        .preview-grid,
        .flip-card.expanded,
        .preview-main {
            position: relative; /* Keep containers relative, but button stays fixed */
        }
        
        /* Ensure preview-main doesn't clip the button */
        .preview-main {
            overflow: visible !important; /* Allow button to be visible outside container */
        }
        
        /* Override any transforms or positioning that might affect the button */
        .preview-main:has(.show-sidebar-btn) .show-sidebar-btn,
        .preview-main .show-sidebar-btn {
            position: fixed !important;
            left: max(20px, calc((100vw - 1500px) / 2 + 20px)) !important;
            top: 15px !important;
            transform: none !important;
            margin: 0 !important;
            /* Ensure visibility even when cards expand */
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* Make sure expanded cards don't cover the button */
        .flip-card.expanded {
            z-index: 1001 !important; /* Lower than button's 2000 */
        }
        
        .preview-filters { background: var(--bg-secondary); padding: 0; border-radius: 0; box-shadow: none; max-height: 100vh; display: flex; flex-direction: column; }
        .preview-filters h3 { font-size: 18px; color: var(--text-primary); margin-bottom: 0; padding: 20px 20px 15px; border-bottom: 1px solid var(--border-color); background: var(--card-bg); flex-shrink: 0; }
        
        .filter-content { flex: 1; overflow-y: auto; padding: 0; min-height: 0; }
        .filter-content::-webkit-scrollbar { width: 6px; }
        .filter-content::-webkit-scrollbar-track { background: transparent; }
        .filter-content::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        .filter-content::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        
        :root.dark-mode .filter-content::-webkit-scrollbar-thumb { background: #4a4a4a; }
        :root.dark-mode .filter-content::-webkit-scrollbar-thumb:hover { background: #5a5a5a; }
        
        .filter-section { padding: 15px 20px 15px 10px; }
        .filter-section.search-section { 
            background: var(--card-bg); 
            border-bottom: 2px solid var(--border-color); 
            padding: 20px 20px 20px 10px;
        }
        
        
        .type-quick-filters { display: flex; flex-direction: column; gap: 2px; margin-bottom: 0; margin-left: 0; }
        .type-filter-btn { 
            width: 100%;
            padding: 14px 18px 14px 6px; /* Reduced left padding from 10px to 6px */
            margin-top: 4px;
            margin-bottom: 4px;
            border: none; 
            border-radius: 0; 
            background: var(--card-bg); 
            color: var(--text-secondary); 
            font-size: 15px; 
            font-weight: 500;
            cursor: pointer; 
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            text-align: left;
            box-shadow: none;
        }
        .type-filter-btn:first-child {
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
        }
        .type-filter-btn:last-child {
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }
        .type-filters-expanded {
            display: none;
        }
        .type-filters-expanded .type-filter-btn {
            border-radius: 16px;
        }
        .type-filter-see-more-btn {
            width: 100%;
            padding: 14px 18px;
            border: none;
            border-radius: 0;
            background: var(--card-bg);
            color: var(--text-secondary);
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
            box-shadow: none;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }
        .type-filter-see-more-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: scale(0.98);
            border-radius: 16px;
        }
        .type-filter-btn svg {
            display: none; /* Hide inline SVGs */
        }
        /* Show SVG icons for category buttons */
        .category-filter-btn .category-icon svg {
            display: block !important; /* Override display: none for category icons */
        }
        /* Remove circular icon backgrounds from sidebar buttons (but keep circular background for category buttons) */
        .type-filter-btn:not(.category-filter-btn)::before {
            display: none !important;
        }
        /* Remove circular icon overlays from sidebar buttons (hide for all, including category buttons) */
        .type-filter-btn::after {
            display: none !important;
        }
        /* Category buttons use ::before only for circular background, not icons */
        .category-filter-btn::before {
            background-image: none !important;
        }
        .type-filter-btn {
            position: relative;
        }
        .type-filter-btn:hover { 
            background: var(--card-bg); 
            color: var(--text-secondary);
        }
        .type-filter-btn:first-child:hover {
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
        }
        .type-filter-btn:last-child:hover {
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }
        .type-filters-expanded .type-filter-btn:last-child {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        .type-filter-btn.active { 
            background: var(--card-bg); 
            color: var(--text-secondary); 
        }
        .category-filter-btn {
            padding: 10px 14px; /* Reduced vertical padding from 12px to 10px for less space */
            position: relative;
            display: flex;
            align-items: center;
            transition: background-color 0.2s ease-in-out;
            border-radius: 16px !important; /* Rounded corners on all sides, override any inherited styles */
        }
        /* Ensure category buttons always have rounded corners, regardless of position */
        .category-filter-btn:first-child,
        .category-filter-btn:last-child {
            border-radius: 16px !important; /* Consistent rounded corners on all sides */
            border-top-left-radius: 16px !important;
            border-top-right-radius: 16px !important;
            border-bottom-left-radius: 16px !important;
            border-bottom-right-radius: 16px !important;
        }
        .category-filter-btn .category-icon {
            margin-right: 8px;
            position: absolute;
            left: 6px; /* Align with button padding-left (6px) */
            top: 50%;
            transform: translateY(-50%);
            z-index: 10; /* Higher z-index to ensure icon appears above background circle */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            width: 40px; /* Match circle width */
            height: 40px; /* Match circle height */
            line-height: 0;
        }
        .category-filter-btn .category-icon svg {
            width: 24px;
            height: 24px;
            stroke-width: 2 !important; /* Ensure stroke is visible */
            fill: none !important;
            position: relative;
            z-index: 11; /* Even higher z-index for the SVG itself */
            display: block;
            margin: auto; /* Center the SVG within the icon container */
            /* Don't override stroke color - use the color from the SVG attribute */
            color: unset !important;
        }
        /* Preserve stroke colors from SVG attributes - don't let CSS override */
        .category-filter-btn .category-icon svg path,
        .category-filter-btn .category-icon svg circle,
        .category-filter-btn .category-icon svg polyline,
        .category-filter-btn .category-icon svg line,
        .category-filter-btn .category-icon svg rect {
            /* Let the SVG stroke attribute take precedence */
            stroke: unset !important;
        }
        /* SVG colors are defined in the SVG itself, so they persist on hover/active */
        .category-filter-btn .category-name {
            flex: 1;
            font-weight: 500;
            margin-left: 50px; /* 6px (left) + 40px (circle width) + 4px (right margin) = 50px */
        }
        /* Circular background behind icon for category buttons on hover/active */
        .category-filter-btn::before {
            content: '';
            position: absolute;
            left: 6px; /* Align with button padding-left (6px) */
            top: 50%;
            transform: translateY(-50%);
            width: 40px; /* Sized for SVG icon */
            height: 40px; /* Sized for SVG icon */
            border-radius: 50%;
            background-color: transparent;
            background-image: none !important; /* Remove any icon backgrounds */
            filter: none !important; /* Remove any brightness/invert filters that might make it dark grey */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: none; /* No shadow by default */
            z-index: 1;
            display: block !important;
        }
        /* Pure white background with soft drop shadow for hover, active/selected, and click states */
        .category-filter-btn:hover::before,
        .category-filter-btn.active::before,
        .category-filter-btn.clicking::before,
        .category-filter-btn:active::before {
            background-color: #ffffff !important; /* Pure white background */
            background-image: none !important; /* Ensure no icon is shown */
            filter: none !important; /* Remove any brightness/invert filters */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important; /* Visible soft drop shadow */
        }
        /* Ensure active state always shows the circle with pure white */
        .category-filter-btn.active::before {
            background-color: #ffffff !important;
            filter: none !important; /* Remove any brightness/invert filters */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
        }
        /* Button background stays transparent on hover - only the circle changes */
        .category-filter-btn:hover,
        .category-filter-btn.active,
        .category-filter-btn.clicking,
        .category-filter-btn:active {
            background-color: transparent !important; /* No background change on button itself */
        }
        /* Dark mode support - ensure shadow is visible */
        :root.dark-mode .category-filter-btn:hover::before,
        :root.dark-mode .category-filter-btn.active::before,
        :root.dark-mode .category-filter-btn.clicking::before,
        :root.dark-mode .category-filter-btn:active::before {
            background-color: #ffffff !important; /* Pure white for dark mode */
            background-image: none !important; /* Ensure no icon is shown */
            filter: none !important; /* Remove any brightness/invert filters */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25) !important; /* More visible shadow for dark mode */
        }
        :root.dark-mode .category-filter-btn:hover,
        :root.dark-mode .category-filter-btn.active,
        :root.dark-mode .category-filter-btn.clicking,
        :root.dark-mode .category-filter-btn:active {
            background-color: transparent !important; /* No background change on button itself in dark mode */
        }
        /* Hide ::after pseudo-element for category buttons (used for icon overlays) */
        .category-filter-btn::after {
            display: none !important;
        }
        /* Icon container styling - circular with colored fill on hover/active (only for non-category buttons) */
        .type-filter-btn:not(.category-filter-btn):hover::before,
        .type-filter-btn:not(.category-filter-btn).active::before {
            background-color: #F1F6F7 !important; /* Default very soft grey-blue, will be overridden by type-specific colors */
            background-image: none !important; /* Hide the colored icon, show white version via ::after */
        }
        .type-filter-btn:not(.category-filter-btn):hover::after,
        .type-filter-btn:not(.category-filter-btn).active::after {
            opacity: 1 !important;
            background-image: inherit !important;
        }
        /* Click state - black background when physically clicking (using .clicking class from JS) - but NOT for category buttons */
        .type-filter-btn:not(.category-filter-btn).clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Hiking"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Hiking"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Hiking"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Wine"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Wine"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Wine"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Winery"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Winery"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Winery"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Beer"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Beer"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Beer"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Brewery"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Brewery"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Brewery"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Restaurant"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Restaurant"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Restaurant"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Lodging"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Lodging"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Lodging"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Hotel"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Hotel"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Hotel"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Outdoor"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Outdoor"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Outdoor"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Activity"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Activity"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Activity"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Activities"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Activities"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Activities"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Coffee"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Coffee"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Coffee"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Cidery"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Cidery"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Cidery"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Indoor Activity"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Indoor Activity"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Indoor Activity"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Attraction"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Attraction"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Attraction"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Farm & Orchard"].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Farm & Orchard"]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type="Farm & Orchard"]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type=""].clicking::before,
        .type-filter-btn:not(.category-filter-btn)[data-type=""]:active::before,
        .type-filter-btn:not(.category-filter-btn)[data-type=""]:hover:active::before,
        .type-filter-btn:not(.category-filter-btn):active::before,
        .type-filter-btn:not(.category-filter-btn):hover:active::before {
            background-color: #000000 !important;
            background-image: none !important;
            transition: none !important; /* Disable transition for immediate feedback */
        }
        /* Category buttons use pure white on click, not black */
        .category-filter-btn.clicking::before,
        .category-filter-btn:active::before,
        .category-filter-btn:hover:active::before {
            background-color: #ffffff !important;
            filter: none !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
        }
        .type-filter-btn.clicking::after,
        .type-filter-btn[data-type="Hiking"].clicking::after,
        .type-filter-btn[data-type="Hiking"]:active::after,
        .type-filter-btn[data-type="Hiking"]:hover:active::after,
        .type-filter-btn[data-type="Wine"].clicking::after,
        .type-filter-btn[data-type="Wine"]:active::after,
        .type-filter-btn[data-type="Wine"]:hover:active::after,
        .type-filter-btn[data-type="Winery"].clicking::after,
        .type-filter-btn[data-type="Winery"]:active::after,
        .type-filter-btn[data-type="Winery"]:hover:active::after,
        .type-filter-btn[data-type="Beer"].clicking::after,
        .type-filter-btn[data-type="Beer"]:active::after,
        .type-filter-btn[data-type="Beer"]:hover:active::after,
        .type-filter-btn[data-type="Brewery"].clicking::after,
        .type-filter-btn[data-type="Brewery"]:active::after,
        .type-filter-btn[data-type="Brewery"]:hover:active::after,
        .type-filter-btn[data-type="Restaurant"].clicking::after,
        .type-filter-btn[data-type="Restaurant"]:active::after,
        .type-filter-btn[data-type="Restaurant"]:hover:active::after,
        .type-filter-btn[data-type="Lodging"].clicking::after,
        .type-filter-btn[data-type="Lodging"]:active::after,
        .type-filter-btn[data-type="Lodging"]:hover:active::after,
        .type-filter-btn[data-type="Hotel"].clicking::after,
        .type-filter-btn[data-type="Hotel"]:active::after,
        .type-filter-btn[data-type="Hotel"]:hover:active::after,
        .type-filter-btn[data-type="Outdoor"].clicking::after,
        .type-filter-btn[data-type="Outdoor"]:active::after,
        .type-filter-btn[data-type="Outdoor"]:hover:active::after,
        .type-filter-btn[data-type="Activity"].clicking::after,
        .type-filter-btn[data-type="Activity"]:active::after,
        .type-filter-btn[data-type="Activity"]:hover:active::after,
        .type-filter-btn[data-type="Activities"].clicking::after,
        .type-filter-btn[data-type="Activities"]:active::after,
        .type-filter-btn[data-type="Activities"]:hover:active::after,
        .type-filter-btn[data-type="Coffee"].clicking::after,
        .type-filter-btn[data-type="Coffee"]:active::after,
        .type-filter-btn[data-type="Coffee"]:hover:active::after,
        .type-filter-btn[data-type="Cidery"].clicking::after,
        .type-filter-btn[data-type="Cidery"]:active::after,
        .type-filter-btn[data-type="Cidery"]:hover:active::after,
        .type-filter-btn[data-type="Indoor Activity"].clicking::after,
        .type-filter-btn[data-type="Indoor Activity"]:active::after,
        .type-filter-btn[data-type="Indoor Activity"]:hover:active::after,
        .type-filter-btn[data-type="Attraction"].clicking::after,
        .type-filter-btn[data-type="Attraction"]:active::after,
        .type-filter-btn[data-type="Attraction"]:hover:active::after,
        .type-filter-btn[data-type="Farm & Orchard"].clicking::after,
        .type-filter-btn[data-type="Farm & Orchard"]:active::after,
        .type-filter-btn[data-type="Farm & Orchard"]:hover:active::after,
        .type-filter-btn[data-type=""].clicking::after,
        .type-filter-btn[data-type=""]:active::after,
        .type-filter-btn[data-type=""]:hover:active::after,
        .type-filter-btn:active::after,
        .type-filter-btn:hover:active::after {
            opacity: 1 !important;
            filter: brightness(0) invert(1) !important;
            transition: none !important; /* Disable transition for immediate feedback */
        }
        /* Ensure icons show correctly when clicked */
        .type-filter-btn[data-type="Hiking"].clicking::after,
        .type-filter-btn[data-type="Hiking"]:active::after,
        .type-filter-btn[data-type="Hiking"]:hover:active::after {
            background-image: var(--icon-hiking) !important;
        }
        .type-filter-btn[data-type="Wine"].clicking::after,
        .type-filter-btn[data-type="Wine"]:active::after,
        .type-filter-btn[data-type="Wine"]:hover:active::after,
        .type-filter-btn[data-type="Winery"].clicking::after,
        .type-filter-btn[data-type="Winery"]:active::after,
        .type-filter-btn[data-type="Winery"]:hover:active::after {
            background-image: var(--icon-wine) !important;
        }
        .type-filter-btn[data-type="Beer"].clicking::after,
        .type-filter-btn[data-type="Beer"]:active::after,
        .type-filter-btn[data-type="Beer"]:hover:active::after,
        .type-filter-btn[data-type="Brewery"].clicking::after,
        .type-filter-btn[data-type="Brewery"]:active::after,
        .type-filter-btn[data-type="Brewery"]:hover:active::after {
            background-image: var(--icon-beer) !important;
        }
        .type-filter-btn[data-type="Restaurant"].clicking::after,
        .type-filter-btn[data-type="Restaurant"]:active::after,
        .type-filter-btn[data-type="Restaurant"]:hover:active::after {
            background-image: var(--icon-restaurant) !important;
        }
        .type-filter-btn[data-type="Lodging"].clicking::after,
        .type-filter-btn[data-type="Lodging"]:active::after,
        .type-filter-btn[data-type="Lodging"]:hover:active::after {
            background-image: var(--icon-lodging) !important;
        }
        .type-filter-btn[data-type="Hotel"].clicking::after,
        .type-filter-btn[data-type="Hotel"]:active::after,
        .type-filter-btn[data-type="Hotel"]:hover:active::after {
            background-image: var(--icon-hotel) !important;
        }
        .type-filter-btn[data-type="Outdoor"].clicking::after,
        .type-filter-btn[data-type="Outdoor"]:active::after,
        .type-filter-btn[data-type="Outdoor"]:hover:active::after,
        .type-filter-btn[data-type="Activity"].clicking::after,
        .type-filter-btn[data-type="Activity"]:active::after,
        .type-filter-btn[data-type="Activity"]:hover:active::after,
        .type-filter-btn[data-type="Activities"].clicking::after,
        .type-filter-btn[data-type="Activities"]:active::after,
        .type-filter-btn[data-type="Activities"]:hover:active::after {
            background-image: var(--icon-activity) !important;
        }
        .type-filter-btn[data-type="Coffee"].clicking::after,
        .type-filter-btn[data-type="Coffee"]:active::after,
        .type-filter-btn[data-type="Coffee"]:hover:active::after {
            background-image: var(--icon-coffee) !important;
        }
        .type-filter-btn[data-type="Cidery"].clicking::after,
        .type-filter-btn[data-type="Cidery"]:active::after,
        .type-filter-btn[data-type="Cidery"]:hover:active::after {
            background-image: var(--icon-cidery) !important;
        }
        .type-filter-btn[data-type="Indoor Activity"].clicking::after,
        .type-filter-btn[data-type="Indoor Activity"]:active::after,
        .type-filter-btn[data-type="Indoor Activity"]:hover:active::after {
            background-image: var(--icon-indoor) !important;
        }
        .type-filter-btn[data-type="Attraction"].clicking::after,
        .type-filter-btn[data-type="Attraction"]:active::after,
        .type-filter-btn[data-type="Attraction"]:hover:active::after {
            background-image: var(--icon-attraction) !important;
        }
        .type-filter-btn[data-type="Farm & Orchard"].clicking::after,
        .type-filter-btn[data-type="Farm & Orchard"]:active::after,
        .type-filter-btn[data-type="Farm & Orchard"]:hover:active::after {
            background-image: var(--icon-farm) !important;
        }
        /* Category buttons (including All Types) don't show icons - only emojis */
        .category-filter-btn::before,
        .category-filter-btn:hover::before,
        .category-filter-btn.active::before,
        .category-filter-btn.clicking::before,
        .category-filter-btn:active::before {
            background-image: none !important;
        }
        .category-filter-btn::after,
        .category-filter-btn:hover::after,
        .category-filter-btn.active::after,
        .category-filter-btn.clicking::after,
        .category-filter-btn:active::after {
            display: none !important;
        }
        /* Non-category buttons can show icons */
        .type-filter-btn[data-type=""]:not(.category-filter-btn).clicking::after,
        .type-filter-btn[data-type=""]:not(.category-filter-btn):active::after,
        .type-filter-btn[data-type=""]:not(.category-filter-btn):hover:active::after {
            background-image: var(--icon-default) !important;
        }
        
        /* Dark mode icon filters (only for non-category buttons) */
        :root.dark-mode body .type-filter-btn:not(.category-filter-btn)::before {
            filter: brightness(0) invert(1);
        }
        /* Category buttons don't have icons, so no filter needed - explicitly remove all filters */
        .category-filter-btn::before,
        .category-filter-btn:hover::before,
        .category-filter-btn.active::before,
        .category-filter-btn.clicking::before,
        .category-filter-btn:active::before,
        :root.dark-mode body .category-filter-btn::before,
        :root.dark-mode body .category-filter-btn:hover::before,
        :root.dark-mode body .category-filter-btn.active::before,
        :root.dark-mode body .category-filter-btn.clicking::before,
        :root.dark-mode body .category-filter-btn:active::before {
            filter: none !important;
        }
        /* In dark mode, still show colored backgrounds on hover/active (only for non-category buttons) */
        :root.dark-mode body .type-filter-btn:not(.category-filter-btn):hover::before,
        :root.dark-mode body .type-filter-btn:not(.category-filter-btn).active::before {
            filter: brightness(0) invert(1); /* White icon */
        }
        
        .preview-filter-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px; }
        .preview-filter-group label { font-size: 12px; font-weight: 600; color: var(--text-secondary); }
        .preview-filter-group select { width: 100%; padding: 13px 16px 13px 40px; border: none; border-radius: 16px; font-size: 15px; background: #ffffff; cursor: pointer; transition: all 0.2s; color: var(--text-primary); appearance: none; 
            /* Left: pin icon, Right: caret */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23D65052' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E"), 
                              url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E"); 
            background-repeat: no-repeat, no-repeat; 
            background-position: 14px center, right 16px center; 
            background-size: 16px 16px, 12px 12px; 
            padding-right: 36px; 
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06); }

        /* Ensure pin icon color stays consistent on hover/focus for Area dropdown */
        #previewTypeFilter,
        #previewTypeFilter:hover,
        #previewTypeFilter:focus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%236b7280' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z'/%3E%3C/svg%3E"),
                              url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat, no-repeat;
            background-position: 14px center, right 16px center;
            background-size: 16px 16px, 12px 12px;
            padding-left: 40px;
            padding-right: 36px;
        }

        #previewAreaFilter,
        #previewAreaFilter:hover,
        #previewAreaFilter:focus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23D65052' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E"),
                              url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat, no-repeat;
            background-position: 14px center, right 16px center;
            background-size: 16px 16px, 12px 12px;
            padding-left: 40px;
            padding-right: 36px;
        }

        /* Amenities dropdown - star icon on left (yellow/orange), caret on right */
        #previewAmenityFilter,
        #previewAmenityFilter:hover,
        #previewAmenityFilter:focus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23f59e0b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z'/%3E%3C/svg%3E"),
                              url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat, no-repeat;
            background-position: 14px center, right 16px center;
            background-size: 16px 16px, 12px 12px;
            padding-left: 40px;
            padding-right: 36px;
        }
        .preview-filter-group select:hover { border-radius: 16px; background: #ffffff; box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.04), 0 2px 12px rgba(0, 0, 0, 0.08); transform: scale(0.98); }
        .preview-filter-group select:focus { outline: none; border-radius: 16px; background: #ffffff; box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.04), 0 2px 12px rgba(0, 0, 0, 0.08); }
        
        .preview-filters .btn { width: 100%; padding: 13px 20px; white-space: nowrap; font-size: 15px; margin-top: 8px; border-radius: 16px; }
        
        .preview-main { 
            flex: 1; 
            min-width: 0; 
            max-width: 100%;
            padding: 0 30px 30px 15px;
        }
        .preview-results { margin-bottom: 20px; font-size: 14px; color: var(--text-secondary); font-weight: 500; }
        .map-collapsed + .preview-results {
            margin-top: 30px;
        }
        
        /* Top Search Bar */
        .top-search-container {
            position: sticky !important;
            top: 0 !important;
            z-index: 1000 !important;
            background: linear-gradient(
                to bottom,
                var(--bg-primary) 0%,
                var(--bg-primary) 30%,
                rgba(255, 255, 255, 0.5) 50%,
                transparent 70%
            );
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            /* Mask to fade out the blur at the bottom */
            mask-image: linear-gradient(
                to bottom,
                black 0%,
                black 42%,
                black 60%,
                rgba(0, 0, 0, 0.8) 70%,
                rgba(0, 0, 0, 0.5) 82%,
                rgba(0, 0, 0, 0.2) 92%,
                transparent 100%
            );
            -webkit-mask-image: linear-gradient(
                to bottom,
                black 0%,
                black 42%,
                black 60%,
                rgba(0, 0, 0, 0.8) 70%,
                rgba(0, 0, 0, 0.5) 82%,
                rgba(0, 0, 0, 0.2) 92%,
                transparent 100%
            );
            padding-top: 15px;
            padding-bottom: 32px;
            margin-bottom: -20px;
            /* Extend blur to edges */
            margin-left: -30px;
            margin-right: -30px;
            padding-left: 30px;
            padding-right: 30px;
            transition: padding-left 0.3s;
        }
        .preview-sidebar.collapsed ~ .preview-main .top-search-container {
            padding-left: 100px;
        }
        .search-input-wrapper {
            position: relative;
            width: 100%;
            z-index: 1;
        }
        .search-icon {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            color: var(--badge-featured-bg);
            pointer-events: none;
            z-index: 1;
        }
        .top-search-container input {
            width: 100%;
            padding: 14px 20px 14px 55px;
            border: 1px solid #ffffff;
            border-radius: 24px;
            font-size: 20px;
            transition: all 0.2s;
            background: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        .top-search-container input:focus {
            outline: none;
            border-color: #ffffff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .top-search-container input::placeholder {
            color: #000000;
        }
        .top-search-container input:focus::placeholder {
            opacity: 0;
        }
        
        @media (max-width: 968px) {
            .preview-container {
                max-width: 100% !important;
                width: 100% !important;
            }
            .preview-content-wrapper {
                flex-direction: column;
                overflow-x: visible !important;
                max-width: 100% !important;
                width: 100% !important;
            }
            .preview-sidebar { 
                display: none !important;
            }
            .show-sidebar-btn,
            .preview-sidebar.collapsed ~ .preview-main .show-sidebar-btn,
            .preview-sidebar.collapsed + * .show-sidebar-btn,
            body:has(.preview-sidebar.collapsed) .show-sidebar-btn {
                display: none !important;
            }
            .preview-main {
                order: 1;
                overflow-x: visible !important;
                width: 100% !important;
                max-width: 100% !important;
                padding-left: 0 !important;
                padding-right: 0 !important;
            }
            .preview-main .preview-grid {
                padding: 0 20px 30px 20px;
            }
            .preview-main .preview-results {
                padding: 0 20px;
            }
            /* Unified mobile search and filter bar container - one border around everything */
            .mobile-filter-bar {
                display: flex;
                flex-wrap: wrap;
                gap: 0;
                padding: 0;
                background: #ffffff !important;
                position: sticky !important;
                top: 5px !important;
                z-index: 1002 !important;
                margin: 16px 16px 0 16px !important;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12), 0 2px 6px rgba(0, 0, 0, 0.1) !important;
                border: 1px solid #e5e7eb;
                border-radius: 22px;
                overflow: hidden;
            }
            
            /* Force line break after search row - ensures filters are on their own row */
            .mobile-filter-bar::after {
                content: '';
                order: 2;
                flex-basis: 100%;
                width: 100%;
                height: 0;
            }
            
            /* Filter row - horizontal container for filters */
            .mobile-filter-bar .filter-row {
                display: flex;
                flex-direction: row;
                width: 100%;
            }
            
            /* Search section - top of bar, flexible width when clear button appears */
            .mobile-filter-bar .top-search-container {
                order: 1;
                flex: 1 1 0;
                min-width: 0;
                margin: 0 !important;
                padding: 8px 20px 8px 8px;
                background: transparent !important;
                backdrop-filter: none !important;
                -webkit-backdrop-filter: none !important;
                mask-image: none !important;
                -webkit-mask-image: none !important;
                border-bottom: 1px solid #e5e7eb;
                border-left: none;
                border-right: none;
                border-top: none;
                display: block !important;
                border-radius: 0;
            }
            
            .mobile-filter-bar .search-input-wrapper {
                width: 100%;
            }
            
            .mobile-filter-bar .top-search-container input {
                width: 100%;
                padding: 6px 16px 6px 23px;
                border: none;
                border-radius: 0;
                font-size: 18px;
                background: transparent;
                box-shadow: none;
                transition: all 0.2s;
            }
            
            .mobile-filter-bar .top-search-container input:focus {
                outline: none;
                border: none;
                background: transparent;
                box-shadow: none;
            }
            
            .mobile-filter-bar .top-search-container input::placeholder {
                color: #000000;
            }
            .mobile-filter-bar .top-search-container input:focus::placeholder {
                opacity: 0;
            }
            
            .mobile-filter-bar .search-icon {
                left: -4px;
                width: 22px;
                height: 22px;
                color: var(--badge-featured-bg);
            }
            
            /* Filter section - below search bar */
            .mobile-filter-bar .mobile-filters-row {
                display: flex;
                flex-direction: row;
                align-items: stretch;
                gap: 0;
                padding: 0;
                background: #ffffff;
            }
            
            /* Filter section container - horizontal row */
            .mobile-filter-bar .mobile-filters-container {
                display: flex;
                flex-direction: row;
                width: 100%;
                background: #ffffff;
            }
            
            /* Filter row container - horizontal layout */
            .mobile-filter-bar .mobile-filters-row {
                display: flex;
                flex-direction: row;
                align-items: stretch;
                width: 100%;
                background: #ffffff;
            }
            
            /* Container for Type, Area, and Amenities filters */
            .mobile-filter-bar > .mobile-filters-wrapper {
                order: 3;
                flex: 1 1 calc(100% - 50px);
                width: calc(100% - 50px);
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
            }
            
            /* Filter controls inside wrapper - each gets 1/3 */
            .mobile-filters-wrapper > .mobile-filter-group {
                flex: 0 0 33.333%;
                width: 33.333%;
                position: relative;
                display: flex !important;
                align-items: center;
                flex-basis: 33.333%;
                min-width: 0;
                padding: 0 8px;
            }
            
            /* Filter controls inside unified mobile bar - horizontal row, FORCED to new row */
            .mobile-filter-bar > .mobile-filter-group {
                order: 3;
                flex: 0 0 25%;
                width: 25%;
                position: relative;
                display: flex !important;
                align-items: center;
                flex-basis: 25%;
                min-width: 25%;
                padding: 0 8px;
            }
            
            /* Category filter - compact, icon only */
            .mobile-filter-bar > .mobile-category-filter-group {
                flex: 0 0 50px;
                width: 50px;
                min-width: 50px;
                max-width: 50px;
                padding: 0;
                position: relative;
            }
            
            .mobile-filter-bar > .mobile-category-filter-group select {
                padding: 0;
                width: 100%;
                height: 100%;
                text-indent: -9999px; /* Hide text on the bar */
                color: transparent; /* Make text invisible */
                position: relative;
                appearance: none !important;
                -webkit-appearance: none !important;
                -moz-appearance: none !important;
                background-color: transparent !important;
                background-image: none !important;
                border: none;
                outline: none;
                cursor: pointer;
            }
            
            /* Remove dropdown arrow - all browser variants */
            .mobile-filter-bar > .mobile-category-filter-group select::-ms-expand {
                display: none !important; /* IE/Edge */
            }
            
            .mobile-filter-bar > .mobile-category-filter-group select::-webkit-appearance {
                -webkit-appearance: none !important;
            }
            
            /* Remove any pseudo-elements that might show arrows */
            .mobile-filter-bar > .mobile-category-filter-group select::after,
            .mobile-filter-bar > .mobile-category-filter-group select::before {
                display: none !important;
            }
            
            /* Icon wrapper for category select */
            .mobile-filter-bar > .mobile-category-filter-group::before {
                content: '';
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 20px;
                height: 20px;
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                pointer-events: none;
                z-index: 1;
                background-image: url('icons/all-types.svg'); /* Default icon */
                transition: filter 0.2s ease;
            }
            
            /* Category-specific background colors and white icon when selected */
            /* Colors match the SVG icon stroke colors */
            .mobile-filter-bar > .mobile-category-filter-group.category-outdoor {
                background-color: #7575b5 !important; /* Purple-blue - outdoor SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-outdoor select {
                background-color: #7575b5 !important; /* Purple-blue - outdoor SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-outdoor::before {
                filter: brightness(0) invert(1); /* Make icon white */
            }
            
            .mobile-filter-bar > .mobile-category-filter-group.category-stay {
                background-color: #e5675c !important; /* Red/coral - stay SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-stay select {
                background-color: #e5675c !important; /* Red/coral - stay SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-stay::before {
                filter: brightness(0) invert(1); /* Make icon white */
            }
            
            .mobile-filter-bar > .mobile-category-filter-group.category-taste {
                background-color: #57d1ae !important; /* Teal/green - taste SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-taste select {
                background-color: #57d1ae !important; /* Teal/green - taste SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-taste::before {
                filter: brightness(0) invert(1); /* Make icon white */
            }
            
            .mobile-filter-bar > .mobile-category-filter-group.category-culture {
                background-color: #8b5cf6 !important; /* Purple - culture SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-culture select {
                background-color: #8b5cf6 !important; /* Purple - culture SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-culture::before {
                filter: brightness(0) invert(1); /* Make icon white */
            }
            
            .mobile-filter-bar > .mobile-category-filter-group.category-experience {
                background-color: #f1b918 !important; /* Yellow/gold - experience SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-experience select {
                background-color: #f1b918 !important; /* Yellow/gold - experience SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-experience::before {
                filter: brightness(0) invert(1); /* Make icon white */
            }
            
            .mobile-filter-bar > .mobile-category-filter-group.category-community {
                background-color: #a3bb12 !important; /* Green/yellow-green - community SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-community select {
                background-color: #a3bb12 !important; /* Green/yellow-green - community SVG color */
            }
            .mobile-filter-bar > .mobile-category-filter-group.category-community::before {
                filter: brightness(0) invert(1); /* Make icon white */
            }
            
            /* Show text in dropdown options */
            .mobile-filter-bar > .mobile-category-filter-group select option {
                text-indent: 0; /* Show text in dropdown */
                color: #000; /* Make text visible in dropdown */
                padding-left: 8px;
            }
            
            
            /* Fine vertical dividers between filters - full height */
            .mobile-filter-bar > .mobile-filter-group:not(:last-child)::after {
                content: '';
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 1px;
                height: 100%;
                background: #e5e7eb;
            }
            
            /* Divider after category filter */
            .mobile-filter-bar > .mobile-category-filter-group::after {
                content: '';
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 1px;
                height: 100%;
                background: #e5e7eb;
            }
            
            /* Dividers between filters inside wrapper */
            .mobile-filters-wrapper > .mobile-filter-group:not(:last-child)::after {
                content: '';
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 1px;
                height: 100%;
                background: #e5e7eb;
            }
            
            /* Clear button - appears inline with search bar on the right, same row */
            .mobile-filter-bar > .mobile-clear-btn {
                order: 1;
                flex: 0 0 auto;
                padding: 14px 20px;
                border: none;
                border-radius: 0;
                font-size: 13px;
                font-weight: 400;
                background: #FF6360;
                color: #ffffff;
                cursor: pointer;
                transition: all 0.2s;
                white-space: nowrap;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
                height: auto;
                border-left: 1px solid #e5e7eb;
                border-bottom: 1px solid #e5e7eb;
                border-top: none;
                border-right: none;
            }
            
            .mobile-filter-bar > .mobile-clear-btn svg {
                width: 14px;
                height: 14px;
                flex-shrink: 0;
                color: #ffffff;
                stroke: #ffffff;
                vertical-align: middle;
                transform: translateY(-3px);
            }
            
            .mobile-filter-bar > .mobile-clear-btn span {
                color: #ffffff;
                line-height: 1;
            }
            
            .mobile-filter-bar > .mobile-clear-btn:hover {
                background-color: #e04d4a;
            }
            
            /* Hide clear button when JavaScript sets display: none */
            .mobile-filter-bar > .mobile-clear-btn[style*="display: none"] {
                display: none !important;
            }
            
            /* Original top-search-container styling for desktop - hide on mobile */
            .top-search-container {
                margin-left: 0 !important;
                margin-right: 0 !important;
                padding-left: 30px !important;
                padding-right: 30px !important;
            }
            
            @media (max-width: 968px) {
                /* Hide desktop search container on mobile */
                .preview-main > .top-search-container {
                    display: none !important;
                }
                /* Show blur bar on mobile - independent element behind the mobile filter bar */
                .mobile-blur-bar {
                    display: block !important;
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    width: 100% !important;
                    height: 100px !important;
                    z-index: 1000 !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    background: linear-gradient(
                        to bottom,
                        var(--bg-primary) 0%,
                        var(--bg-primary) 30%,
                        rgba(255, 255, 255, 0.5) 50%,
                        transparent 70%
                    ) !important;
                    backdrop-filter: blur(12px) !important;
                    -webkit-backdrop-filter: blur(12px) !important;
                    mask-image: linear-gradient(
                        to bottom,
                        black 0%,
                        black 60%,
                        rgba(0, 0, 0, 0.8) 75%,
                        rgba(0, 0, 0, 0.5) 85%,
                        rgba(0, 0, 0, 0.2) 92%,
                        transparent 100%
                    ) !important;
                    -webkit-mask-image: linear-gradient(
                        to bottom,
                        black 0%,
                        black 60%,
                        rgba(0, 0, 0, 0.8) 75%,
                        rgba(0, 0, 0, 0.5) 85%,
                        rgba(0, 0, 0, 0.2) 92%,
                        transparent 100%
                    ) !important;
                    pointer-events: none !important;
                }
                /* Explicitly show search inside mobile filter bar */
                .mobile-filter-bar .top-search-container {
                    display: block !important;
                }
            }
            
            /* Hide blur bar on desktop */
            @media (min-width: 969px) {
                .mobile-blur-bar {
                    display: none !important;
                }
            }
            .mobile-filter-group {
                flex: 0 0 33.333%;
                width: 33.333%;
                display: flex;
                align-items: center;
                position: relative;
                box-sizing: border-box;
                padding: 0 20px;
            }
            
            /* First filter gets left padding, last gets right padding to match search margins */
            .mobile-filter-bar > .mobile-filter-group:first-of-type {
                padding-left: 20px;
            }
            
            .mobile-filter-bar > .mobile-filter-group:last-of-type {
                padding-right: 20px;
            }
            
            /* Remove any right border/divider from the last filter */
            .mobile-filter-bar > .mobile-filter-group:last-of-type::after {
                display: none !important;
            }
            .mobile-filter-group select {
                width: 100%;
                padding: 14px 10px 14px 40px;
                border: none;
                border-radius: 0;
                font-size: 14px;
                background: #ffffff;
                color: var(--text-primary);
                cursor: pointer;
                transition: letter-spacing 0.3s ease;
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239ca3af' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 10px center;
                padding-right: 28px;
                box-shadow: none;
                text-align: left;
                box-sizing: border-box;
                letter-spacing: 0;
            }
            
            /* Hiking icon for All Types filter - Purple */
            #mobileTypeFilter {
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239333ea' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M8.76,6.63a1.09,1.09,0,0,1,2,0l2.8,5.53v0L15,8.9a1,1,0,0,1,1.8,0L21,18H3Z'/%3E%3C/svg%3E"),
                                  url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239ca3af' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
                background-repeat: no-repeat, no-repeat;
                background-position: 14px center, right 14px center;
                background-size: 16px 16px, 12px 12px;
                padding-left: 40px;
            }
            
            /* Pin icon for All Areas filter */
            #mobileAreaFilter {
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23D65052' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E"),
                                  url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239ca3af' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
                background-repeat: no-repeat, no-repeat;
                background-position: 14px center, right 14px center;
                background-size: 16px 16px, 12px 12px;
                padding-left: 40px;
            }
            
            /* Star icon for All Amenities filter - Orange/Yellow */
            #mobileAmenityFilter {
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23f59e0b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z'/%3E%3C/svg%3E"),
                                  url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239ca3af' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
                background-repeat: no-repeat, no-repeat;
                background-position: 14px center, right 14px center;
                background-size: 16px 16px, 12px 12px;
                padding-left: 40px;
            }
            .mobile-filter-group select:hover {
                background-color: #ffffff;
                letter-spacing: 0.3px;
            }
            .mobile-filter-group select:focus {
                outline: none;
                background-color: #ffffff;
            }
            
            /* Even tighter configuration for very small screens */
            @media (max-width: 440px) {
                .mobile-filter-bar > .mobile-filter-group {
                    padding: 0 2px 0 6px;
                }
                
                /* Keep category filter at 50px on all mobile screens */
                .mobile-filter-bar > .mobile-category-filter-group {
                    flex: 0 0 50px !important;
                    width: 50px !important;
                    min-width: 50px !important;
                    max-width: 50px !important;
                    padding: 0 2px !important;
                }
                
                /* Container takes remaining space after 50px category filter */
                .mobile-filter-bar > .mobile-filters-wrapper {
                    flex: 1 1 calc(100% - 50px) !important;
                    width: calc(100% - 50px) !important;
                    min-width: 0;
                }
                
                /* Each filter in wrapper gets 1/3 of remaining space */
                .mobile-filters-wrapper > .mobile-filter-group {
                    flex: 0 0 33.333% !important;
                    width: 33.333% !important;
                    flex-basis: 33.333% !important;
                    min-width: 0 !important;
                    padding: 0 2px 0 4px;
                }
                .mobile-filter-group select {
                    padding: 12px 2px 12px 26px;
                    padding-right: 2px;
                    font-size: 15px;
                    appearance: none !important;
                    -webkit-appearance: none !important;
                    -moz-appearance: none !important;
                }
                
                /* Remove dropdown arrows for all mobile selects on small screens */
                .mobile-filter-group select::-ms-expand {
                    display: none !important;
                }
                
                /* Restore icons for Type, Area, and Amenities filters */
                #mobileTypeFilter,
                #mobileAreaFilter,
                #mobileAmenityFilter {
                    padding-left: 26px;
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239333ea' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M8.76,6.63a1.09,1.09,0,0,1,2,0l2.8,5.53v0L15,8.9a1,1,0,0,1,1.8,0L21,18H3Z'/%3E%3C/svg%3E");
                    background-position: 6px center;
                    background-size: 14px 14px;
                    background-repeat: no-repeat;
                }
                #mobileTypeFilter {
                    padding-left: 32px;
                    background-position: 12px center;
                }
                #mobileAreaFilter {
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23D65052' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 10.5a3 3 0 11-6 0 3 3 0 016 0z' /%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z' /%3E%3C/svg%3E");
                }
                #mobileAmenityFilter {
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23f59e0b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z'/%3E%3C/svg%3E");
                }
            }
            /* Clear button styling is now above in the mobile-filter-bar section */
        }
        @media (min-width: 969px) {
            .mobile-filter-bar {
                display: none !important;
            }
        }
        
        .preview-grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
        
        /* 2 columns at 435px and wider */
        @media (min-width: 435px) {
            .preview-grid { grid-template-columns: repeat(2, 1fr); }
        }
        /* 3 columns at 850px and wider */
        @media (min-width: 680px) {
            .preview-grid { grid-template-columns: repeat(3, 1fr); }
        }
        /* 4 columns at 1400px and wider */
        @media (min-width: 1400px) {
            .preview-grid { grid-template-columns: repeat(4, 1fr); }
        }
        /* Desktop only: Add one more column when sidebar is collapsed */
        @media (min-width: 969px) {
            /* 3 columns when sidebar is collapsed at 400px+ */
            @media (min-width: 400px) {
                .preview-sidebar.collapsed ~ .preview-main .preview-grid,
                body:has(.preview-sidebar.collapsed) .preview-grid {
                    grid-template-columns: repeat(3, 1fr);
                }
            }
            /* 4 columns when sidebar is collapsed at 680px+ */
            @media (min-width: 680px) {
                .preview-sidebar.collapsed ~ .preview-main .preview-grid,
                body:has(.preview-sidebar.collapsed) .preview-grid {
                    grid-template-columns: repeat(4, 1fr);
                }
            }
            /* 5 columns when sidebar is collapsed at 1400px+ */
            @media (min-width: 1400px) {
                .preview-sidebar.collapsed ~ .preview-main .preview-grid,
                body:has(.preview-sidebar.collapsed) .preview-grid {
                    grid-template-columns: repeat(5, 1fr);
                }
            }
        }
        
        /* Map Styles */
        .map-container {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 0;
            margin-top: 25px;
            margin-bottom: 30px;
            box-shadow: none;
            transition: all 0.3s;
            position: relative;
        }
        .map-container.map-collapsed {
            background: transparent !important;
        }
        
        @media (max-width: 968px) {
            .map-container {
                box-shadow: none !important;
                padding: 0 !important;
                margin: 16px !important;
                margin-top: 30px !important;
                position: relative;
            }
            .map-header {
                position: absolute;
                top: 10px;
                left: 10px;
                z-index: 1000;
                margin: 0 !important;
                justify-content: flex-start;
            }
            .map-collapsed .map-header {
                left: 50%;
                top: 1px;
                transform: translateX(-50%);
                justify-content: center;
            }
            /* On very small screens, move open map button to left and hide listing count */
            @media (max-width: 461px) {
                .preview-results {
                    display: none !important;
                }
                .map-collapsed .map-header {
                    left: 10px;
                    transform: none;
                    justify-content: flex-start;
                }
            }
            .map-header h2 {
                display: none !important;
            }
            .map-toggle-btn {
                width: 36px;
                height: 36px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;
                gap: 6px;
            }
            .map-collapsed .map-toggle-btn {
                width: auto !important;
                padding: 10px 14px !important;
                transform: translateY(-30px) !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08) !important;
            }
            .map-toggle-text {
                font-size: 12px;
            }
            #map {
                border-radius: 20px;
                height: 33.333vh !important;
            }
        }
        .map-collapsed {
            padding: 0;
            margin-top: 0;
            margin-bottom: -20px;
            background: transparent !important;
        }
        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            transition: all 0.3s;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            margin: 0;
            justify-content: flex-start;
        }
        .map-collapsed .map-header {
            justify-content: center;
            gap: 12px;
            margin-bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;
            top: 23px;
        }
        .map-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            transition: all 0.3s;
        }
        .map-collapsed .map-header h2 {
            font-size: 16px;
        }
        .map-toggle-btn {
            background: white;
            color: var(--text-primary);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            transition: all 0.3s;
            padding: 0;
            gap: 8px;
        }
        .map-toggle-text {
            display: none;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }
        .map-collapsed .map-toggle-btn {
            width: auto;
            border-radius: 12px;
            padding: 10px 24px 10px 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            height: auto;
        }
        .map-collapsed .map-toggle-text {
            display: inline;
        }
        .map-toggle-btn:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }
        .map-toggle-btn svg {
            display: block;
        }
        .map-collapsed .map-toggle-btn svg {
            stroke: #22c55e;
            color: #22c55e;
        }
        #map {
            height: 500px;
            width: 100%;
            border-radius: 24px;
            overflow: hidden;
        }
        .map-collapsed #map {
            display: none;
        }
        
        /* Hide Google Maps attribution, copyright, and footer links at the bottom */
        .gm-style-cc {
            display: none !important;
        }
        .gm-style-cc a,
        .gm-style-cc button,
        .gm-style-cc span,
        .gm-style-cc div {
            display: none !important;
        }
        
        /* Hide keyboard shortcuts notice (specific button) */
        .gm-style button[title*="keyboard" i],
        .gm-style button[title*="Keyboard" i],
        .gm-style button[aria-label*="keyboard" i],
        .gm-style button[aria-label*="Keyboard" i] {
            display: none !important;
        }
        
        /* Hide specific attribution links - be very specific */
        .gm-style a[href*="terms"],
        .gm-style a[href*="Report a map error"],
        .gm-style a[href*="report"] {
            display: none !important;
        }
        
        /* Clean up map appearance - but don't hide the map itself */
        .gm-style {
            font-family: inherit !important;
        }
        
        /* Ensure map controls are styled nicely */
        .gm-style-iw-t::after {
            background: transparent !important;
        }
        
        /* Style Google Maps zoom controls with rounded corners */
        /* Target all Google Maps control containers */
        .gm-style > div > div > div[style*="right"] > div,
        .gm-style > div > div > div[style*="right"],
        div[style*="position: absolute"][style*="right"] > div > div,
        /* Target zoom control buttons directly */
        button[aria-label*="Zoom"],
        button[title*="Zoom"],
        /* Target the zoom control container classes */
        .gm-style-ctrl,
        .gm-style-ctrl-active,
        .gm-control-active,
        /* More specific zoom control targets */
        .gm-style-ctrl-top-right,
        .gm-style-ctrl-right,
        /* Target all divs and buttons within zoom area */
        div[id*="zoom"],
        .gm-style button,
        /* Direct descendant targeting */
        .gm-style > div > div > div > div > button,
        .gm-style > div > div > div > div > div > button {
            border-radius: 16px !important;
        }
        
        /* Ensure the zoom control wrapper is rounded */
        .gm-style div[style*="position: absolute"] div[style*="position: absolute"]:has(button[aria-label*="Zoom"]) {
            border-radius: 16px !important;
            overflow: hidden !important;
        }
        
        /* Round individual buttons more aggressively */
        .gm-style button {
            border-radius: 16px !important;
            border-top-left-radius: 16px !important;
            border-top-right-radius: 16px !important;
            border-bottom-left-radius: 16px !important;
            border-bottom-right-radius: 16px !important;
        }
        
        /* Round the container holding zoom buttons */
        .gm-style > div > div > div > div {
            border-radius: 16px !important;
        }        
        /* Custom Google Maps Info Window Styles */
        /* Custom Google Maps Info Window Styles */
        .gm-style .gm-style-iw-c {
            border-radius: 16px !important;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2) !important;
            padding: 0 12px 12px !important; /* add bottom padding to avoid clipping button */
            margin: 0 !important;
            max-width: 340px !important;
            overflow: hidden !important;
        }
        @media (min-width: 969px) {
            .gm-style .gm-style-iw-c {
                width: 200px !important;
                height: 200px !important;
                padding: 0 !important;
                border-radius: 12px !important;
                margin: 0 !important;
                overflow: hidden !important;
            }
            .gm-style-iw-ch {
                padding: 0 !important;
                margin: 0 !important;
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style-iw-t {
                padding: 0 !important;
                margin: 0 !important;
            }
            .gm-style-iw-t > div {
                padding: 0 !important;
                margin: 0 !important;
            }
            .gm-style .gm-style-iw-d {
                padding: 0 !important;
                margin: 0 !important;
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style .gm-style-iw-d > div {
                margin: 0 !important;
                padding: 0 !important;
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style .gm-style-iw-d > div > div {
                margin: 0 !important;
                padding: 0 !important;
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style .gm-style-iw-d > div > div > div {
                margin: 0 !important;
                padding: 0 !important;
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style .gm-style-iw-d > * {
                margin: 0 !important;
                padding: 0 !important;
            }
            .gm-style-iw button {
                position: absolute !important;
                top: 4px !important;
                right: 4px !important;
                z-index: 1001 !important;
                margin: 0 !important;
            }
        }
        @media (max-width: 968px) {
            .gm-style .gm-style-iw-c {
                width: 120px !important;
                height: 120px !important;
                padding: 0 !important;
                border-radius: 12px !important;
                margin: 0 !important;
                overflow: hidden !important;
            }
            .gm-style-iw-ch {
                padding: 0 !important;
                margin: 0 !important;
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style-iw-t {
                padding: 0 !important;
                margin: 0 !important;
            }
            .gm-style-iw-t > div {
                padding: 0 !important;
                margin: 0 !important;
            }
            .gm-style .gm-style-iw-d {
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style .gm-style-iw-d > div {
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style .gm-style-iw-d > div > div {
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            .gm-style-iw button {
                position: absolute !important;
                top: 4px !important;
                right: 4px !important;
                z-index: 1001 !important;
                margin: 0 !important;
            }
            .gm-style .gm-style-iw-d {
                padding: 0 !important;
                margin: 0 !important;
            }
            .gm-style .gm-style-iw-d > div {
                margin: 0 !important;
                padding: 0 !important;
            }
            .gm-style .gm-style-iw-d > div > div {
                margin: 0 !important;
                padding: 0 !important;
            }
            .gm-style .gm-style-iw-d > div > div > div {
                margin: 0 !important;
                padding: 0 !important;
            }
            .gm-style .gm-style-iw-d > * {
                margin: 0 !important;
                padding: 0 !important;
            }
        }
        .gm-style .gm-style-iw-d {
            overflow: hidden !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .gm-style .gm-style-iw-d > div {
            margin: 0 !important;
            padding: 0 !important;
        }
        .gm-style .gm-style-iw-d > div > div {
            margin: 0 !important;
            padding: 0 !important;
        }
        .gm-style img {
            margin: 0 !important;
            padding: 0 !important;
            display: block !important;
            border: none !important;
            outline: none !important;
        }
        @media (max-width: 968px) {
            .gm-style img {
                margin: 0 !important;
                padding: 0 !important;
                border: 0 !important;
                outline: 0 !important;
                line-height: 0 !important;
                vertical-align: top !important;
            }
        }
        .gm-style-iw button {
            top: 8px !important;
            right: 8px !important;
            width: 28px !important;
            height: 28px !important;
            background: rgba(255, 255, 255, 0.7) !important;
            border-radius: 50% !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2) !important;
            z-index: 1000 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
            padding: 0 !important;
            overflow: hidden !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
        }
        .gm-style-iw button:hover {
            background: rgba(255, 255, 255, 0.9) !important;
        }
        /* Center and properly size the X icon within the circle */
        .gm-style-iw button > * {
            width: 14px !important;
            height: 14px !important;
            margin: 0 !important;
            padding: 0 !important;
            display: block !important;
            max-width: 14px !important;
            max-height: 14px !important;
            object-fit: contain !important;
            object-position: center !important;
            background-position: center !important;
            background-size: 14px 14px !important;
            background-repeat: no-repeat !important;
        }
        .gm-style-iw button img {
            width: 14px !important;
            height: 14px !important;
            margin: 0 !important;
            padding: 0 !important;
            display: block !important;
            max-width: 14px !important;
            max-height: 14px !important;
            object-fit: contain !important;
            object-position: center !important;
        }
        .map-popup-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 14px;
            padding-right: 30px;
            line-height: 1.3;
        }
        .map-popup-badges {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        /* Fix badge layout in map popups - show icons like main cards */
        .gm-style-iw .badge {
            display: inline-flex !important;
            align-items: center !important;
            gap: 6px !important;
            vertical-align: middle !important;
            line-height: 1.4 !important;
            position: relative !important;
            padding: 4px 10px !important; /* match .badge */
            border-radius: 6px !important; /* match main cards */
            font-size: 12px !important; /* match .badge */
            font-weight: 600 !important; /* match .badge */
            margin: 0 !important;
            border: none !important;
            cursor: pointer !important;
        }
        /* Show icons for badges in map popups */
        .gm-style-iw .badge-type::before {
            content: '' !important;
            display: inline-block !important;
            width: 14px !important;
            height: 14px !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            background-position: center !important;
            flex-shrink: 0 !important;
        }
        .gm-style-iw .badge-area::before {
            content: '' !important;
            display: inline-block !important;
            width: 14px !important;
            height: 14px !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            background-position: center !important;
            flex-shrink: 0 !important;
            background-image: var(--icon-local) !important;
        }
        /* Ensure badge background colors work in map */
        .gm-style-iw .badge-type {
            background: var(--badge-type-bg) !important;
            color: var(--badge-type-color) !important;
        }
        .gm-style-iw .badge-area {
            background: var(--badge-area-bg) !important;
            color: var(--badge-area-color) !important;
            border-radius: 6px !important; /* Force same radius as main cards */
        }
        .gm-style-iw .badge-type {
            border-radius: 6px !important; /* Force same radius as main cards */
        }
        .map-popup-desc {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }
        .map-popup-btn {
            display: inline-block;
            background: #2d6a4f !important;
            color: white !important;
            padding: 16px 18px;
            border-radius: 10px;
            text-decoration: none;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: none;
            cursor: pointer;
        }
        .map-popup-btn:hover {
            background: var(--theme-primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        /* Ensure Google Maps info window doesn't override button styles */
        .gm-style-iw .map-popup-btn {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            width: 100% !important;
            padding: 18px 20px !important;
            background: #2d6a4f !important;
            color: #ffffff !important;
            border: none !important;
            border-radius: 10px !important;
            text-align: center !important;
            text-decoration: none !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            line-height: 1 !important;
            cursor: pointer !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
            margin-bottom: 10px !important;
        }
        .gm-style-iw .map-popup-btn:hover {
            background: var(--theme-primary-hover) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
        }
        
        .flip-card { 
            cursor: pointer; 
            position: relative; 
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.6s ease-out, transform 0.6s ease-out;
            container-type: inline-size;
            container-name: card;
            will-change: transform;
            contain: layout style paint;
            height: 100%;
            display: flex;
            flex-direction: column;
            opacity: 0;
            transform: translateY(20px);
        }
        
        /* Smooth fade-in for cards on load */
        .flip-card.card-loaded {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Intersection Observer will add this class when card comes into view */
        .flip-card.card-visible {
            opacity: 1;
            transform: translateY(0);
        }
        .flip-card-inner { 
            position: relative; 
            width: 100%; 
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .flip-card-front, .flip-card-back { 
            width: 100%; 
            border-radius: 16px; 
            transition: opacity 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease; 
            background: var(--card-bg); 
            transform-origin: center center;
        }
        .flip-card:hover .flip-card-front,
        .flip-card:hover .flip-card-back {
            transform: scale(0.98);
        }
        .flip-card-front { position: relative; opacity: 1; transform: scale(1); display: flex; flex-direction: column; overflow: hidden; }
        .flip-card-back { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%;
            height: 100%;
            max-height: 100%;
            display: flex; 
            flex-direction: column; 
            opacity: 0; 
            transform: scale(0.96); 
            pointer-events: none; 
            overflow-y: auto; 
            overflow-x: hidden; 
            -webkit-overflow-scrolling: touch;
            box-sizing: border-box;
        }
        .flip-card-back::-webkit-scrollbar {
            width: 6px;
        }
        .flip-card-back::-webkit-scrollbar-track {
            background: transparent;
        }
        .flip-card-back::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        .flip-card-back::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        .flip-card.flipped { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08); border-radius: 24px; overflow: hidden; }
        .flip-card.flipped .flip-card-front { opacity: 0; transform: scale(0.96); pointer-events: none; }
        .flip-card.flipped .flip-card-back { opacity: 1; transform: scale(1); pointer-events: auto; border-radius: 24px; }
        
        /* Card front title - responsive to card width using container queries */
        .flip-card-front h3 {
            font-size: 16px !important;
            font-weight: 700 !important;
            margin-bottom: 10px !important;
            color: var(--text-primary) !important;
            line-height: 1.2 !important;
            orphans: 3 !important;
            widows: 3 !important;
        }
        
        /* Scale title based on card width */
        @container card (min-width: 200px) {
            .flip-card-front h3 { font-size: 17px !important; }
        }
        @container card (min-width: 260px) {
            .flip-card-front h3 { font-size: 18px !important; }
        }
        @container card (min-width: 300px) {
            .flip-card-front h3 { font-size: 20px !important; }
        }
        @container card (min-width: 350px) {
            .flip-card-front h3 { font-size: 22px !important; }
        }
        
        /* Card front description - limit to 2 lines by default (when title is multi-line) */
        .flip-card-front p {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-clamp: 2;
        }
        /* Allow 3 lines of description when title is single line */
        .flip-card.title-single-line .flip-card-front p {
            -webkit-line-clamp: 3;
            line-clamp: 3;
        }
        
        /* Scrollable images on card front - square by default, 3:2 (wider) on small screens */
        .card-front-image-scroll {
            position: relative;
            height: 0 !important;
            padding-bottom: 100% !important;
            width: 100%;
            overflow-x: auto !important;
            overflow-y: hidden !important;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            flex-shrink: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
            border-radius: 24px;
            clip-path: inset(0 round 24px);
        }
        
        /* 3:2 aspect ratio (wider than tall) for screens below 435px */
        @media (max-width: 434px) {
            .card-front-image-scroll {
                padding-bottom: 66.67% !important; /* 3:2 aspect ratio (height = 2/3 * width) */
            }
            .card-front-image-scroll img {
                aspect-ratio: 3 / 2 !important;
            }
        }
        .card-front-image-scroll::-webkit-scrollbar {
            display: none;
        }
        .card-front-image-scroll > div {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            display: flex;
            width: auto;
        }
        .card-front-image-scroll img {
            position: relative;
            border-radius: 24px !important;
            width: 100%;
            min-width: 100%;
            height: 100% !important;
            aspect-ratio: 1 / 1 !important;
            object-fit: cover !important;
            object-position: center !important;
            display: block !important;
            flex-shrink: 0;
            scroll-snap-align: start;
            filter: saturate(1.15) brightness(0.95); /* Increase saturation and slightly darken images */
        }
        .card-front-image-scroll::-webkit-scrollbar {
            display: none;
        }
        .scroll-arrow {
            position: absolute;
            width: 30px !important;
            height: 30px !important;
            min-width: 30px !important;
            max-width: 30px !important;
            min-height: 30px !important;
            max-height: 30px !important;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            background-size: 16px 16px !important;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0 !important;
            transition: opacity 0.3s ease;
            z-index: 10;
            cursor: pointer;
            pointer-events: auto !important;
            flex-shrink: 0 !important;
            box-sizing: border-box !important;
        }
        .scroll-arrow-right {
            right: 13px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23000' stroke-width='3'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5l7 7-7 7'/%3E%3C/svg%3E");
        }
        .scroll-arrow-left {
            left: 10px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23000' stroke-width='3'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M15 19l-7-7 7-7'/%3E%3C/svg%3E");
        }
        .flip-card-front:hover .scroll-arrow,
        .flip-card-front:hover .card-front-image-scroll .scroll-arrow {
            opacity: 1 !important;
        }
        .scroll-arrow:hover {
            background-color: rgba(255, 255, 255, 0.9);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23000' stroke-width='3'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5l7 7-7 7'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: 16px 16px !important;
            transform: translateY(-50%);
            width: 30px !important;
            height: 30px !important;
        }
        
        /* Overlay behind flipped card - constrained to viewport */
        .flip-overlay {
            display: none;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            max-height: 100vh !important;
            background: rgba(0, 0, 0, 0.7) !important;
            z-index: 999 !important;
            backdrop-filter: blur(4px) !important;
            overflow: hidden !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        .flip-overlay.active {
            display: block;
        }
        
        /* Sort dropdown styling */
        #sortDropdown {
            background: #ffffff !important;
            border: none !important;
            border-radius: 12px !important;
            padding: 10px 16px !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            color: #333 !important;
            cursor: pointer !important;
            appearance: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12' fill='none'%3E%3Cpath d='M3 4.5L6 7.5L9 4.5' stroke='%23333' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E") !important;
            background-repeat: no-repeat !important;
            background-position: right 12px center !important;
            padding-right: 36px !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08) !important;
            transition: all 0.2s ease !important;
        }
        #sortDropdown:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.12) !important;
            background-color: #fafafa !important;
        }
        #sortDropdown:focus {
            outline: none !important;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15), 0 0 0 2px rgba(45, 106, 79, 0.2) !important;
        }
        #sortDropdown option {
            background: #ffffff !important;
            color: #333 !important;
            padding: 10px !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
            font-size: 14px !important;
            font-weight: 500 !important;
        }
        
        /* Safari/Mac specific fix to force sans-serif font */
        @supports (-webkit-appearance: none) {
            #sortDropdown {
                font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;
            }
            #sortDropdown option {
                font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;
            }
        }
        
        /* Additional Safari-specific rules */
        select#sortDropdown,
        select#sortDropdown option {
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;
            -webkit-font-smoothing: antialiased !important;
            -moz-osx-font-smoothing: grayscale !important;
        }
        
        /* Safari/Mac specific fix to prevent serif fonts in native dropdown */
        @supports (-webkit-appearance: none) {
            #sortDropdown {
                -webkit-appearance: none !important;
                -moz-appearance: none !important;
                appearance: none !important;
                font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;
                -webkit-font-smoothing: antialiased !important;
                -moz-osx-font-smoothing: grayscale !important;
            }
            #sortDropdown optgroup,
            #sortDropdown option {
                font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;
                font-style: normal !important;
                font-variant: normal !important;
                font-synthesis: none !important;
                -webkit-font-smoothing: antialiased !important;
                -moz-osx-font-smoothing: grayscale !important;
            }
        }
        
        /* Expanded card modal-like view - uses CSS variables set by JavaScript */
        .flip-card.expanded { 
            position: fixed !important; 
            top: 0 !important;
            left: 0 !important;
            width: var(--viewport-width, 100vw) !important;
            height: var(--viewport-height, 100vh) !important;
            max-width: var(--viewport-width, 100vw) !important;
            max-height: var(--viewport-height, 100vh) !important;
            z-index: 1001 !important; 
            overflow: hidden !important;
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        .flip-card.expanded .flip-card-inner { 
            width: 90vw !important;
            max-width: 1100px !important;
            height: 80vh !important;
            max-height: 80vh !important;
            overflow: hidden !important;
            display: flex !important;
            flex-direction: column !important;
            box-sizing: border-box !important;
        }
        @media (min-width: 768px) {
            .flip-card.expanded .flip-card-inner {
                width: 70vw !important;
                height: 75vh !important;
                max-height: 75vh !important;
            }
        }
        @media (min-width: 1200px) {
            .flip-card.expanded .flip-card-inner {
                width: 50vw !important;
                max-width: 1100px !important;
                height: 75vh !important;
                max-height: 75vh !important;
            }
        }
        .flip-card.expanded .flip-card-front { opacity: 0; pointer-events: none; }
        .flip-card.expanded .flip-card-back { 
            opacity: 1; 
            transform: scale(1) !important; 
            pointer-events: auto; 
            height: 100% !important; 
            max-height: 100% !important;
            min-height: 0 !important;
            position: relative !important;
            overflow: hidden !important;
            box-sizing: border-box !important;
        }
        .flip-card.expanded:hover { 
            transform: none !important;
        }

        /* Back layout prioritizing imagery and title when expanded - constrained to card height, not viewport */
        .flip-card.expanded .flip-card-back .back-content { 
            padding: 20px 20px 40px 20px !important; 
            height: 100% !important; 
            max-height: 100% !important;
            min-height: 0 !important;
            display: flex !important; 
            flex-direction: column !important; 
            overflow: hidden !important;
            box-sizing: border-box !important;
        }
        .flip-card.expanded .flip-card-back .back-title { 
            font-size: 24px; 
            font-weight: 800; 
            line-height: 1.2; 
            color: var(--text-primary); 
            margin-bottom: 12px; 
            flex-shrink: 0;
        }
        .flip-card.expanded .flip-card-back .back-hero { 
            width: 100%; 
            height: 180px; 
            max-height: 180px;
            min-height: 0;
            border-radius: 12px; 
            overflow: hidden; 
            margin-bottom: 12px; 
            flex-shrink: 0;
        }
        .flip-card.expanded .flip-card-back .back-hero img { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
        }
        .flip-card.expanded .flip-card-back .back-body { 
            flex: 1; 
            padding-right: 6px; 
            overflow-y: auto;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        .flip-card.expanded .flip-card-back .two-up { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 10px; 
            margin-bottom: 12px; 
            flex-shrink: 0;
            height: 120px;
            max-height: 120px;
        }
        .flip-card.expanded .flip-card-back .two-up img { 
            width: 100%; 
            height: 100%; 
            max-height: 100%;
            object-fit: cover; 
            border-radius: 10px; 
        }
        /* If there's only one image in the two-up container, make it span both columns */
        .flip-card.expanded .flip-card-back .two-up img:only-child { grid-column: span 2; }
        
        /* Larger description text and tags on back */
        .flip-card .flip-card-back .back-body p { font-size: 16px !important; line-height: 1.65 !important; }
        .flip-card .flip-card-back .badge-type { font-size: 14px !important; padding: 6px 12px !important; border-radius: 8px !important; }
        .flip-card .flip-card-back .badge-area { font-size: 14px !important; padding: 6px 12px 6px 28px !important; border-radius: 8px !important; }
        .flip-card .flip-card-back .back-body > div[style*="display: flex;"] { gap: 10px !important; }
        
        /* Smaller amenities tags on back */
        .flip-card .flip-card-back .amenity { 
            font-size: 12px !important; 
            padding: 2px 6px !important; 
            border-radius: 6px !important; 
            margin: 0 !important; 
            line-height: 1.2 !important;
            letter-spacing: 0;
            transition: letter-spacing 0.3s ease-in-out;
        }
        .flip-card .flip-card-back .amenity:hover {
            letter-spacing: 0.2px !important;
        }
        
        /* Hover effects for address, phone, and website - increased letter spacing */
        .flip-card .flip-card-back .card-info-item a {
            letter-spacing: 0;
            transition: letter-spacing 0.3s ease-in-out;
        }
        .flip-card .flip-card-back .card-info-item:hover a {
            letter-spacing: 0.5px;
        }
        
        /* Title on back - balance ragged lines and control orphans/widows */
        .flip-card .flip-card-back h3,
        .flip-card .flip-card-back a[href*="/explore/"]:first-child {
            orphans: 2;
            widows: 2;
            text-wrap: balance;
        }
        
        /* Title hover effect - darken on hover */
        .flip-card .flip-card-back a[href*="/explore/"]:first-child {
            transition: color 0.3s ease-in-out;
        }
        .flip-card .flip-card-back a[href*="/explore/"]:first-child:hover {
            color: #4b5563 !important;
        }
        
        /* Description hover effect - lighten on hover */
        .flip-card .flip-card-back .back-description {
            transition: color 0.3s ease-in-out;
        }
        .flip-card .flip-card-back .back-description:hover {
            color: #6b7280 !important;
        }
        
        /* View Details button hover effect */
        .flip-card .flip-card-back a[href*="/explore/"]:last-child {
            letter-spacing: 0;
            transition: letter-spacing 0.3s ease-in-out;
        }
        .flip-card .flip-card-back a[href*="/explore/"]:last-child:hover {
            letter-spacing: 0.5px;
        }
        
        /* Back side image gallery */
        .flip-back-images {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .flip-back-image {
            flex: 1;
            height: 250px;
            border-radius: 12px;
            object-fit: cover;
        }
        
        /* Tags container on flip side */
        .flip-tags-container { margin: 15px 0; padding: 15px 0; border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); }
        .flip-tags-title { font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .flip-tags-list { display: flex; flex-wrap: wrap; gap: 6px; }
        
        /* Close button for flipped card */
        .flip-close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: background 0.3s;
        }
        .flip-close-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        
        @media (max-width: 768px) {
            .preview-sidebar { 
                width: 100% !important;
                min-width: 100% !important;
            }
            .type-filter-btn {
                font-size: 10px;
                padding: 5px 8px;
            }
            .preview-filters h3 {
                font-size: 14px;
            }
            .area-filter-btn {
                font-size: 11px;
                padding: 6px 10px;
            }
        }
        
    

    </style>
    
    <style>
        /* Framer-specific overrides to ensure proper container behavior */
        .preview-container {
            width: 100%;
            min-height: 100vh;
            position: relative;
        }
        /* Ensure the component works within Framer's responsive framework */
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            overflow-x: hidden;
        }
    </style>
</head>
<body>

        <div class="preview-container">
            <div class="preview-content-wrapper">
                <aside class="preview-sidebar">
                    <div class="preview-filters">
                        <div class="sidebar-header">
                            <button class="sidebar-toggle-btn" onclick="toggleSidebar()">
                                <svg id="sidebarToggleIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        <div class="filter-content">
                            <div class="filter-section">
                                <div class="type-quick-filters" id="typeQuickFilters">
                                    <button class="type-filter-btn category-filter-btn active" data-type="">
                                        <span class="category-icon"><img src="icons/all-types.svg" alt="All" style="width: 24px; height: 24px; display: block;" /></span>
                                        <span class="category-name">All</span>
                                    </button>
                                    <!-- Type filter buttons will be dynamically generated here based on data usage -->
                                </div>
                            </div>

                            <div class="filter-section">
                                <div class="preview-filter-group">
                                    <select id="previewTypeFilter" onchange="handleTypeFilter()">
                                        <option value="">All Types</option>
                                    </select>
                                </div>

                                <div class="preview-filter-group">
                                    <select id="previewAreaFilter" onchange="filterPreview()">
                                        <option value="">All Areas</option>
                                    <option value="Afton">Afton</option><option value="Wintergreen">Wintergreen</option><option value="Lovingston">Lovingston</option><option value="Nellysford">Nellysford</option><option value="Montebello">Montebello</option><option value="Arrington">Arrington</option><option value="Roseland">Roseland</option><option value="Seymour">Seymour</option>
                                </select>
                                </div>

                                <div class="preview-filter-group">
                                    <select id="previewAmenityFilter" onchange="filterPreview()">
                                        <option value="">All Amenities</option>
                                    <option value="Kid-Friendly">Kid-Friendly</option><option value="Pet-Friendly">Pet-Friendly</option><option value="Wheelchair Accessible">Wheelchair Accessible</option><option value="Free">Free</option><option value="Seasonal">Seasonal</option><option value="Outdoor Seating">Outdoor Seating</option><option value="Food Available">Food Available</option><option value="Live Music">Live Music</option><option value="Tours Available">Tours Available</option><option value="Events">Events</option><option value="Photography">Photography</option><option value="Scenic Views">Scenic Views</option><option value="Biking">Biking</option><option value="Appalachian Trail">Appalachian Trail</option><option value="Pro Shop">Pro Shop</option><option value="Lessons Available">Lessons Available</option><option value="Cart Rental">Cart Rental</option><option value="Lifeguards">Lifeguards</option>
                                </select>
                                </div>

                                <button id="clearFiltersBtn" class="btn btn-clear" onclick="clearPreviewFilters()" style="display: none;">Clear Filters</button>
                            </div>
                        </div>
                    </div>
                </aside>

                <main class="preview-main">
                    <!-- Floating button to show sidebar when collapsed -->
                    <button class="show-sidebar-btn" onclick="toggleSidebar()">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="width: 24px; height: 24px;">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>
                
                    <!-- Blur Bar (Mobile Only) -->
                    <div class="mobile-blur-bar"></div>
                
                    <!-- Search Bar (Desktop) -->
                    <div class="top-search-container">
                        <div class="search-input-wrapper">
                            <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                            </svg>
                            <input type="text" id="previewSearchInput" placeholder="Find your adventure">
                        </div>
                    </div>

                    <!-- Mobile Unified Search and Filter Bar -->
                    <div class="mobile-filter-bar">
                        <!-- Search bar inside mobile filter bar -->
                        <div class="top-search-container">
                            <div class="search-input-wrapper">
                                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                </svg>
                                <input type="text" id="previewSearchInputMobile" placeholder="Find your adventure">
                            </div>
                        </div>
                        <div class="mobile-filter-group mobile-category-filter-group">
                            <select id="mobileCategoryFilter" onchange="handleMobileCategoryFilter()">
                                <option value="">All</option>
                            </select>
                        </div>
                        <div class="mobile-filters-wrapper">
                            <div class="mobile-filter-group">
                                <select id="mobileTypeFilter" onchange="handleMobileTypeFilter()">
                                    <option value="">All Types</option>
                                </select>
                            </div>
                            <div class="mobile-filter-group">
                                <select id="mobileAreaFilter" onchange="handleMobileAreaFilter()">
                                    <option value="">Area</option>
                                </select>
                            </div>
                            <div class="mobile-filter-group">
                                <select id="mobileAmenityFilter" onchange="handleMobileAmenityFilter()">
                                    <option value="">Amenities</option>
                                </select>
                            </div>
                        </div>
                        <button id="mobileClearFiltersBtn" class="mobile-clear-btn" onclick="clearPreviewFilters()" style="display: none;">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
                            </svg>
                            <span>Clear</span>
                        </button>
                    </div>

                    <!-- Map Container -->
                    <div class="map-container" id="mapContainer">
                        <div class="map-header">
                            <h2 style="display: none;">Map View</h2>
                            <button class="map-toggle-btn" onclick="toggleMap()">
                                <svg id="mapToggleIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                                <span class="map-toggle-text">Open Map</span>
                            </button>
                        </div>
                        <div id="map"></div>
                    </div>

                    <div class="preview-results" style="display: flex; justify-content: space-between; align-items: center;">
                        <span id="previewResultsCount">Showing 15 listings</span>
                        <select id="sortDropdown" onchange="sortListings()" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px; cursor: pointer; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;">
                            <option value="default" selected style="font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;">Default</option>
                            <option value="name-asc" style="font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;">Name (A-Z)</option>
                            <option value="name-desc" style="font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;">Name (Z-A)</option>
                            <option value="area-asc" style="font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;">Area (A-Z)</option>
                            <option value="type-asc" style="font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;">Type (A-Z)</option>
                        </select>
                    </div>

                    <div id="previewGrid" class="preview-grid"></div>

                    <!-- Overlay for flipped cards -->
                    <div id="flipOverlay" class="flip-overlay" onclick="closeAllFlippedCards()"></div>
                </main>
            </div>
        </div>

    <!-- Embedded JavaScript - Contains all functionality -->
    <script>
// EMBEDDED FALLBACK DATA
// This data is used if GitHub fetch fails or until you save to GitHub
const fallbackData = {
  "listings": [
    {
      "id": "1",
      "name": "Devil's Backbone Brewing Company",
      "type": "Brewery",
      "area": "Wintergreen",
      "description": "Award-winning craft brewery nestled at the base of the Blue Ridge Mountains. Enjoy locally-brewed beers, live music, and mountain views from the outdoor beer garden.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://dbbrewingcompany.com",
      "phone": "(434) 361-1001",
      "address": "200 Mosbys Run, Roseland, VA 22967",
      "amenities": [
        "Pet-Friendly",
        "Outdoor Seating",
        "Live Music",
        "Food Available"
      ],
      "featured": true
    },
    {
      "id": "2",
      "name": "Crabtree Falls Trail",
      "type": "Hiking",
      "area": "Montebello",
      "description": "Virginia's highest vertical-drop cascading waterfall. This moderate 3-mile round trip hike features stunning overlooks and is especially beautiful in fall foliage season.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.fs.usda.gov/recarea/gwj/recarea/?recid=73957",
      "phone": "(540) 291-2188",
      "address": "Crabtree Falls Hwy, Montebello, VA 24464",
      "amenities": [
        "Free",
        "Kid-Friendly",
        "Scenic Views",
        "Photography"
      ],
      "featured": true
    },
    {
      "id": "3",
      "name": "Wintergreen Resort",
      "type": "Outdoor",
      "area": "Wintergreen",
      "description": "Four-season mountain resort offering skiing, snowboarding, mountain biking, hiking, golf, and spa services. Stunning Blue Ridge Mountain views year-round.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wintergreenresort.com",
      "phone": "(434) 325-2200",
      "address": "39 Mountain Inn Loop, Wintergreen, VA 22958",
      "amenities": [
        "Kid-Friendly",
        "Seasonal",
        "Wheelchair Accessible",
        "Lessons Available"
      ],
      "featured": true
    },
    {
      "id": "4",
      "name": "Blue Mountain Brewery",
      "type": "Brewery",
      "area": "Afton",
      "description": "Farm brewery and taproom with an on-site hop yard. Full restaurant menu featuring locally-sourced ingredients and spectacular mountain views from multiple decks.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.bluemountainbrewery.com",
      "phone": "(540) 456-8020",
      "address": "9519 Critzers Shop Rd, Afton, VA 22920",
      "amenities": [
        "Pet-Friendly",
        "Outdoor Seating",
        "Food Available",
        "Live Music"
      ],
      "featured": false
    },
    {
      "id": "5",
      "name": "The Plunge at Wintergreen",
      "type": "Outdoor",
      "area": "Wintergreen",
      "description": "Outdoor aquatic complex featuring water slides, lazy river, zero-entry pool, and lap pool. Perfect family summer destination with mountain views.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wintergreenresort.com/play/the-plunge",
      "phone": "(434) 325-8169",
      "address": "Wintergreen Dr, Wintergreen, VA 22958",
      "amenities": [
        "Kid-Friendly",
        "Seasonal",
        "Wheelchair Accessible",
        "Lifeguards"
      ],
      "featured": false
    },
    {
      "id": "6",
      "name": "Rockfish Valley Trail",
      "type": "Hiking",
      "area": "Nellysford",
      "description": "Easy 2-mile paved trail perfect for walking, jogging, or biking. Follows Rockfish River with mountain views and connects to local breweries and shops.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.nelsoncounty-va.gov/facilities/facility/details/Rockfish-Valley-Trail-25",
      "phone": "(434) 263-7015",
      "address": "Rockfish Valley Hwy, Nellysford, VA 22958",
      "amenities": [
        "Free",
        "Kid-Friendly",
        "Pet-Friendly",
        "Wheelchair Accessible",
        "Biking"
      ],
      "featured": false
    },
    {
      "id": "7",
      "name": "Wild Wolf Brewing Company",
      "type": "Brewery",
      "area": "Nellysford",
      "description": "Craft brewery with full kitchen, outdoor patio, and kid-friendly atmosphere. Known for creative seasonal beers and live music on weekends.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wildwolfbeer.com",
      "phone": "(434) 361-0088",
      "address": "2773 Rockfish Valley Hwy, Nellysford, VA 22958",
      "amenities": [
        "Kid-Friendly",
        "Pet-Friendly",
        "Outdoor Seating",
        "Food Available",
        "Live Music"
      ],
      "featured": false
    },
    {
      "id": "8",
      "name": "Stoney Creek Golf Course",
      "type": "Outdoor",
      "area": "Wintergreen",
      "description": "Championship 18-hole golf course designed by Rees Jones. Features dramatic elevation changes, mountain views, and challenging play for all skill levels.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.wintergreenresort.com/play/golf",
      "phone": "(434) 325-8250",
      "address": "Wintergreen Dr, Wintergreen, VA 22958",
      "amenities": [
        "Seasonal",
        "Pro Shop",
        "Lessons Available",
        "Cart Rental"
      ],
      "featured": false
    },
    {
      "id": "9",
      "name": "Humpback Rocks Trail",
      "type": "Hiking",
      "area": "Afton",
      "description": "Challenging 2-mile hike to stunning 360-degree Blue Ridge views. Part of the Appalachian Trail with rocky terrain and rewarding summit panoramas.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.nps.gov/blri/planyourvisit/humpback-rocks.htm",
      "phone": "(540) 943-5187",
      "address": "Milepost 5.8, Blue Ridge Parkway, Afton, VA 22920",
      "amenities": [
        "Free",
        "Scenic Views",
        "Photography",
        "Appalachian Trail"
      ],
      "featured": true
    },
    {
      "id": "10",
      "name": "Veritas Vineyards",
      "type": "Winery",
      "area": "Afton",
      "description": "Award-winning winery with stunning views of the Blue Ridge foothills. Offers tastings, tours, and a beautiful outdoor pavilion for events.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.veritaswines.com",
      "phone": "(540) 456-8000",
      "address": "151 Veritas Ln, Afton, VA 22920",
      "amenities": [
        "Pet-Friendly",
        "Outdoor Seating",
        "Tours Available",
        "Events"
      ],
      "featured": false
    },
    {
      "id": "11",
      "name": "Bold Rock Hard Cider",
      "type": "Cidery",
      "area": "Nellysford",
      "description": "Virginia's first cidery and taproom featuring handcrafted hard ciders made from fresh-pressed Virginia apples. Enjoy live music on the outdoor stage with mountain views, lawn games, and seasonal cider releases. The expansive grounds include a tasting room, outdoor pavilion, and food trucks.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.boldrock.com",
      "phone": "(434) 361-1030",
      "address": "1020 Rockfish Valley Hwy, Nellysford, VA 22958",
      "amenities": [
        "Pet-Friendly",
        "Outdoor Seating",
        "Live Music",
        "Kid-Friendly",
        "Tours Available",
        "Food Available"
      ],
      "featured": true
    },
    {
      "id": "12",
      "name": "Spy Rock",
      "type": "Hiking",
      "area": "Montebello",
      "description": "A moderately challenging 3.7-mile out-and-back trail leading to stunning 360-degree views from a rocky outcrop. Popular spot for sunrise and sunset photography. The trail passes through beautiful hardwood forest and offers glimpses of wildlife. Best visited in spring for wildflowers or fall for foliage.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.hikingupward.com/GWNF/SpyRock",
      "phone": "(540) 291-2188",
      "address": "Spy Rock Rd, Montebello, VA 24464",
      "amenities": [
        "Free",
        "Scenic Views",
        "Photography",
        "Kid-Friendly"
      ],
      "featured": false
    },
    {
      "id": "13",
      "name": "Pharsalia",
      "type": "Farm & Orchard",
      "area": "Lovingston",
      "description": "Working farm and educational center offering farm tours, workshops, and seasonal events. Visit the farm store for locally-raised grass-fed beef, pastured pork, and farm-fresh eggs. Popular destination for school field trips and agritourism. Beautiful historic property with walking trails and picnic areas.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.pharsalia.org",
      "phone": "(434) 277-5050",
      "address": "3735 Variety Mills Rd, Lovingston, VA 22949",
      "amenities": [
        "Kid-Friendly",
        "Tours Available",
        "Events",
        "Seasonal",
        "Free"
      ],
      "featured": false
    },
    {
      "id": "14",
      "name": "Swannanoa Palace",
      "type": "Attraction",
      "area": "Afton",
      "description": "Historic Italian Renaissance-style marble mansion built in 1912 atop Afton Mountain. Offers guided tours showcasing Tiffany stained glass windows, marble columns, and panoramic mountain views. Rich history includes its time as a country club and art school. Perfect for architecture enthusiasts and history buffs.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.swannanoavalley.org",
      "phone": "(434) 325-5539",
      "address": "3051 Swannanoa Dr, Afton, VA 22920",
      "amenities": [
        "Tours Available",
        "Photography",
        "Scenic Views",
        "Wheelchair Accessible"
      ],
      "featured": false
    },
    {
      "id": "15",
      "name": "Tye River Gap Trail",
      "type": "Hiking",
      "area": "Roseland",
      "description": "Moderate 2.4-mile trail following the historic Tye River through scenic forest. Features multiple creek crossings, swimming holes, and remnants of old railroad grade. Great for families and dogs. Less crowded than other area trails. Best visited in summer for swimming and wading opportunities.",
      "image1": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "image2": "https://www.adventurebook.com/connect/wp-content/uploads/sites/2/2021/10/Adventure-Ideas.jpg",
      "website": "https://www.nelsoncounty-va.gov/trails",
      "phone": "(434) 263-7015",
      "address": "Tye River Gap, VA-56, Roseland, VA 22967",
      "amenities": [
        "Free",
        "Pet-Friendly",
        "Kid-Friendly",
        "Scenic Views",
        "Seasonal"
      ],
      "featured": false
    }
  ],
  "filterOptions": {
    "types": [
      "Brewery",
      "Winery",
      "Cidery",
      "Hiking",
      "Outdoor",
      "Indoor Activity",
      "Attraction",
      "Farm & Orchard"
    ],
    "areas": [
      "Afton",
      "Wintergreen",
      "Lovingston",
      "Nellysford",
      "Montebello",
      "Arrington",
      "Roseland",
      "Seymour"
    ],
    "amenities": [
      "Kid-Friendly",
      "Pet-Friendly",
      "Wheelchair Accessible",
      "Free",
      "Seasonal",
      "Outdoor Seating",
      "Food Available",
      "Live Music",
      "Tours Available",
      "Events",
      "Photography",
      "Scenic Views",
      "Biking",
      "Appalachian Trail",
      "Pro Shop",
      "Lessons Available",
      "Cart Rental",
      "Lifeguards"
    ]
  }
};

// CMS Base URL for images and assets
const CMS_BASE_URL = 'https://nelson-county.framer.website';

// Google Sheets Configuration
// Using the published CSV URL from "Publish to web" feature
const GOOGLE_SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTjIYDylHAm_j9b4rwGOjfPe0aoPRA1rcqsZ8NZg8ugT97pkM83n87NrDVhx7NU63-whpia-hRscywD/pub?gid=0&single=true&output=csv';
// Google Apps Script URL for loading categories (same as admin panel)
const GOOGLE_APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzu1ukNVAwEPf_xWoerojDRDGWmsCYanERrc_yZsAq1XnUskOgq1usxY0JNx2c3EiKvGA/exec';

// Fetch adventure data from Google Sheets (or GitHub as fallback)
const GITHUB_JSON_URL = 'https://raw.githubusercontent.com/odd-even/nelsoncounty/main/data/config.json';

console.log(' Adventure Directory Loading...');
console.log(' Google Sheet URL:', GOOGLE_SHEET_CSV_URL);
console.log(' GitHub URL (fallback):', GITHUB_JSON_URL);
console.log(' Fallback data available:', fallbackData ? 'YES' : 'NO');
console.log(' Fallback listings count:', fallbackData?.listings?.length || 0);

// Check for pending breadcrumb filter IMMEDIATELY on page load (before data loads)
// This ensures we capture it even if postMessage from parent doesn't work
try {
    const storedFilter = sessionStorage.getItem('pendingBreadcrumbFilter');
    if (storedFilter) {
        const filterParams = JSON.parse(storedFilter);
        console.log('  Iframe found pending breadcrumb filter in sessionStorage on INITIAL LOAD:', filterParams);
        pendingBreadcrumbFilter = filterParams;
        // DON'T clear it yet - wait until filters are applied
    } else {
        console.log(' No pending breadcrumb filter found in sessionStorage on initial load');
    }
} catch (e) {
    console.warn(' Could not read pending breadcrumb filter from sessionStorage on initial load:', e);
    console.warn(' Error details:', e.message, e.stack);
}

// Log that we're ready to receive postMessage from parent
console.log(' Iframe ready to receive breadcrumb filter via postMessage');

// TEST FUNCTION: Run this in browser console to test filter system
// Example: window.testBreadcrumbFilter({category: 'outdoor'})
window.testBreadcrumbFilter = function(filterParams) {
    console.log(' TEST: Manually applying filter:', filterParams);
    if (data) {
        applyBreadcrumbFilter(filterParams);
        console.log(' TEST: Filter applied successfully');
    } else {
        console.log(' TEST: Data not loaded yet, storing filter');
        pendingBreadcrumbFilter = filterParams;
    }
};

// Global data variable
let data = null;
let currentTypeFilter = []; // Array to hold types for the selected category (only one category active at a time)
let currentCategoryFilter = null; // Track which category is currently active (null = "All Types")
let currentFeaturedOnly = false;
// Store URL parameters received via postMessage (for cross-origin iframe support)
let receivedUrlParams = {};
let lastProcessedParamsHash = null; // Track last processed parameters hash to prevent loops
let isProcessingParams = false; // Guard to prevent concurrent processing
let ignoreUrlParamsUntil = 0; // Timestamp - ignore URL params until this time (to prevent re-applying after clear)
let filtersExplicitlyCleared = false; // Flag: if true, ignore all URL parameters until user explicitly sets a filter
let pendingBreadcrumbFilter = null; // Store breadcrumb filter command if data isn't loaded yet

// Pagination variables for infinite scroll
let currentPage = 1;
const ITEMS_PER_PAGE = 50; // Load 50 cards at a time
let isLoadingMore = false;
let hasMoreItems = true;
let allFilteredListings = []; // Store all filtered listings for pagination

// Search debouncing
let searchDebounceTimeout = null;
const SEARCH_DEBOUNCE_DELAY = 200; // 200ms delay

// Helper function to parse CSV text into array of objects
function parseCSV(csvText) {
    // Parse CSV row by row, handling quoted fields that may contain newlines
    const rows = [];
    let currentRow = '';
    let inQuotes = false;
    
    // Process character by character to properly handle quoted fields
    for (let i = 0; i < csvText.length; i++) {
        const char = csvText[i];
        const nextChar = csvText[i + 1];
        
        if (char === '"') {
            if (inQuotes && nextChar === '"') {
                // Escaped quote (double quote)
                currentRow += '"';
                i++; // Skip next quote
            } else {
                // Toggle quote state
                inQuotes = !inQuotes;
                currentRow += char; // Keep quote for parsing
            }
        } else if (char === '\n' || char === '\r') {
            if (inQuotes) {
                // Newline inside quoted field - keep it as part of the field
                currentRow += char;
            } else {
                // End of row
                if (char === '\r' && nextChar === '\n') {
                    i++; // Skip \n after \r
                }
                if (currentRow.trim()) {
                    rows.push(currentRow.trim());
                }
                currentRow = '';
            }
        } else {
            currentRow += char;
        }
    }
    
    // Add final row if there's content
    if (currentRow.trim()) {
        rows.push(currentRow.trim());
    }
    
    // Filter out completely empty lines
    const filteredRows = rows.filter(row => row.trim());
    
    console.log(' Total rows found (including header):', filteredRows.length);
    
    if (filteredRows.length === 0) return [];
    
    // Parse header row
    const headers = parseCSVLine(filteredRows[0]).map(h => h.trim()).filter(h => h); // Remove empty headers
    console.log(' CSV Headers found:', headers);
    
    const dataRows = [];
    
    // Parse data rows
    for (let i = 1; i < filteredRows.length; i++) {
        const values = parseCSVLine(filteredRows[i]);
        // Check if row has any meaningful data (at least Title/Name field should exist)
        if (values.length === 0) {
            console.log(` Skipping row ${i + 1}: empty values array`);
            continue;
        }
        // Check if Title field (first column) exists and has content
        const titleField = values[0] ? values[0].trim() : '';
        if (!titleField) {
            console.log(` Skipping row ${i + 1}: empty title field`);
            continue;
        }
        
        const row = {};
        headers.forEach((header, index) => {
            row[header] = (values[index] || '').trim();
        });
        dataRows.push(row);
        
        // Log progress for debugging (first few and last few)
        if (i <= 5 || i > filteredRows.length - 5) {
            console.log(` Parsed row ${i + 1}/${filteredRows.length - 1}:`, titleField.substring(0, 50));
        }
    }
    
    console.log(' Total data rows parsed:', dataRows.length);
    console.log(' Expected data rows (excluding header):', filteredRows.length - 1);
    return dataRows;
}

// Helper function to parse a single CSV line (handles quoted fields with commas)
function parseCSVLine(line) {
    const values = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
                // Escaped quote
                current += '"';
                i++; // Skip next quote
            } else {
                // Toggle quote state
                inQuotes = !inQuotes;
                // Don't include the quote characters in the value
                continue;
            }
        } else if (char === ',' && !inQuotes) {
            // Field separator
            values.push(current);
            current = '';
        } else {
            current += char;
        }
    }
    
    // Add last field
    values.push(current);
    
    return values;
}

// Helper function to convert CSV row to listing object
function mapCSVRowToListing(row, index) {
    // Handle various column name variations
    const getField = (fieldName, altNames = []) => {
        const names = [fieldName, ...altNames];
        for (const name of names) {
            if (row[name]) return row[name].trim();
        }
        return '';
    };
    
    // Parse amenities (can be comma or semicolon separated)
    const amenitiesStr = getField('Amenities', ['amenities', 'Amenity']);
    const amenities = amenitiesStr 
        ? amenitiesStr.split(/[,;]/).map(a => a.trim()).filter(a => a)
        : [];
    
    // Parse featured (handle various formats)
    const featuredStr = getField('Featured', ['featured']);
    const featured = featuredStr === 'TRUE' || featuredStr === 'true' || featuredStr === '1' || featuredStr === 'Yes' || featuredStr === 'yes';
    
    // Handle category EXACTLY like type - simple and direct
    // Type: getField('Type', ['type']) || '' - no normalization, no transformation
    // Category: getField('Category', ['category']) || '' - same approach
    const categoryValue = getField('Category', ['category']);
    
    return {
        id: getField('ID', ['id', 'Id']) || String(index + 1),
        name: getField('Title', ['Name', 'name', 'title']) || 'Unnamed',
        slug: getField('Slug', ['slug']) || '',
        type: getField('Type', ['type']) || '', // Simple, direct - no normalization
        category: categoryValue || '', // Simple, direct - same as type (no normalization, no trim transformation)
        area: getField('Area', ['area']) || '',
        description: getField('Description', ['description', 'Desc', 'desc']) || '',
        detailedDescription: getField('Detailed Description', ['detailedDescription', 'detaileddescription', 'DetailedDescription', 'longdescription', 'longDescription', 'fulldescription', 'fullDescription']) || '',
        image1: getField('Photo', ['photo', 'Image', 'image', 'Image1', 'image1', 'Image 1']) || '',
        // Support multiple second-image header variants from the sheet
        image2: getField('Image2', ['image2', 'Image 2', 'Photo 2', 'photo2', 'Photo2', 'Second Photo', 'Secondary Photo']) || '',
        image3: getField('Image3', ['image3', 'Image 3', 'Photo 3', 'photo3', 'Photo3', 'Third Photo']) || '',
        // Image descriptions for SEO (alt text)
        image1Desc: getField('Image1Desc', ['image1Desc', 'image1 desc', 'Image 1 Desc', 'image description 1', 'Image Description 1']) || '',
        image2Desc: getField('Image2Desc', ['image2Desc', 'image2 desc', 'Image 2 Desc', 'image description 2', 'Image Description 2']) || '',
        image3Desc: getField('Image3Desc', ['image3Desc', 'image3 desc', 'Image 3 Desc', 'image description 3', 'Image Description 3']) || '',
        website: getField('External Website', ['Website', 'website', 'URL', 'url']) || '',
        phone: getField('Phone', ['phone']) || '',
        address: getField('Address', ['address']) || '',
        amenities: amenities,
        featured: featured
    };
}

// Helper function to extract filter options from listings
function extractFilterOptions(listings) {
    const types = [...new Set(listings.map(l => l.type).filter(Boolean))].sort();
    // Normalize areas: trim whitespace and filter out empty strings
    const areas = [...new Set(listings.map(l => l.area ? l.area.trim() : '').filter(Boolean))].sort();
    const amenities = [...new Set(listings.flatMap(l => l.amenities || []).filter(Boolean))].sort();
    
    return { types, areas, amenities };
}

// Load categories from localStorage (synced with admin.js)
function loadCategoriesFromStorage() {
    try {
        const stored = localStorage.getItem('nelsonCounty_categories');
        if (stored) {
            const parsed = JSON.parse(stored);
            if (parsed && typeof parsed === 'object') {
                console.log(' loadCategoriesFromStorage: Found', Object.keys(parsed).length, 'categories in localStorage');
                return parsed;
            }
        }
    } catch (e) {
        console.error('Error loading categories from storage:', e);
    }
    console.log(' loadCategoriesFromStorage: No categories found in localStorage');
    return null;
}

// Save categories to localStorage (synced with admin panel)
function saveCategoriesToStorage(categories) {
    try {
        localStorage.setItem('nelsonCounty_categories', JSON.stringify(categories));
        console.log(' saveCategoriesToStorage: Saved', Object.keys(categories).length, 'categories to localStorage');
        return true;
    } catch (e) {
        console.error('Error saving categories to storage:', e);
        return false;
    }
}

// Load icon mappings from localStorage or use defaults (sync with admin.js)
function loadIconMappingsFromStorage() {
    try {
        const stored = localStorage.getItem('nelsonCounty_iconMappings');
        if (stored) {
            const parsed = JSON.parse(stored);
            if (parsed && typeof parsed === 'object') {
                return parsed;
            }
        }
    } catch (e) {
        console.error('Error loading icon mappings from storage:', e);
    }
    return null;
}

// Default icon mappings - comprehensive list (merged from admin and front page)
const DEFAULT_ICON_MAPPINGS = {
    'Wine': 'icon-wine',
    'Winery': 'icon-wine',
    'Beer': 'icon-beer',
    'Brewery': 'icon-beer',
    'Spirits': 'icon-spirits',
    'Distillery': 'icon-spirits',
    'Cocktails': 'icon-cocktail',
    'Cocktail Bar': 'icon-cocktail',
    'Coffee': 'icon-coffee',
    'Coffee Shop': 'icon-coffee',
    'Caf': 'icon-coffee',
    'Tea': 'icon-tea',
    'Tea Room': 'icon-tea',
    'Restaurant': 'icon-restaurant',
    'Dining': 'icon-restaurant',
    'Bakery': 'icon-bakery',
    'Patisserie': 'icon-bakery',
    'Cheese': 'icon-cheese',
    'Fromagerie': 'icon-cheese',
    'Chocolate': 'icon-chocolate',
    'Chocolatier': 'icon-chocolate',
    'Museum': 'icon-museum',
    'Art': 'icon-art',
    'Art Gallery': 'icon-gallery',
    'Gallery': 'icon-gallery',
    'Hiking': 'icon-hiking',
    'Hike': 'icon-hiking',
    'Trail': 'icon-hiking',
    'Cycling': 'icon-cycling',
    'Bike': 'icon-cycling',
    'Activity': 'icon-activity',
    'Activities': 'icon-activity',
    'Outdoor': 'icon-outdoor',
    'Outdoor Activity': 'icon-outdoor',
    'Kayaking': 'icon-kayaking',
    'Kayak': 'icon-kayaking',
    'Spa': 'icon-spa',
    'Wellness': 'icon-wellness',
    'Health': 'icon-wellness',
    'Shopping': 'icon-shopping',
    'Shop': 'icon-shopping',
    'Market': 'icon-market',
    'Farmers Market': 'icon-market',
    'Concert': 'icon-concert',
    'Music': 'icon-concert',
    'Theater': 'icon-theater',
    'Theatre': 'icon-theater',
    'Cinema': 'icon-cinema',
    'Movie': 'icon-cinema',
    'Film': 'icon-cinema',
    'Festival': 'icon-festival',
    'Event': 'icon-festival',
    'Hotel': 'icon-lodging',
    'Lodging': 'icon-lodging',
    'B&B': 'icon-lodging',
    'BnB': 'icon-lodging',
    'Inn': 'icon-lodging',
    'Cabin': 'icon-lodging',
    'Camping': 'icon-lodging',
    'Transport': 'icon-transport',
    'Transportation': 'icon-transport',
    'Train': 'icon-train',
    'Railway': 'icon-train',
    'Boat': 'icon-boat',
    'Ferry': 'icon-boat',
    'Scenic': 'icon-scenic',
    'Viewpoint': 'icon-viewpoint',
    'Lookout': 'icon-viewpoint',
    'Park': 'icon-park',
    'Garden': 'icon-garden',
    'Beach': 'icon-beach',
    'History': 'icon-history',
    'Historical': 'icon-history',
    'Heritage': 'icon-history',
    'Culture': 'icon-culture',
    'Cultural': 'icon-culture',
    'Architecture': 'icon-architecture',
    'Building': 'icon-architecture',
    'Local': 'icon-local',
    'Tour': 'icon-tour',
    'Guided Tour': 'icon-tour',
    'Workshop': 'icon-workshop',
    'Class': 'icon-class',
    'Course': 'icon-class',
    'Food': 'icon-food',
    'Cuisine': 'icon-food',
    'Cidery': 'icon-cidery',
    'Cider': 'icon-cidery',
    'Indoor Activity': 'icon-indoor',
    'Indoor': 'icon-indoor',
    'Attraction': 'icon-attraction',
    'Attractions': 'icon-attraction',
    'Farm & Orchard': 'icon-farm',
    'Farm': 'icon-farm',
    'Orchard': 'icon-farm'
};

// Initialize icon mappings from storage or defaults
let ICON_MAPPINGS = loadIconMappingsFromStorage();
if (!ICON_MAPPINGS || Object.keys(ICON_MAPPINGS).length === 0) {
    ICON_MAPPINGS = DEFAULT_ICON_MAPPINGS;
    try {
        localStorage.setItem('nelsonCounty_iconMappings', JSON.stringify(ICON_MAPPINGS));
    } catch (e) {
        console.error('Error saving icon mappings to storage:', e);
    }
}

// Default category definitions - comprehensive list
const DEFAULT_TYPE_CATEGORIES = {
    'taste': {
        emoji: '',
        name: 'Taste',
        description: 'Food and drink experiences of all kinds.',
        icon: 'icon-food',
        types: ['Restaurant', 'Caf', 'Coffee Shop', 'Bakery', 'Brewery', 'Winery', 'Cidery', 'Distillery', 'Bar', 'Cocktail Bar', 'Food Market', 'Farmers Market', 'Food Tour', 'Cooking Class', 'Local Specialty', 'Street Food', 'Fine Dining']
    },
    'stay': {
        emoji: '',
        name: 'Stay',
        description: 'Places to sleep or retreat.',
        icon: 'icon-lodging',
        types: ['Lodging', 'Hotel', 'Resort', 'B&B', 'BnB', 'Inn', 'Cabin', 'Camping', 'Glamping', 'Hostel', 'Boutique Stay', 'Treehouse', 'Unique Stay', 'Airbnb', 'Lodge', 'Boat', 'Entire House', 'House Stay', 'House Rental', 'Vacation Rental', 'Rental', 'Apartment', 'Condo', 'Cottage', 'Villa', 'Home', 'Property']
    },
    'outdoor': {
        emoji: '',
        name: 'Outdoor',
        description: 'Nature, adventure, and recreation outside.',
        icon: 'icon-outdoor',
        types: ['Hiking', 'Outdoor', 'Outdoor Activity', 'Park', 'Beach', 'Trail', 'Camping', 'Climbing', 'Water Sports', 'Skiing', 'Scenic Drive', 'Viewpoint', 'Nature Walk', 'Biking', 'Cycling', 'Kayaking', 'Kayak', 'Farm & Orchard', 'National Park', 'Hike']
    },
    'culture': {
        emoji: '',
        name: 'Culture',
        description: 'Art, heritage, people, and traditions.',
        icon: 'icon-culture',
        types: ['Museum', 'Gallery', 'Art Gallery', 'Art', 'Architecture', 'Landmark', 'Historical Site', 'Festival', 'Cultural Tour', 'Craft', 'Music', 'Theater', 'Theatre', 'Dance', 'Attraction', 'Attractions', 'Local Craft', 'Cultural Site']
    },
    'experience': {
        emoji: '',
        name: 'Experience',
        description: 'Fun, entertainment, and activities.',
        icon: 'icon-activity',
        types: ['Activity', 'Activities', 'Indoor Activity', 'Event', 'Nightlife', 'Club', 'Amusement Park', 'Arcade', 'Live Show', 'Interactive Experience', 'Workshop', 'Tour', 'Entertainment']
    },
    'community': {
        emoji: '',
        name: 'Community',
        description: 'Local people, causes, and collectives.',
        icon: 'icon-local',
        types: ['Community', 'Community Project', 'Volunteer Work', 'Local Profile', 'Maker', 'Story', 'Collective']
    }
};

// Initialize TYPE_CATEGORIES from localStorage or defaults
let TYPE_CATEGORIES = loadCategoriesFromStorage() || DEFAULT_TYPE_CATEGORIES;

// Function to reload categories from localStorage (called when data loads or when storage changes)
function reloadCategoriesFromStorage() {
    const loadedCategories = loadCategoriesFromStorage();
    if (loadedCategories && Object.keys(loadedCategories).length > 0) {
        // Start with loaded categories from localStorage (preserves new categories added in admin)
        TYPE_CATEGORIES = JSON.parse(JSON.stringify(loadedCategories));
        // Ensure all default categories have icons (but don't overwrite new categories)
        for (const categoryKey in DEFAULT_TYPE_CATEGORIES) {
            if (TYPE_CATEGORIES[categoryKey]) {
                // If category exists but doesn't have an icon, set it from defaults
                if (!TYPE_CATEGORIES[categoryKey].icon && DEFAULT_TYPE_CATEGORIES[categoryKey].icon) {
                    TYPE_CATEGORIES[categoryKey].icon = DEFAULT_TYPE_CATEGORIES[categoryKey].icon;
                }
            } else {
                // If default category is missing, add it from defaults
                TYPE_CATEGORIES[categoryKey] = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES[categoryKey]));
            }
        }
        console.log(' Reloaded categories from localStorage. Total categories:', Object.keys(TYPE_CATEGORIES).length);
        console.log(' Categories:', Object.keys(TYPE_CATEGORIES).map(function(k) {
            return TYPE_CATEGORIES[k].name;
        }).join(', '));
        return true;
    } else {
        // If no categories in localStorage, keep current TYPE_CATEGORIES (might have defaults)
        console.log(' No categories found in localStorage, keeping current categories');
        return false;
    }
}

// Ensure we always have the default structure and icons
// But preserve custom categories from localStorage
if (!TYPE_CATEGORIES || Object.keys(TYPE_CATEGORIES).length === 0) {
    TYPE_CATEGORIES = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES));
    saveCategoriesToStorage(TYPE_CATEGORIES);
} else {
    // Ensure all default categories have icons (but preserve custom categories)
    let needsUpdate = false;
    for (const categoryKey in DEFAULT_TYPE_CATEGORIES) {
        if (TYPE_CATEGORIES[categoryKey]) {
            // If category exists but doesn't have an icon, set it from defaults
            if (!TYPE_CATEGORIES[categoryKey].icon && DEFAULT_TYPE_CATEGORIES[categoryKey].icon) {
                TYPE_CATEGORIES[categoryKey].icon = DEFAULT_TYPE_CATEGORIES[categoryKey].icon;
                needsUpdate = true;
            }
        } else {
            // If default category is missing, add it from defaults
            TYPE_CATEGORIES[categoryKey] = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES[categoryKey]));
            needsUpdate = true;
        }
    }
    // Only save if we added missing defaults, don't overwrite custom categories
    if (needsUpdate) {
        saveCategoriesToStorage(TYPE_CATEGORIES);
    }
}

// Log initial categories for debugging
console.log(' Initial TYPE_CATEGORIES on page load:', Object.keys(TYPE_CATEGORIES).length, 'categories');
console.log(' Category names:', Object.keys(TYPE_CATEGORIES).map(function(k) {
    return TYPE_CATEGORIES[k].name;
}).join(', '));

// Function to refresh categories and re-render filters
function refreshCategoriesAndFilters() {
    console.log(' Manually refreshing categories from localStorage...');
    if (reloadCategoriesFromStorage()) {
        // Re-render filter buttons if data is already loaded
        if (data && data.listings) {
            console.log(' Re-rendering filter buttons with updated categories...');
            renderTypeFilterButtons(data.listings, '.type-quick-filters');
            renderPreview(); // Re-render to reflect category changes
            return true;
        }
    }
    return false;
}

// Listen for storage changes to automatically update categories when changed in admin panel (works across tabs)
window.addEventListener('storage', function(e) {
    if (e.key === 'nelsonCounty_categories') {
        console.log(' Categories updated in localStorage (storage event), reloading...');
        refreshCategoriesAndFilters();
    }
});

// Also listen for custom events (for same-tab updates)
window.addEventListener('categoriesUpdated', function() {
    console.log(' Categories updated (custom event), reloading...');
    refreshCategoriesAndFilters();
});

// Poll for category changes every 2 seconds (fallback for same-tab updates)
let lastCategoryHash = null;
function checkForCategoryUpdates() {
    try {
        const stored = localStorage.getItem('nelsonCounty_categories');
        if (stored) {
            const currentHash = stored; // Simple hash - just the string itself
            if (lastCategoryHash !== null && currentHash !== lastCategoryHash) {
                console.log(' Categories changed in localStorage (polling detected), reloading...');
                refreshCategoriesAndFilters();
            }
            lastCategoryHash = currentHash;
        }
    } catch (e) {
        // Silently fail if localStorage is not accessible
    }
}

// Initialize hash on load
try {
    const stored = localStorage.getItem('nelsonCounty_categories');
    if (stored) {
        lastCategoryHash = stored;
    }
} catch (e) {
    // Silently fail
}

// Poll every 2 seconds for category updates (only if not in iframe to prevent loops)
if (window.self === window.top) {
    setInterval(checkForCategoryUpdates, 2000);
}

// Keyword mappings for automatic category assignment based on type content
// Used when exact type match is not found in category types array
const TYPE_KEYWORD_MAPPINGS = {
    'taste': ['coffee', 'cafe', 'caf', 'restaurant', 'food', 'dining', 'bakery', 'brewery', 'winery', 'cidery', 'distillery', 'bar', 'cocktail', 'market', 'food', 'cuisine', 'cooking', 'chef', 'meal', 'eat', 'drink', 'beverage', 'wine', 'beer', 'spirit', 'liquor', 'tea', 'espresso', 'latte', 'pizza', 'burger', 'sandwich', 'deli', 'grocery', 'farmers market', 'food tour', 'culinary'],
    'stay': ['hotel', 'lodging', 'resort', 'inn', 'bed and breakfast', 'bnb', 'cabin', 'camping', 'glamping', 'hostel', 'boutique stay', 'treehouse', 'unique stay', 'airbnb', 'lodge', 'accommodation', 'room', 'suite', 'retreat', 'getaway', 'entire house', 'house stay', 'house rental', 'vacation rental', 'rental', 'apartment', 'condo', 'cottage', 'villa', 'home', 'property', 'entire', 'house', 'vacation', 'short term rental', 'str', 'vrbo', 'booking', 'reservation'],
    'outdoor': ['hiking', 'hike', 'trail', 'park', 'beach', 'outdoor', 'nature', 'camping', 'climbing', 'water sports', 'skiing', 'snow', 'scenic', 'viewpoint', 'lookout', 'nature walk', 'biking', 'cycling', 'bike', 'kayaking', 'kayak', 'canoe', 'paddle', 'fishing', 'hunting', 'wildlife', 'forest', 'mountain', 'river', 'lake', 'national park', 'state park', 'garden', 'botanical'],
    'culture': ['museum', 'gallery', 'art', 'architecture', 'landmark', 'historical', 'history', 'heritage', 'festival', 'cultural', 'craft', 'music', 'theater', 'theatre', 'dance', 'performance', 'concert', 'show', 'exhibit', 'exhibition', 'monument', 'memorial', 'site', 'attraction', 'local craft', 'cultural site', 'tradition'],
    'experience': ['activity', 'activities', 'indoor activity', 'indoor', 'event', 'nightlife', 'club', 'amusement', 'arcade', 'live show', 'interactive', 'entertainment', 'fun', 'play', 'game', 'adventure', 'experience', 'tour', 'excursion'],
    'community': ['community', 'volunteer', 'local profile', 'maker', 'story', 'collective', 'group', 'organization', 'nonprofit', 'non-profit', 'charity', 'cause', 'initiative', 'foundation', 'association', 'society', 'network', 'community project', 'volunteer work']
};

// Map individual types to categories (case-insensitive)
// Uses exact match first, then keyword matching, then default fallback
// Also checks for category override on listing
function getCategoryForType(type, listing) {
    // If listing has a category override, use it
    if (listing && listing.category) {
        return listing.category;
    }
    
    if (!type) return null;
    const normalizedType = type.trim().toLowerCase();
    
    // Step 1: Try exact match (case-insensitive) against category types arrays
    for (const categoryKey in TYPE_CATEGORIES) {
        const category = TYPE_CATEGORIES[categoryKey];
        if (category.types.some(function(catType) {
            return catType.toLowerCase() === normalizedType;
        })) {
            return categoryKey;
        }
    }
    
    // Step 2: Try keyword-based matching if exact match failed
    // Check if the type contains keywords that suggest a category
    for (const categoryKey in TYPE_KEYWORD_MAPPINGS) {
        const keywords = TYPE_KEYWORD_MAPPINGS[categoryKey];
        if (keywords.some(function(keyword) {
            return normalizedType.indexOf(keyword.toLowerCase()) > -1;
        })) {
            return categoryKey;
        }
    }
    
        // Step 3: Default fallback for unmapped types
        return 'experience'; // Default to Experience
}

// Get all categories from TYPE_CATEGORIES
// Returns ALL categories regardless of whether they have matching types in the data
// Categories with matching types will have a count > 0
function getCategoriesByUsage(listings) {
    // Initialize counts for all categories (0 if no listings)
    const categoryCounts = {};
    const categoryTypesMap = {};
    
    // Initialize all categories from TYPE_CATEGORIES
    for (const categoryKey in TYPE_CATEGORIES) {
        categoryCounts[categoryKey] = 0;
        categoryTypesMap[categoryKey] = [];
    }
    
    // Track custom categories from Google Sheets that aren't in TYPE_CATEGORIES
    const customCategories = {};
    
    // Count listings for each category if we have listings
    // Use category from Google Sheets directly (no auto-assignment)
    if (listings && listings.length > 0) {
        listings.forEach(function(listing) {
            // Use category from Google Sheets if it exists (simple, direct - no auto-assignment)
            let listingCategory = null;
            if (listing.category && listing.category.trim() !== '') {
                // Use category directly from Google Sheets
                listingCategory = listing.category.trim();
            } else if (listing.type) {
                // Only use auto-assignment as fallback if no category in Google Sheets
                listingCategory = getCategoryForType(listing.type, listing);
            }
            
            if (listingCategory) {
                if (TYPE_CATEGORIES[listingCategory]) {
                    // Category exists in TYPE_CATEGORIES - count it
                    categoryCounts[listingCategory] = (categoryCounts[listingCategory] || 0) + 1;
                    // Track which types belong to this category
                    if (listing.type && categoryTypesMap[listingCategory].indexOf(listing.type) === -1) {
                        categoryTypesMap[listingCategory].push(listing.type);
                    }
                } else {
                    // Category exists in Google Sheets but not in TYPE_CATEGORIES
                    // Add it as a custom category so it shows in sidebar
                    if (!customCategories[listingCategory]) {
                    customCategories[listingCategory] = {
                        name: listingCategory,
                        emoji: '',
                        description: 'Custom category from Google Sheets',
                        count: 0,
                        types: []
                    };
                    }
                    customCategories[listingCategory].count++;
                    if (listing.type && customCategories[listingCategory].types.indexOf(listing.type) === -1) {
                        customCategories[listingCategory].types.push(listing.type);
                    }
                }
            }
        });
    }
    
    // Add custom categories to TYPE_CATEGORIES temporarily for display
    // (They'll be shown in sidebar but won't persist - admin should add them properly)
    // Check localStorage for emoji/name from admin before adding
    // IMPORTANT: Do case-insensitive lookup since Google Sheets stores keys as lowercase
    const categoriesFromStorage = loadCategoriesFromStorage();
    for (const customKey in customCategories) {
        const normalizedKey = customKey.trim();
        
        // Case-insensitive lookup in localStorage
        let matchingStorageKey = null;
        if (categoriesFromStorage) {
            // First try exact match
            if (categoriesFromStorage[normalizedKey]) {
                matchingStorageKey = normalizedKey;
            } else {
                // Try case-insensitive match
                for (const storageKey in categoriesFromStorage) {
                    if (storageKey.toLowerCase() === normalizedKey.toLowerCase()) {
                        matchingStorageKey = storageKey;
                        console.log(' Found case-insensitive match in getCategoriesByUsage:', storageKey, 'for', normalizedKey);
                        break;
                    }
                }
            }
        }
        
        if (!TYPE_CATEGORIES[normalizedKey]) {
            // Check if category exists in localStorage (from admin) for emoji/name - use case-insensitive match
            let categoryData = null;
            if (matchingStorageKey && categoriesFromStorage[matchingStorageKey]) {
                categoryData = categoriesFromStorage[matchingStorageKey];
                console.log(' Found custom category in localStorage (from admin):', matchingStorageKey, '', normalizedKey, 'with emoji:', categoryData.emoji, 'name:', categoryData.name);
            } else if (DEFAULT_TYPE_CATEGORIES[normalizedKey]) {
                categoryData = DEFAULT_TYPE_CATEGORIES[normalizedKey];
                console.log(' Found custom category in DEFAULT_TYPE_CATEGORIES:', normalizedKey, 'with emoji:', categoryData.emoji);
            }
            
            // Use data from admin/localStorage if available, otherwise use minimal entry
            TYPE_CATEGORIES[normalizedKey] = categoryData ? {
                name: categoryData.name || customCategories[customKey].name,
                emoji: categoryData.emoji || '',
                description: categoryData.description || customCategories[customKey].description,
                types: categoryData.types || [],
                icon: categoryData.icon || ''
            } : {
                name: customCategories[customKey].name,
                emoji: customCategories[customKey].emoji || '',
                description: customCategories[customKey].description,
                types: []
            };
            categoryCounts[normalizedKey] = customCategories[customKey].count;
            categoryTypesMap[normalizedKey] = customCategories[customKey].types;
            console.log(' Added custom category to TYPE_CATEGORIES:', normalizedKey, 'with', customCategories[customKey].count, 'listings, emoji:', TYPE_CATEGORIES[normalizedKey].emoji || '(none)', 'name:', TYPE_CATEGORIES[normalizedKey].name);
        } else {
            // Category already exists - sync emoji/name from localStorage/admin
            if (matchingStorageKey && categoriesFromStorage[matchingStorageKey]) {
                const storageCategory = categoriesFromStorage[matchingStorageKey];
                if (storageCategory.emoji) {
                    TYPE_CATEGORIES[normalizedKey].emoji = storageCategory.emoji;
                    console.log(' Synced emoji for existing custom category', normalizedKey, 'from admin:', storageCategory.emoji);
                }
                if (storageCategory.name) {
                    TYPE_CATEGORIES[normalizedKey].name = storageCategory.name;
                    console.log(' Synced name for existing custom category', normalizedKey, 'from admin:', storageCategory.name);
                }
                if (storageCategory.description) {
                    TYPE_CATEGORIES[normalizedKey].description = storageCategory.description;
                }
                if (storageCategory.icon) {
                    TYPE_CATEGORIES[normalizedKey].icon = storageCategory.icon;
                }
            }
        }
    }
    
    console.log(' TYPE_CATEGORIES after adding custom categories:', Object.keys(TYPE_CATEGORIES).length, 'categories');
    console.log(' Category keys:', Object.keys(TYPE_CATEGORIES));
    
    // Convert all categories to array
    const categoriesArray = Object.keys(TYPE_CATEGORIES).map(function(categoryKey) {
        return {
            key: categoryKey,
            category: TYPE_CATEGORIES[categoryKey],
            count: categoryCounts[categoryKey] || 0,
            types: categoryTypesMap[categoryKey] || [] // Types found in data for this category
        };
    });
    
    // Sort by count (descending), then by category name (ascending) for ties
    categoriesArray.sort(function(a, b) {
        if (b.count !== a.count) {
            return b.count - a.count; // Most used first
        }
        return a.key.localeCompare(b.key); // Alphabetical for ties
    });
    
    return categoriesArray;
}

// Dynamically render category filter buttons
// Shows ALL categories from TYPE_CATEGORIES regardless of whether they have matching types
function renderTypeFilterButtons(listings, containerSelector, maxVisible) {
    const container = document.querySelector(containerSelector);
    if (!container) {
        console.error(' Container not found:', containerSelector);
        return;
    }
    
    console.log(' renderTypeFilterButtons called with', listings ? listings.length : 0, 'listings');
    console.log(' TYPE_CATEGORIES before getCategoriesByUsage:', Object.keys(TYPE_CATEGORIES).length, 'categories');
    console.log(' TYPE_CATEGORIES keys:', Object.keys(TYPE_CATEGORIES));
    
    // Get ALL categories (will show all regardless of usage)
    const categoriesByUsage = getCategoriesByUsage(listings || []);
    
    console.log(' TYPE_CATEGORIES after getCategoriesByUsage:', Object.keys(TYPE_CATEGORIES).length, 'categories');
    console.log(' TYPE_CATEGORIES keys after:', Object.keys(TYPE_CATEGORIES));
    console.log(' categoriesByUsage length:', categoriesByUsage.length);
    
    if (categoriesByUsage.length === 0) {
        console.log(' No categories defined in TYPE_CATEGORIES');
        return;
    }
    
    console.log(' All categories (showing all regardless of usage):', categoriesByUsage.map(function(c) {
        return c.key + ': ' + toSentenceCase(c.key) + ' (' + c.count + ' listings)';
    }).join(', '));
    console.log(' TYPE_CATEGORIES keys:', Object.keys(TYPE_CATEGORIES));
    console.log(' TYPE_CATEGORIES count:', Object.keys(TYPE_CATEGORIES).length);
    
    // Show ALL categories - if maxVisible is not specified or is less than total, show all
    // Otherwise respect maxVisible but default to showing all
    const totalCategories = categoriesByUsage.length;
    const effectiveMaxVisible = maxVisible && maxVisible >= totalCategories ? maxVisible : totalCategories;
    
    const visibleCategories = categoriesByUsage.slice(0, effectiveMaxVisible);
    const hiddenCategories = categoriesByUsage.slice(effectiveMaxVisible);
    
    // Clear existing buttons (except "All Types" button)
    const existingButtons = container.querySelectorAll('.type-filter-btn[data-category]:not([data-category=""])');
    existingButtons.forEach(function(btn) {
        btn.remove();
    });
    
    // Remove existing expanded section and see-more button if they exist
    const existingExpanded = container.querySelector('.type-filters-expanded');
    const existingSeeMore = container.querySelector('.type-filter-see-more-btn');
    if (existingExpanded) existingExpanded.remove();
    if (existingSeeMore) existingSeeMore.remove();
    
    // Get the "All Types" button to insert after it
    const allTypeBtn = container.querySelector('.type-filter-btn[data-type=""]');
    
    // Render visible categories - insert them right after the "All Types" button
    visibleCategories.forEach(function(categoryInfo) {
        const btn = createCategoryFilterButton(categoryInfo.key, categoryInfo.category);
        attachCategoryFilterButtonHandler(btn, categoryInfo.key, categoryInfo.category);
        if (allTypeBtn) {
            // Insert after "All Types" button
            if (allTypeBtn.nextSibling) {
                container.insertBefore(btn, allTypeBtn.nextSibling);
            } else {
                // If "All Types" button is the last child, append after it
                container.appendChild(btn);
            }
        } else {
            // If no "All Types" button, just append
            container.appendChild(btn);
        }
    });
    
    // Render hidden categories in expandable section (if there are any)
    if (hiddenCategories.length > 0) {
        const expandedDiv = document.createElement('div');
        expandedDiv.className = 'type-filters-expanded';
        expandedDiv.style.display = 'none';
        
        hiddenCategories.forEach(function(categoryInfo) {
            const btn = createCategoryFilterButton(categoryInfo.key, categoryInfo.category);
            attachCategoryFilterButtonHandler(btn, categoryInfo.key, categoryInfo.category);
            expandedDiv.appendChild(btn);
        });
        
        container.appendChild(expandedDiv);
        
        // Add "See More" button
        const seeMoreBtn = document.createElement('button');
        seeMoreBtn.className = 'type-filter-see-more-btn';
        seeMoreBtn.onclick = function() {
            toggleTypeFilters();
        };
        seeMoreBtn.innerHTML = '<span class="see-more-text">See More</span><span class="see-less-text" style="display: none;">See Less</span>';
        container.appendChild(seeMoreBtn);
    }
}

// Create a category filter button element
// Convert text to sentence case (first letter capitalized, rest lowercase)
function toSentenceCase(text) {
    if (!text || typeof text !== 'string') return text;
    const trimmed = text.trim();
    if (trimmed.length === 0) return text;
    return trimmed.charAt(0).toUpperCase() + trimmed.slice(1).toLowerCase();
}

// SVG icon cache to avoid repeated fetches
const svgIconCache = {};

// Get SVG icon for category - loads from external files
async function getCategorySVGIcon(categoryKey) {
    const normalizedKey = categoryKey.toLowerCase();
    const iconFile = normalizedKey + '.svg';
    
    // Check cache first
    if (svgIconCache[normalizedKey]) {
        return svgIconCache[normalizedKey];
    }
    
    try {
        const response = await fetch(`icons/${iconFile}`);
        if (response.ok) {
            const svgContent = await response.text();
            svgIconCache[normalizedKey] = svgContent;
            return svgContent;
        }
    } catch (error) {
        console.warn(`Failed to load icon ${iconFile}:`, error);
    }
    
    // Fallback to default experience icon
    if (!svgIconCache['experience']) {
        try {
            const response = await fetch('icons/experience.svg');
            if (response.ok) {
                svgIconCache['experience'] = await response.text();
            }
        } catch (error) {
            console.warn('Failed to load default experience icon:', error);
        }
    }
    
    return svgIconCache['experience'] || '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"></svg>';
}

// Synchronous version that returns cached icon or placeholder
function getCategorySVGIconSync(categoryKey) {
    const normalizedKey = categoryKey.toLowerCase();
    return svgIconCache[normalizedKey] || '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"></svg>';
}

function createCategoryFilterButton(categoryKey, category) {
    const btn = document.createElement('button');
    btn.className = 'type-filter-btn category-filter-btn';
    btn.setAttribute('data-category', categoryKey);
    btn.setAttribute('data-type', ''); // Empty to indicate it's a category, not a specific type
    
    // Create button content with SVG icon and name
    const iconSpan = document.createElement('span');
    iconSpan.className = 'category-icon';
    
    // Use img tag to load SVG from file
    const img = document.createElement('img');
    img.src = `icons/${categoryKey.toLowerCase()}.svg`;
    img.alt = toSentenceCase(categoryKey);
    img.style.width = '24px';
    img.style.height = '24px';
    img.style.display = 'block';
    iconSpan.appendChild(img);
    
    const nameSpan = document.createElement('span');
    nameSpan.className = 'category-name';
    nameSpan.textContent = toSentenceCase(categoryKey);
    
    btn.appendChild(iconSpan);
    btn.appendChild(nameSpan);
    
    // Add title attribute with description for tooltip
    btn.title = category.description;
    
    return btn;
}

// Attach click handler to a category filter button
function attachCategoryFilterButtonHandler(btn, categoryKey, category) {
    // Add clicking class on mousedown for visual feedback
    btn.addEventListener('mousedown', function() {
        this.classList.add('clicking');
    });
    // Remove clicking class on mouseup or mouseleave
    btn.addEventListener('mouseup', function() {
        this.classList.remove('clicking');
    });
    btn.addEventListener('mouseleave', function() {
        this.classList.remove('clicking');
    });
    btn.addEventListener('click', function() {
        // Remove clicking class after click
        this.classList.remove('clicking');
        
        // Clear the "explicitly cleared" flag FIRST, before any filter logic
        // This allows new filters to be applied even if filters were previously cleared
        filtersExplicitlyCleared = false;
        try {
            sessionStorage.removeItem('filtersExplicitlyCleared');
        } catch (e) {
            // sessionStorage might not be available
        }
        
        const filterCategory = this.dataset.category;
        
        // Special handling for "All Types" button (empty data-type and no category)
        if (!filterCategory) {
            // Clear all selections and activate only "All Types"
            currentTypeFilter = [];
            currentCategoryFilter = null;
            // Remove category from URL
            updateUrlWithCategory(null);
            // Remove active state from all category buttons
            document.querySelectorAll('.type-filter-btn').forEach(function(b) {
                b.classList.remove('active');
            });
            // Activate "All Types" button
            this.classList.add('active');
        } else {
            // Only one category can be active at a time
            // Check if this category is already active (use filterCategory from dataset)
            if (currentCategoryFilter === filterCategory) {
                // If clicking the same category, deselect it and show "All Types"
                console.log(' Clearing category filter:', filterCategory);
                currentTypeFilter = [];
                currentCategoryFilter = null;
                // Remove category from URL
                updateUrlWithCategory(null);
                // Remove active state from all category buttons
                document.querySelectorAll('.type-filter-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                // Activate "All Types" button
                document.querySelectorAll('.type-filter-btn').forEach(function(b) {
                    if (b.dataset.type === '' && !b.dataset.category) {
                        b.classList.add('active');
                    }
                });
            } else {
                // User is explicitly setting a filter - clear the "explicitly cleared" flag FIRST
                filtersExplicitlyCleared = false;
                try {
                    sessionStorage.removeItem('filtersExplicitlyCleared');
                } catch (e) {
                    // sessionStorage might not be available
                }
                
                // Clear previous category selection and set new category
                const selectedCategory = TYPE_CATEGORIES[filterCategory];
                console.log(' Filtering by category:', filterCategory, selectedCategory ? selectedCategory.name : 'unknown');
                currentCategoryFilter = filterCategory;
                
                // Get all types that belong to this category (for legacy support, but filtering now uses currentCategoryFilter)
                const categoryTypes = selectedCategory ? (selectedCategory.types || []) : [];
                
                // Set filter to only this category's types (for legacy support)
                currentTypeFilter = categoryTypes.slice(); // Copy the array
                
                // Update URL to include category parameter
                updateUrlWithCategory(filterCategory);
                
                // Remove active state from all category buttons (including "All Types")
                document.querySelectorAll('.type-filter-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                
                // Activate only this category button
                this.classList.add('active');
            }
        }
        
        filterPreview();
    });
}

// Update URL with category parameter (or remove it)
function updateUrlWithCategory(categoryKey) {
    // If user is setting a filter, clear the "explicitly cleared" flag
    if (categoryKey) {
        filtersExplicitlyCleared = false;
        try {
            sessionStorage.removeItem('filtersExplicitlyCleared');
        } catch (e) {
            // sessionStorage might not be available
        }
    }
    try {
        const url = new URL(window.location.href);
        
        if (categoryKey) {
            // Add or update category parameter
            url.searchParams.set('category', categoryKey);
        } else {
            // Remove category parameter
            url.searchParams.delete('category');
        }
        
        // Update URL without reloading page
        window.history.pushState({ category: categoryKey }, '', url.toString());
    } catch (e) {
        // Fallback for older browsers or if URL constructor fails
        console.warn(' Could not update URL:', e);
    }
}

// Track last known parent URL to detect navigation
let lastParentUrl = '';
let lastParentSearch = '';
let lastGetUrlParamsRequest = 0;
let pendingGetUrlParamsRequest = false;
const GET_URL_PARAMS_THROTTLE = 5000; // Only request every 5 seconds max

// Extract URL parameters from referrer (works cross-origin for iframe embeds)
function extractParamsFromReferrer() {
    // Try to get parameters from parent window (same-origin only)
    try {
        if (window.parent && window.parent.location && window.parent !== window) {
            var parentUrl = window.parent.location.href;
            var parentSearch = window.parent.location.search;
            
            // Check if parent URL changed (navigation occurred)
            if (parentUrl !== lastParentUrl || parentSearch !== lastParentSearch) {
                lastParentUrl = parentUrl;
                lastParentSearch = parentSearch;
                console.log(' Parent URL changed to:', parentUrl);
                
                if (parentSearch && parentSearch.length > 1) {
                    var params = {};
                    var searchParams = new URLSearchParams(parentSearch);
                    for (var pair of searchParams.entries()) {
                        params[pair[0]] = pair[1];
                    }
                    console.log(' Extracted parameters from parent window:', params);
                    // Store in receivedUrlParams so getUrlParameter can use them
                    receivedUrlParams = Object.assign({}, receivedUrlParams, params);
                    
                    // If data is loaded, apply the parameters immediately
                    if (data) {
                        console.log(' Parent URL changed - re-applying URL parameters');
                        // Reset the processed hash to force re-processing
                        lastProcessedParamsHash = null;
                        handleUrlParameters();
                    }
                    return true;
                } else {
                    // Parent URL changed but no parameters - clear filters if we had params before
                    if (Object.keys(receivedUrlParams).length > 0) {
                        console.log(' Parent URL changed to clean URL - clearing received parameters');
                        receivedUrlParams = {};
                        lastProcessedParamsHash = null;
                    }
                }
            } else if (parentSearch && parentSearch.length > 1) {
                // Same URL but check params anyway (in case they were updated)
                var params = {};
                var searchParams = new URLSearchParams(parentSearch);
                for (var pair of searchParams.entries()) {
                    params[pair[0]] = pair[1];
                }
                receivedUrlParams = Object.assign({}, receivedUrlParams, params);
            }
            
            // If we can access parent URL directly (same-origin), don't need to request via postMessage
            return false;
        }
    } catch (e) {
        // Cross-origin restriction - can't access parent URL directly, try referrer
        try {
            var referrer = document.referrer;
            if (referrer && referrer.includes('?')) {
                var referrerUrl = new URL(referrer);
                var params = {};
                referrerUrl.searchParams.forEach(function(value, key) {
                    params[key] = value;
                });
                if (Object.keys(params).length > 0) {
                    console.log(' Extracted parameters from referrer:', params);
                    receivedUrlParams = Object.assign({}, receivedUrlParams, params);
                    return true;
                }
            }
            // No referrer params - don't log, just continue
        } catch (e2) {
            // Referrer check failed, continue to postMessage fallback
        }
    }
    
    // Only request via postMessage if:
    // 1. We haven't sent a request recently (throttle)
    // 2. We're not waiting for a response
    // 3. We're in cross-origin context (couldn't access parent URL)
    const now = Date.now();
    if (!pendingGetUrlParamsRequest && (now - lastGetUrlParamsRequest) > GET_URL_PARAMS_THROTTLE) {
        try {
            pendingGetUrlParamsRequest = true;
            lastGetUrlParamsRequest = now;
            window.parent.postMessage({ 
                type: 'getUrlParams',
                source: 'find-your-adventure'
            }, '*');
            
            // Reset pending flag after a delay (in case response never comes)
            setTimeout(function() {
                pendingGetUrlParamsRequest = false;
            }, 2000);
        } catch (e) {
            pendingGetUrlParamsRequest = false;
            console.log(' Could not send postMessage to parent:', e);
        }
    }
    
    return false;
}

// Poll parent URL periodically to detect navigation (for cross-origin cases)
let parentUrlPollInterval = null;
function startParentUrlPolling() {
    if (parentUrlPollInterval) return; // Already polling
    
    // Only poll if we're in cross-origin context (can't access parent.location)
    // Check once, then only poll if needed
    var needsPolling = false;
    try {
        if (window.parent && window.parent !== window) {
            // Try to access parent URL - if this fails, we're cross-origin
            var test = window.parent.location.href;
            // If we get here, we can access parent URL directly - no need to poll
        }
    } catch (e) {
        // Cross-origin - we need polling
        needsPolling = true;
    }
    
    if (needsPolling) {
        // Poll less frequently - every 5 seconds instead of every second
        parentUrlPollInterval = setInterval(function() {
            extractParamsFromReferrer();
        }, 5000); // Check every 5 seconds for parent URL changes
    }
}

// Start polling when page loads (only if needed)
if (typeof window !== 'undefined') {
    setTimeout(startParentUrlPolling, 2000); // Start after initial load
}

// Get URL parameters helper
// Checks: 1) postMessage params (cross-origin), 2) referrer URL (cross-origin), 3) parent window URL (same-origin), 4) current window URL
function getUrlParameter(name) {
    // First check if we received this parameter via postMessage (works cross-origin)
    if (receivedUrlParams && receivedUrlParams[name] !== undefined) {
        return receivedUrlParams[name];
    }
    
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    
    // Try parent window first (for iframe embeds - same origin only)
    var searchString = '';
    try {
        if (window.parent && window.parent.location && window.parent !== window) {
            searchString = window.parent.location.search;
        }
    } catch (e) {
        // Cross-origin restriction - can't access parent URL, try referrer instead
        var referrer = document.referrer;
        if (referrer && referrer.includes('?')) {
            try {
                var referrerUrl = new URL(referrer);
                searchString = referrerUrl.search;
                console.log(' Using referrer URL for parameters:', searchString);
            } catch (e2) {
                // Referrer not a valid URL
            }
        }
    }
    
    // If no parent or cross-origin, use current window
    if (!searchString) {
        searchString = location.search;
    }
    
    var results = regex.exec(searchString);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}

// Build URL with parameters preserved only if target contains /find-your-adventure
// If target doesn't contain /find-your-adventure, returns URL without parameters
function buildUrlWithConditionalParams(targetUrl) {
    if (!targetUrl) return targetUrl;
    
    // Check if target URL contains /find-your-adventure
    const containsFindYourAdventure = targetUrl.includes('/find-your-adventure');
    
    if (!containsFindYourAdventure) {
        // Remove any existing parameters from target URL
        try {
            const url = new URL(targetUrl);
            return url.origin + url.pathname + (url.hash || '');
        } catch (e) {
            // If URL parsing fails, try to remove query string manually
            const urlWithoutParams = targetUrl.split('?')[0].split('#')[0];
            const hash = targetUrl.includes('#') ? targetUrl.substring(targetUrl.indexOf('#')) : '';
            return urlWithoutParams + hash;
        }
    }
    
    // Target contains /find-your-adventure - preserve current URL parameters
    try {
        const targetUrlObj = new URL(targetUrl);
        const currentUrl = window.location.href;
        
        // Get current URL parameters
        let currentParams = {};
        try {
            // Try to get from receivedUrlParams first (cross-origin iframe support)
            if (receivedUrlParams && Object.keys(receivedUrlParams).length > 0) {
                currentParams = Object.assign({}, receivedUrlParams);
            } else {
                // Fall back to current window URL
                const currentUrlObj = new URL(currentUrl);
                currentUrlObj.searchParams.forEach((value, key) => {
                    currentParams[key] = value;
                });
            }
        } catch (e) {
            // If we can't get current params, just return target URL as-is
            return targetUrl;
        }
        
        // Merge current parameters into target URL
        Object.keys(currentParams).forEach(function(key) {
            if (currentParams[key]) {
                targetUrlObj.searchParams.set(key, currentParams[key]);
            }
        });
        
        return targetUrlObj.toString();
    } catch (e) {
        // If URL parsing fails, try manual approach
        const urlParts = targetUrl.split('?');
        const baseUrl = urlParts[0];
        const hash = baseUrl.includes('#') ? baseUrl.substring(baseUrl.indexOf('#')) : (targetUrl.includes('#') ? targetUrl.substring(targetUrl.indexOf('#')) : '');
        const cleanBaseUrl = baseUrl.split('#')[0];
        
        // Get current parameters
        let currentParams = {};
        try {
            if (receivedUrlParams && Object.keys(receivedUrlParams).length > 0) {
                currentParams = Object.assign({}, receivedUrlParams);
            } else if (window.location.search) {
                const searchParams = new URLSearchParams(window.location.search);
                searchParams.forEach((value, key) => {
                    currentParams[key] = value;
                });
            }
        } catch (e2) {
            return cleanBaseUrl + hash;
        }
        
        // Build query string
        const paramPairs = [];
        Object.keys(currentParams).forEach(function(key) {
            if (currentParams[key]) {
                paramPairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(currentParams[key]));
            }
        });
        
        const queryString = paramPairs.length > 0 ? '?' + paramPairs.join('&') : '';
        return cleanBaseUrl + queryString + hash;
    }
}

// Find listing by legacy WordPress URL
function findListingByLegacyUrl(url) {
    if (!data || !data.listings) return null;
    
    // Normalize URL (remove trailing slashes, protocol, www)
    var normalizeUrl = function(u) {
        return (u || '').toLowerCase()
            .replace(/^https?:\/\//, '')
            .replace(/^www\./, '')
            .replace(/\/$/, '')
            .trim();
    };
    
    var normalizedParam = normalizeUrl(url);
    
    // Try exact match first
    for (var i = 0; i < data.listings.length; i++) {
        var listing = data.listings[i];
        var legacyUrl = listing.legacyUrl || listing.wordpressUrl || '';
        if (legacyUrl && normalizeUrl(legacyUrl) === normalizedParam) {
            return listing;
        }
    }
    
    // Try partial match (for URLs with query strings or fragments)
    for (var i = 0; i < data.listings.length; i++) {
        var listing = data.listings[i];
        var legacyUrl = listing.legacyUrl || listing.wordpressUrl || '';
        var normalizedLegacy = normalizeUrl(legacyUrl);
        
        if (normalizedLegacy && (
            normalizedParam.includes(normalizedLegacy) || 
            normalizedLegacy.includes(normalizedParam) ||
            normalizedParam.indexOf(normalizedLegacy) === 0 ||
            normalizedLegacy.indexOf(normalizedParam) === 0
        )) {
            return listing;
        }
    }
    
    // Try matching by path segment (e.g., "/breweries/devils-backbone" matches)
    var pathSegments = normalizedParam.split('/').filter(function(s) { return s.length > 0; });
    if (pathSegments.length > 1) {
        var lastSegment = pathSegments[pathSegments.length - 1]; // Get last part of URL
        
        for (var i = 0; i < data.listings.length; i++) {
            var listing = data.listings[i];
            var legacyUrl = listing.legacyUrl || listing.wordpressUrl || '';
            var normalizedLegacy = normalizeUrl(legacyUrl);
            
            // Check if last segment of URL matches slug from listing name
            var listingSlug = listing.name
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
            
            if (lastSegment === listingSlug || normalizedLegacy.includes(lastSegment) || lastSegment.includes(listingSlug)) {
                return listing;
            }
        }
    }
    
    return null;
}

// Find listing by ID or slug
function findListingByIdentifier(idOrSlug) {
    if (!data || !data.listings) return null;
    
    // Try ID match
    for (var i = 0; i < data.listings.length; i++) {
        if (data.listings[i].id === idOrSlug || data.listings[i].id === String(idOrSlug)) {
            return data.listings[i];
        }
        
        // Try slug match (create slug from name)
        var nameSlug = data.listings[i].name
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        if (nameSlug === idOrSlug.toLowerCase()) {
            return data.listings[i];
        }
    }
    
    return null;
}

// Handle URL parameters to filter to specific listing or apply filters
function handleUrlParameters() {
    // Prevent concurrent processing
    if (isProcessingParams) {
        console.log(' Already processing URL parameters, skipping duplicate call...');
        return;
    }
    
    // Check if filters were explicitly cleared - if so, ignore URL parameters
    // BUT: if URL has parameters (user navigated to a filtered link), clear the flag and allow processing
    try {
        const clearedFlag = sessionStorage.getItem('filtersExplicitlyCleared');
        if (clearedFlag === 'true') {
            filtersExplicitlyCleared = true;
        }
    } catch (e) {
        // sessionStorage might not be available
    }
    
    // Check if URL has parameters - if so, user navigated to a filtered link, so clear the flag
    const hasUrlParams = Object.keys(receivedUrlParams).length > 0 || 
                        (window.location.search && window.location.search.length > 1);
    
    if (hasUrlParams && filtersExplicitlyCleared) {
        // URL has parameters - user navigated to a filtered link, so clear the flag
        console.log(' URL has parameters - clearing filtersExplicitlyCleared flag to allow processing');
        filtersExplicitlyCleared = false;
        try {
            sessionStorage.removeItem('filtersExplicitlyCleared');
        } catch (e) {
            // sessionStorage might not be available
        }
    }
    
    if (filtersExplicitlyCleared && !hasUrlParams) {
        // Filters were explicitly cleared AND no URL params - ignore all URL parameters
        console.log(' Filters were explicitly cleared - ignoring all URL parameters');
        return;
    }
    
    // Merge receivedUrlParams with actual iframe URL parameters (preserve iframe's own params)
    // This ensures parameters from the iframe URL aren't lost when postMessages arrive
    let paramsToUse = Object.assign({}, receivedUrlParams);
    
    // Also check the iframe's own URL parameters (in case we're in an iframe)
    try {
        const iframeUrl = new URL(window.location.href);
        iframeUrl.searchParams.forEach(function(value, key) {
            // Only add if not already in receivedUrlParams (receivedUrlParams takes priority)
            if (!(key in paramsToUse)) {
                paramsToUse[key] = value;
            }
        });
    } catch (e) {
        // If we can't parse URL, continue with receivedUrlParams only
    }
    
    // Create a hash of current parameters to check if they've changed
    const paramsHash = JSON.stringify(paramsToUse);
    if (lastProcessedParamsHash === paramsHash) {
        // Parameters haven't changed, skip processing
        console.log(' URL parameters unchanged, skipping processing');
        return;
    }
    
    // Only process if we're not already rendering (to prevent duplicate renders)
    if (isRendering) {
        console.log(' Render in progress, deferring URL parameter processing...');
        // Defer processing until render completes
        setTimeout(function() {
            handleUrlParameters();
        }, 500);
        return;
    }
    
    isProcessingParams = true;
    lastProcessedParamsHash = paramsHash;
    
    // Temporarily override receivedUrlParams for this processing
    const originalReceivedParams = receivedUrlParams;
    receivedUrlParams = paramsToUse;
    if (!data) return;
    
    var listing = null;
    var hasFilters = false;
    
    // Check for ?listing= parameter (can be ID, slug, or name) - takes priority
    var listingParam = getUrlParameter('listing');
    if (listingParam) {
        listing = findListingByIdentifier(listingParam);
        if (!listing) {
            // Try matching by name (partial)
            listing = data.listings.find(function(l) {
                return l.name.toLowerCase().includes(listingParam.toLowerCase()) ||
                       listingParam.toLowerCase().includes(l.name.toLowerCase());
            });
        }
    }
    
    // Check for ?legacy_url= or ?wordpress_url= parameter
    if (!listing) {
        var legacyUrlParam = getUrlParameter('legacy_url') || getUrlParameter('wordpress_url') || getUrlParameter('url');
        if (legacyUrlParam) {
            listing = findListingByLegacyUrl(legacyUrlParam);
        }
    }
    
    // If we found a listing, filter to it and auto-flip the card (skip other filters)
    if (listing) {
        console.log(' Found listing from URL parameter:', listing.name);
        filterByListingName(listing.name);
        return;
    }
    
    // Handle search parameter
    var searchParam = getUrlParameter('search');
    if (searchParam) {
        var searchInput = document.getElementById('previewSearchInput');
        var mobileSearchInput = document.getElementById('previewSearchInputMobile');
        if (searchInput) {
            searchInput.value = decodeURIComponent(searchParam);
            hasFilters = true;
            console.log(' Setting search from URL:', searchParam);
        }
        if (mobileSearchInput) {
            mobileSearchInput.value = decodeURIComponent(searchParam);
        }
    }
    
    // Handle category filter parameter (e.g., ?category=community)
    var categoryParam = getUrlParameter('category');
    if (categoryParam) {
        const categoryValue = decodeURIComponent(categoryParam).toLowerCase();
        // Check if this category exists in TYPE_CATEGORIES
        if (TYPE_CATEGORIES[categoryValue]) {
            currentCategoryFilter = categoryValue;
            // Get all types that belong to this category
            const selectedCategory = TYPE_CATEGORIES[categoryValue];
            const categoryTypes = selectedCategory ? (selectedCategory.types || []) : [];
            currentTypeFilter = categoryTypes.slice(); // Copy the array
            
            // Activate the category button
            document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
                btn.classList.remove('active');
                if (btn.dataset.category === categoryValue) {
                    btn.classList.add('active');
                }
            });
            
            hasFilters = true;
            console.log(' Setting category filter from URL:', categoryValue);
        } else {
            console.warn(' Category not found:', categoryValue);
        }
    }
    
    // Handle type filter parameter
    var typeParam = getUrlParameter('type');
    if (typeParam) {
        const typeValue = decodeURIComponent(typeParam);
        // Set type filter - do NOT set category filter, let type filter work independently
        currentTypeFilter = [typeValue];
        currentCategoryFilter = null; // Clear category filter so type filter works independently
        
        var typeFilter = document.getElementById('previewTypeFilter');
        var mobileTypeFilter = document.getElementById('mobileTypeFilter');
        if (typeFilter) {
            ensureDropdownOption(typeFilter, typeValue, typeValue);
            typeFilter.value = typeValue;
        }
        if (mobileTypeFilter) {
            ensureDropdownOption(mobileTypeFilter, typeValue, typeValue);
            mobileTypeFilter.value = typeValue;
        }
        // Update type filter buttons - deactivate all category buttons, keep "All Types" active
        document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
            btn.classList.remove('active');
            if (btn.dataset.type === '' && !btn.dataset.category) {
                btn.classList.add('active');
            }
        });
        hasFilters = true;
        console.log(' Setting type filter from URL:', typeParam);
    }
    
    // Handle area filter parameter
    var areaParam = getUrlParameter('area');
    if (areaParam) {
        var areaFilter = document.getElementById('previewAreaFilter');
        var mobileAreaFilter = document.getElementById('mobileAreaFilter');
        var areaValue = decodeURIComponent(areaParam);
        if (areaFilter) areaFilter.value = areaValue;
        if (mobileAreaFilter) mobileAreaFilter.value = areaValue;
        hasFilters = true;
        console.log(' Setting area filter from URL:', areaParam);
    }
    
    // Handle amenity filter parameter
    var amenityParam = getUrlParameter('amenity');
    if (amenityParam) {
        var amenityFilter = document.getElementById('previewAmenityFilter');
        var mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
        var amenityValue = decodeURIComponent(amenityParam);
        if (amenityFilter) amenityFilter.value = amenityValue;
        if (mobileAmenityFilter) mobileAmenityFilter.value = amenityValue;
        hasFilters = true;
        console.log(' Setting amenity filter from URL:', amenityParam);
    }
    
    // Handle featured filter parameter
    var featuredParam = getUrlParameter('featured');
    if (featuredParam && (featuredParam.toLowerCase() === 'true' || featuredParam === '1')) {
        currentFeaturedOnly = true;
        hasFilters = true;
        console.log(' Setting featured filter from URL');
    }
    
    // Apply all filters if any were set
    if (hasFilters) {
        filterPreview();
    }
    
    // Restore original receivedUrlParams (don't permanently modify it)
    receivedUrlParams = originalReceivedParams;
    
    // Reset processing flag after a short delay to allow filterPreview to complete
    setTimeout(function() {
        isProcessingParams = false;
    }, 100);
    
    // Reset processing flag after a delay
    setTimeout(function() {
        isProcessingParams = false;
    }, 300);
    
    // Notify parent that filters were applied (for aggressive URL clearing)
    try {
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'filtersApplied',
                source: 'find-your-adventure'
            }, '*');
            console.log(' Notified parent that filters were applied');
        }
    } catch (e) {
        // Cross-origin restriction - silently fail
    }
}

// Fetch data from GitHub and initialize
// Function to load data from Google Sheets
function loadDataFromGoogleSheets() {
    // Check if Google Sheet CSV URL is configured
    if (!GOOGLE_SHEET_CSV_URL || GOOGLE_SHEET_CSV_URL.includes('YOUR_SHEET_ID')) {
        console.log(' Google Sheet URL not configured, trying GitHub...');
        return loadDataFromGitHub();
    }
    
    console.log(' Attempting to load from Google Sheets...');
    const cacheBustUrl = GOOGLE_SHEET_CSV_URL + (GOOGLE_SHEET_CSV_URL.includes('?') ? '&' : '?') + 't=' + Date.now();
    console.log(' URL:', cacheBustUrl);

    // For file:// origins, use a proxy immediately (CORS doesn't work with file://)
    // Check if we're running from file:// protocol
    const isFileProtocol = window.location.protocol === 'file:';
    
    let fetchPromise;
    
    if (isFileProtocol) {
        console.log(' Detected file:// protocol - using CORS proxy');
        // Try multiple CORS proxy options
        function buildProxyUrl(base, url) {
            if (base.includes('corsproxy.io')) {
                return base + encodeURIComponent(url);
            } else if (base.includes('allorigins')) {
                return base + encodeURIComponent(url);
            } else {
                return base + encodeURIComponent(url);
            }
        }
        
        const proxies = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.herokuapp.com/'
        ];
        
        let proxyIndex = 0;
        function tryProxy() {
            const proxyUrl = buildProxyUrl(proxies[proxyIndex], cacheBustUrl);
            console.log(' Trying proxy', proxyIndex + 1, ':', proxyUrl.substring(0, 100) + '...');
            
            return fetch(proxyUrl, { 
                method: 'GET', 
                mode: 'cors', 
                cache: 'no-cache', 
                credentials: 'omit' 
            })
            .catch(function(err) {
                console.warn(' Proxy', proxyIndex + 1, 'failed:', err && err.message);
                proxyIndex++;
                if (proxyIndex < proxies.length) {
                    return tryProxy();
                } else {
                    throw new Error('All CORS proxies failed. Try running from a web server instead of file://');
                }
            });
        }
        
        fetchPromise = tryProxy();
    } else {
        // For http/https, try direct first, fallback to proxy if needed
        fetchPromise = fetch(cacheBustUrl, { 
            method: 'GET', 
            mode: 'cors', 
            cache: 'no-cache', 
            credentials: 'omit' 
        })
        .catch(function(err) {
            console.warn(' Direct CSV fetch failed, retrying via CORS proxy:', err && err.message);
            const proxied = 'https://corsproxy.io/?' + encodeURIComponent(cacheBustUrl);
            console.log(' Proxy URL:', proxied);
            return fetch(proxied, { 
                method: 'GET', 
                mode: 'cors', 
                cache: 'no-cache', 
                credentials: 'omit' 
            });
        });
    }
    
    return fetchPromise
        .then(response => {
            console.log(' Response status:', response.status, response.statusText);
            console.log(' Response headers:', response.headers.get('content-type'));
            if (!response.ok) {
                throw new Error(`Google Sheets fetch failed: ${response.status} ${response.statusText}`);
            }
            console.log(' Successfully fetched CSV from Google Sheets');
            return response.text();
        })
        .then(csvText => {
            console.log(' CSV Text received, length:', csvText.length);
            console.log(' First 500 chars:', csvText.substring(0, 500));
            
            // Parse CSV
            const rows = parseCSV(csvText);
            console.log(' Parsed CSV rows:', rows.length);
            
            if (rows.length === 0) {
                throw new Error('No data rows found in Google Sheet');
            }
            
            // Log first row to verify structure
            if (rows.length > 0) {
                console.log(' First row keys:', Object.keys(rows[0]));
                console.log(' First row sample:', JSON.stringify(rows[0]).substring(0, 200));
            }
            
            // Convert CSV rows to listings
            const listings = rows.map((row, index) => mapCSVRowToListing(row, index));
            console.log(' Converted to listings:', listings.length);
            console.log(' Listing names (first 5):', listings.slice(0, 5).map(l => l.name || 'NO NAME'));
            console.log(' Listing names (last 5):', listings.slice(-5).map(l => l.name || 'NO NAME'));
            console.log(' Listing count breakdown:', {
                total: listings.length,
                withNames: listings.filter(l => l.name && l.name.trim()).length,
                withoutNames: listings.filter(l => !l.name || !l.name.trim()).length,
                withCategories: listings.filter(l => l.category && l.category.trim()).length,
                categoryExamples: listings.filter(l => l.category && l.category.trim()).slice(0, 5).map(l => ({ name: l.name, category: l.category }))
            });
            
            // Log category usage
            const categoriesInData = [...new Set(listings.map(l => l.category).filter(Boolean))];
            if (categoriesInData.length > 0) {
                console.log(' Categories found in Google Sheets data:', categoriesInData);
            } else {
                console.log(' No categories found in Google Sheets data - will use auto-assignment');
            }
            
            if (listings.length > 0) {
                console.log(' First listing:', JSON.stringify(listings[0]).substring(0, 300));
                console.log(' Last listing:', JSON.stringify(listings[listings.length - 1]).substring(0, 300));
            }
            
            // Extract filter options
            const filterOptions = extractFilterOptions(listings);
            console.log(' Filter options - Types:', filterOptions.types.length, 'Areas:', filterOptions.areas.length, 'Amenities:', filterOptions.amenities.length);
            
            return {
                listings: listings,
                filterOptions: filterOptions
            };
        })
        .catch(error => {
            console.error(' Google Sheets fetch failed:', error);
            console.error(' Error message:', error.message);
            console.error(' Error stack:', error.stack);
            console.log(' Falling back to GitHub...');
            return loadDataFromGitHub();
        });
}

// Function to load categories from Google Sheets Apps Script
function loadCategoriesFromGoogleSheets() {
    if (!GOOGLE_APPS_SCRIPT_URL || GOOGLE_APPS_SCRIPT_URL.includes('YOUR_SCRIPT_ID')) {
        console.log(' Google Apps Script URL not configured, using defaults');
        return Promise.resolve({});
    }
    
    console.log(' Loading categories from Google Sheets...');
    const url = GOOGLE_APPS_SCRIPT_URL + '?t=' + Date.now();
    
    return fetch(url, {
        method: 'GET',
        mode: 'cors',
        cache: 'no-cache',
        credentials: 'omit'
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Google Sheets fetch failed: ' + response.status + ' ' + response.statusText);
        }
        return response.json();
    })
    .then(function(result) {
        if (result.success && result.categories) {
            console.log(' Categories loaded from Google Sheets:', Object.keys(result.categories).length, 'categories');
            return result.categories;
        } else {
            console.log(' No categories in response, using defaults');
            return {};
        }
    })
    .catch(function(error) {
        console.warn(' Could not load categories from Google Sheets:', error);
        return {};
    });
}

// Function to load data from GitHub (fallback)
function loadDataFromGitHub() {
    console.log(' Attempting to load from GitHub...');
    return fetch(GITHUB_JSON_URL)
        .then(response => {
            console.log(' GitHub Response Status:', response.status, response.statusText);
            if (!response.ok) {
                console.warn(' Could not fetch from GitHub (status ' + response.status + '), using embedded fallback data');
                return fallbackData;
            }
            console.log(' Successfully fetched from GitHub');
            // Ensure UTF-8 encoding is handled properly
            return response.text().then(text => {
                try {
                    return JSON.parse(text);
                } catch (e) {
                    console.error('Error parsing JSON:', e);
                    // Try to fix common encoding issues
                    const fixedText = text
                        .replace(/\u00C3\u00A9/g, '\u00E9') // Fix  if double-encoded
                        .replace(/\u00C3\u00A1/g, '\u00E1') // Fix 
                        .replace(/\u00C3\u00AD/g, '\u00ED') // Fix 
                        .replace(/\u00C3\u00B3/g, '\u00F3') // Fix 
                        .replace(/\u00C3\u00BA/g, '\u00FA') // Fix 
                        .replace(/\u00C3\u00B1/g, '\u00F1') // Fix 
                        .replace(/\u00C3\u00BC/g, '\u00FC') // Fix 
                        .replace(/\u00C3\u00B6/g, '\u00F6'); // Fix 
                    return JSON.parse(fixedText);
                }
            });
        })
        .catch(error => {
            console.warn(' GitHub fetch failed:', error);
            console.log(' Using embedded fallback data');
            return fallbackData;
        });
}

// Load data: Try Google Sheets first, then GitHub, then fallback
loadDataFromGoogleSheets()
    .then(loadedData => {
        if (!loadedData || !loadedData.listings) {
            throw new Error('Loaded data is empty or missing listings');
        }
        
        data = loadedData;
        console.log(' Adventure data loaded successfully');
        console.log(' Source: Google Sheets');
        console.log(' Listings count:', data.listings.length);
        console.log(' First listing name:', data.listings[0]?.name || 'N/A');
        console.log(' Last listing name:', data.listings[data.listings.length - 1]?.name || 'N/A');
        
        // Guard to prevent double rendering
        let hasRendered = false;
        let categoriesLoaded = false;
        
        // Process categories and render (called after categories load or immediately with defaults)
        function processCategoriesAndRender(forceRender = false) {
            // Prevent double rendering unless forced (e.g., for filter updates)
            if (hasRendered && !forceRender) {
                console.log(' Skipping duplicate render - already rendered');
                return;
            }
            
            // FIRST: Check for pending breadcrumb filter from sessionStorage (before anything else)
            // This handles cases where postMessage from parent doesn't work
            try {
                const storedFilter = sessionStorage.getItem('pendingBreadcrumbFilter');
                if (storedFilter) {
                    const filterParams = JSON.parse(storedFilter);
                    console.log('  Iframe found pending breadcrumb filter in sessionStorage on load:', filterParams);
                    pendingBreadcrumbFilter = filterParams;
                    // Clear it so it doesn't reapply on next load
                    sessionStorage.removeItem('pendingBreadcrumbFilter');
                }
            } catch (e) {
                // sessionStorage might not be available or parse failed
                console.warn(' Could not read pending breadcrumb filter from sessionStorage:', e);
            }
            
            // Extract categories from Google Sheets data and ensure they're in TYPE_CATEGORIES
            // This ensures custom categories from Google Sheets show up even if not in Categories sheet yet
            const categoriesFromData = [...new Set(data.listings.map(l => l.category).filter(Boolean))];
            console.log(' Categories found in listings data:', categoriesFromData);
        
            // Add any missing categories from listings data (in case Categories sheet is not up to date)
            // IMPORTANT: Only add if category doesn't exist - don't overwrite categories loaded from Google Sheets
            // Use defaults if available, otherwise create minimal entry
            let addedCustomCategories = false;
            categoriesFromData.forEach(function(categoryKey) {
                if (!categoryKey || !categoryKey.trim()) return;
                
                const normalizedKey = categoryKey.trim().toLowerCase();
                
                // Only add if category doesn't exist - preserve emojis from Google Sheets
                if (!TYPE_CATEGORIES[normalizedKey]) {
                    // Check defaults first
                    let categoryData = null;
                    if (DEFAULT_TYPE_CATEGORIES[normalizedKey]) {
                        categoryData = DEFAULT_TYPE_CATEGORIES[normalizedKey];
                        console.log(' Found category in DEFAULT_TYPE_CATEGORIES:', normalizedKey, 'with emoji:', categoryData.emoji);
                    }
                    
                    // Use defaults if available, otherwise create minimal entry
                    TYPE_CATEGORIES[normalizedKey] = categoryData ? {
                        name: categoryData.name || normalizedKey,
                        emoji: categoryData.emoji || '',
                        description: categoryData.description || 'Custom category from Google Sheets',
                        types: categoryData.types || [],
                        icon: categoryData.icon || ''
                    } : {
                        name: normalizedKey,
                        emoji: '',
                        description: 'Custom category from Google Sheets',
                        types: []
                    };
                    addedCustomCategories = true;
                    console.log(' Added missing category from listings:', normalizedKey, 'with emoji:', TYPE_CATEGORIES[normalizedKey].emoji || '(none)', 'name:', TYPE_CATEGORIES[normalizedKey].name);
                } else {
                    // Category already exists - log its emoji to verify it's correct
                    console.log(' Category already exists:', normalizedKey, 'emoji:', TYPE_CATEGORIES[normalizedKey].emoji || '(none)', 'name:', TYPE_CATEGORIES[normalizedKey].name);
                }
            });
            
            if (addedCustomCategories) {
                console.log(' TYPE_CATEGORIES after adding missing categories:', Object.keys(TYPE_CATEGORIES).length, 'categories');
                console.log(' Category keys:', Object.keys(TYPE_CATEGORIES));
            }
        
            // Ensure filterOptions exist (if loaded from CSV, they're already there)
            if (!data.filterOptions && data.listings) {
                data.filterOptions = extractFilterOptions(data.listings);
            }
            
            // Verify we're NOT using fallback data
            if (data.listings.length === 20 && data.listings[0]?.name === 'Devil\'s Backbone Brewing Company') {
                console.warn(' WARNING: This looks like fallback data! Something went wrong with Google Sheets fetch.');
            }
            
            // Update head meta from fresh data
            updateHeadFromData(data);
            
            // Force clear any cached/stale grid content
            const grid = document.getElementById('previewGrid');
            if (grid) {
                grid.innerHTML = '';
                console.log(' Cleared previewGrid innerHTML');
            }
            
            console.log(' About to render', data.listings.length, 'listings');
            console.log(' TYPE_CATEGORIES before rendering:', Object.keys(TYPE_CATEGORIES).length, 'categories');
            console.log(' Category keys:', Object.keys(TYPE_CATEGORIES));
            console.log(' Category names:', Object.keys(TYPE_CATEGORIES).map(function(k) {
                return TYPE_CATEGORIES[k].name;
            }).join(', '));
            
            // Check for pending breadcrumb filter from sessionStorage (backup method)
            // This handles cases where postMessage from parent doesn't work
            try {
                const storedFilter = sessionStorage.getItem('pendingBreadcrumbFilter');
                if (storedFilter && !pendingBreadcrumbFilter) {
                    const filterParams = JSON.parse(storedFilter);
                    console.log(' Iframe found pending breadcrumb filter in sessionStorage:', filterParams);
                    pendingBreadcrumbFilter = filterParams;
                    // Clear it so it doesn't reapply on next load
                    sessionStorage.removeItem('pendingBreadcrumbFilter');
                }
            } catch (e) {
                // sessionStorage might not be available or parse failed
                console.warn(' Could not read pending breadcrumb filter from sessionStorage:', e);
            }
            
            // Check for pending breadcrumb filter and apply it BEFORE rendering buttons
            // (This can be set by postMessage from breadcrumb component OR sessionStorage)
            if (pendingBreadcrumbFilter) {
                console.log(' Applying pending breadcrumb filter after data load:', pendingBreadcrumbFilter);
                applyBreadcrumbFilter(pendingBreadcrumbFilter);
                pendingBreadcrumbFilter = null; // Clear after applying
            }
            
            // Render type filter buttons dynamically based on usage
            renderTypeFilterButtons(data.listings, '.type-quick-filters'); // Show all categories
            
            // Populate mobile category dropdown
            populateMobileCategoryFilter();
            
            // Restore active state on filter buttons after re-rendering
            // This preserves the active highlight when buttons are recreated after categories load
            if (currentCategoryFilter) {
                document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
                    btn.classList.remove('active');
                    if (btn.dataset.category === currentCategoryFilter) {
                        btn.classList.add('active');
                    }
                });
            } else if (currentTypeFilter.length > 0) {
                // If type filter is active, activate the appropriate buttons
                document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
                    btn.classList.remove('active');
                    if (btn.dataset.type && currentTypeFilter.includes(btn.dataset.type)) {
                        btn.classList.add('active');
                    } else if (!btn.dataset.type && !btn.dataset.category && currentTypeFilter.length > 0) {
                        // "All Types" button should be active if type filter is set
                        btn.classList.add('active');
                    }
                });
            }
            
            // Check if there are active filters before rendering
            // If filters are active, use filterPreview() to preserve them
            // Otherwise, use renderPreview() to show all listings
            const searchTerm = document.getElementById('previewSearch') ? document.getElementById('previewSearch').value.trim() : '';
            const areaFilter = document.getElementById('previewAreaFilter');
            const mobileAreaFilter = document.getElementById('mobileAreaFilter');
            const selectedArea = ((areaFilter ? areaFilter.value : '') || (mobileAreaFilter ? mobileAreaFilter.value : '')).trim();
            const amenityFilter = document.getElementById('previewAmenityFilter');
            const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
            const selectedAmenity = ((amenityFilter ? amenityFilter.value : '') || (mobileAmenityFilter ? mobileAmenityFilter.value : '')).trim();
            const hasActiveFilters = searchTerm || currentCategoryFilter || currentTypeFilter.length > 0 || selectedArea || selectedAmenity || currentFeaturedOnly;
            
            if (hasActiveFilters) {
                // Preserve active filters by using filterPreview() instead of renderPreview()
                console.log(' Active filters detected, preserving filter state:', {
                    category: currentCategoryFilter,
                    type: currentTypeFilter,
                    area: selectedArea,
                    amenity: selectedAmenity,
                    featured: currentFeaturedOnly,
                    search: searchTerm
                });
                filterPreview(); // This will apply filters and render
            } else {
                renderPreview(); // Sorting is now handled inside renderPreview
            }
            
            // Mark as rendered to prevent duplicate renders
            hasRendered = true;
            
            // Extract parameters from referrer (for cross-origin iframe support)
            extractParamsFromReferrer();
        }
        
        // Load categories from Google Sheets (public source, same for everyone)
        // This replaces localStorage which is browser-specific
        // Load categories in parallel, but don't let it block the main data loading
        loadCategoriesFromGoogleSheets()
            .then(function(categoriesFromSheets) {
                console.log(' Categories loaded from Google Sheets:', Object.keys(categoriesFromSheets || {}).length, 'categories');
                
                // Merge categories from Google Sheets into TYPE_CATEGORIES
                // This preserves any categories already added from listings, but updates with Google Sheets data
                if (categoriesFromSheets && Object.keys(categoriesFromSheets).length > 0) {
                    // Merge: Google Sheets categories take priority (they have the latest emojis)
                    for (const key in categoriesFromSheets) {
                        TYPE_CATEGORIES[key] = categoriesFromSheets[key];
                        console.log(' Loaded category from Google Sheets:', key, 'emoji:', categoriesFromSheets[key].emoji || '(none)', 'name:', categoriesFromSheets[key].name);
                    }
                    console.log(' Loaded', Object.keys(categoriesFromSheets).length, 'categories from Google Sheets');
                } else {
                    // Fallback to defaults if no categories in Google Sheets
                    console.log(' No categories found in Google Sheets, using defaults');
                    // Only set defaults if TYPE_CATEGORIES is empty
                    if (!TYPE_CATEGORIES || Object.keys(TYPE_CATEGORIES).length === 0) {
                        TYPE_CATEGORIES = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES));
                    }
                }
                
                // Mark categories as loaded
                categoriesLoaded = true;
                
                // Only re-render if we haven't rendered yet (categories loaded before initial render)
                // Otherwise, just update the categories without full re-render
                if (!hasRendered) {
                    // Process categories and render with updated categories
                    processCategoriesAndRender();
                } else {
                    // Categories loaded after initial render - just update filter buttons without full re-render
                    console.log(' Categories loaded after initial render - updating filter buttons only');
                    renderTypeFilterButtons(data.listings, '.type-quick-filters');
                    
                    // Restore active state on filter buttons
                    if (currentCategoryFilter) {
                        document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
                            btn.classList.remove('active');
                            if (btn.dataset.category === currentCategoryFilter) {
                                btn.classList.add('active');
                            }
                        });
                    }
                }
                
                // After categories load, check URL parameters again to ensure filters are applied
                // This is important because handleUrlParameters needs categories to be loaded
                if (!hasRendered) {
                    setTimeout(function() {
                        extractParamsFromReferrer();
                        handleUrlParameters();
                    }, 300); // Short delay after categories load
                }
            })
            .catch(function(error) {
                console.error(' Error loading categories from Google Sheets:', error);
                // Fallback to defaults
                TYPE_CATEGORIES = JSON.parse(JSON.stringify(DEFAULT_TYPE_CATEGORIES));
                console.log(' Using default categories due to error');
                
                // Mark categories as loaded (even if from fallback)
                categoriesLoaded = true;
                
                // Only render if we haven't rendered yet
                if (!hasRendered) {
                    processCategoriesAndRender();
                    
                    // After categories load (even from fallback), check URL parameters again
                    setTimeout(function() {
                        extractParamsFromReferrer();
                        handleUrlParameters();
                    }, 300);
                }
            });
        
        // Start processing immediately with defaults (categories will update when they load)
        // This will render once, and when categories load, they'll just update the buttons
        processCategoriesAndRender();
        
        // Set up debounced search input handlers
        setTimeout(function() {
            setupSearchInputs();
        }, 100); // Small delay to ensure inputs exist
        
        // Handle URL parameters after data is loaded and rendered
        // Use a delay to allow postMessage response from parent
        // Extract referrer params first, then handle URL parameters
        setTimeout(function() {
            // Re-check referrer in case it wasn't available immediately
            extractParamsFromReferrer();
            // Call handleUrlParameters - deduplication will prevent duplicate processing
            handleUrlParameters();
        }, 800); // Initial delay - long enough for postMessage
        
        // Also check again after a longer delay to catch any late postMessages
        // This ensures URL params are applied even if postMessage is slow
        setTimeout(function() {
            extractParamsFromReferrer();
            handleUrlParameters();
        }, 1500); // Second check - ensures params are applied even if first check was too early
    })
    .catch(error => {
        console.error(' Error loading data:', error);
        console.error(' Error details:', error.message, error.stack);
        console.warn(' Falling back to embedded data');
        data = fallbackData;
        
        // Reload categories from localStorage to get latest changes from admin panel
        reloadCategoriesFromStorage();
        
        // Ensure filterOptions exist for fallback data
        if (!data.filterOptions && data.listings) {
            data.filterOptions = extractFilterOptions(data.listings);
        }
        console.log(' Using fallback data with', data?.listings?.length || 0, 'listings');
        console.warn(' NOTE: You are seeing FALLBACK DATA (20 items). Google Sheets fetch failed!');
        // Update head meta from fallback so head isn't stale
        updateHeadFromData(data);
        
        console.log(' TYPE_CATEGORIES before rendering (fallback):', Object.keys(TYPE_CATEGORIES).map(function(k) {
            return TYPE_CATEGORIES[k].name;
        }).join(', '));
        
        // Render type filter buttons dynamically based on usage
        renderTypeFilterButtons(data.listings, '.type-quick-filters'); // Show all categories
        
        renderPreview(); // Sorting is now handled inside renderPreview
        
        // Set up debounced search input handlers (fallback path)
        setupSearchInputs();
        
        // Check if filters were explicitly cleared on page load
        try {
            const clearedFlag = sessionStorage.getItem('filtersExplicitlyCleared');
            if (clearedFlag === 'true') {
                filtersExplicitlyCleared = true;
                console.log(' Filters were explicitly cleared - will ignore URL parameters');
            }
        } catch (e) {
            // sessionStorage might not be available
        }
        
        // Initialize receivedUrlParams from iframe's own URL first (preserve these)
        // BUT only if filters weren't explicitly cleared
        if (!filtersExplicitlyCleared) {
            try {
                const iframeUrl = new URL(window.location.href);
                iframeUrl.searchParams.forEach(function(value, key) {
                    receivedUrlParams[key] = value;
                });
                console.log(' Initialized params from iframe URL (fallback):', receivedUrlParams);
            } catch (e) {
                console.log(' Could not parse iframe URL:', e);
            }
        }
        
        // Extract parameters from referrer (for cross-origin iframe support)
        extractParamsFromReferrer();
        
        // Handle URL parameters after fallback data is loaded
        // Use a single delay to allow postMessage response from parent
        setTimeout(function() {
            // Re-check referrer in case it wasn't available immediately
            extractParamsFromReferrer();
            // Single call to handleUrlParameters - deduplication will prevent duplicate processing
            handleUrlParameters();
        }, 800); // Single delay - long enough for postMessage but not too long
    });

// Detect when iframe becomes hidden and clear URL parameters in parent
(function() {
    let wasVisible = !document.hidden;
    
    function handleVisibilityChange() {
        const isVisible = !document.hidden;
        
        // If iframe just became hidden, notify parent to clear URL parameters
        if (wasVisible && !isVisible) {
            console.log(' Iframe became hidden - requesting parent to clear URL parameters');
            try {
                window.parent.postMessage({
                    type: 'iframeHidden',
                    source: 'find-your-adventure',
                    clearUrlParams: true
                }, '*');
            } catch (e) {
                console.warn(' Could not notify parent of visibility change:', e);
            }
        }
        
        wasVisible = isVisible;
    }
    
    // Listen for visibility changes
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Also check if iframe is in a hidden container (using IntersectionObserver)
    if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver(function(entries) {
            entries.forEach(function(entry) {
                if (!entry.isIntersecting) {
                    // Iframe is not visible, notify parent to clear URL parameters
                    console.log(' Iframe not visible in viewport - requesting parent to clear URL parameters');
                    try {
                        window.parent.postMessage({
                            type: 'iframeHidden',
                            source: 'find-your-adventure',
                            clearUrlParams: true
                        }, '*');
                    } catch (e) {
                        console.warn(' Could not notify parent of visibility change:', e);
                    }
                }
            });
        }, {
            threshold: 0
        });
        
        // Observe the document body
        observer.observe(document.body);
    }
})();

// Set up debounced search input handlers
function setupSearchInputs() {
    const searchInput = document.getElementById('previewSearchInput');
    const mobileSearchInput = document.getElementById('previewSearchInputMobile');
    
    // Skip if already set up
    if (searchInput && searchInput.dataset.debounceSetup === 'true') {
        return;
    }
    if (mobileSearchInput && mobileSearchInput.dataset.debounceSetup === 'true') {
        return;
    }
    
    function handleSearchInput() {
        // Clear existing timeout
        if (searchDebounceTimeout) {
            clearTimeout(searchDebounceTimeout);
        }
        
        // Sync mobile and desktop search inputs
        if (searchInput && mobileSearchInput) {
            if (document.activeElement === searchInput) {
                mobileSearchInput.value = searchInput.value;
            } else if (document.activeElement === mobileSearchInput) {
                searchInput.value = mobileSearchInput.value;
            }
        }
        
        // Debounce the filter call
        searchDebounceTimeout = setTimeout(function() {
            filterPreview();
        }, SEARCH_DEBOUNCE_DELAY);
    }
    
    if (searchInput) {
        searchInput.addEventListener('input', handleSearchInput);
        searchInput.addEventListener('keyup', handleSearchInput);
        searchInput.dataset.debounceSetup = 'true';
    }
    
    if (mobileSearchInput) {
        mobileSearchInput.addEventListener('input', handleSearchInput);
        mobileSearchInput.addEventListener('keyup', handleSearchInput);
        mobileSearchInput.dataset.debounceSetup = 'true';
    }
}

// Function to escape HTML special characters
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Function to format text with line breaks and paragraphs preserved
function formatDescriptionWithLineBreaks(text) {
    if (!text) return '';
    // First escape HTML to prevent XSS
    const escaped = escapeHtml(text);
    // Convert \r\n (Windows line breaks) to \n
    let formatted = escaped.replace(/\r\n/g, '\n');
    // Convert \r (Mac line breaks) to \n
    formatted = formatted.replace(/\r/g, '\n');
    // Convert double newlines (paragraph breaks) to <br><br> for visual spacing
    formatted = formatted.replace(/\n\n+/g, '<br><br>');
    // Convert single newlines to <br>
    formatted = formatted.replace(/\n/g, '<br>');
    return formatted;
}

// Function to fix character encoding issues
function fixEncoding(text) {
    if (!text) return text;
    return String(text)
        .replace(/\u00C3\u00A9/g, '\u00E9') // Fix  if double-encoded
        .replace(/\u00C3\u00A1/g, '\u00E1') // Fix 
        .replace(/\u00C3\u00AD/g, '\u00ED') // Fix 
        .replace(/\u00C3\u00B3/g, '\u00F3') // Fix 
        .replace(/\u00C3\u00BA/g, '\u00FA') // Fix 
        .replace(/\u00C3\u00B1/g, '\u00F1') // Fix 
        .replace(/\u00C3\u00BC/g, '\u00FC') // Fix 
        .replace(/\u00C3\u00B6/g, '\u00F6') // Fix 
        .replace(/\u00C3\u00A0/g, '\u00E0') // Fix 
        .replace(/\u00C3\u00A8/g, '\u00E8') // Fix 
        .replace(/\u00C3\u00AC/g, '\u00EC') // Fix 
        .replace(/\u00C3\u00B2/g, '\u00F2') // Fix 
        .replace(/\u00C3\u00B9/g, '\u00F9') // Fix 
        .replace(/\u00C3\u00A7/g, '\u00E7') // Fix 
        .replace(/Caf[^\u00E9]|Cafe[^s]/g, 'Caf') // Fix "Cafe" without accent (but not "Cafes")
        .replace(/caf[^\u00E9]|cafe[^s]/g, 'caf'); // Fix "cafe" without accent (but not "cafes")
}

// Update head <title> and meta tags from loaded data
function updateHeadFromData(loadedData) {
    try {
        if (!loadedData || !loadedData.listings || loadedData.listings.length === 0) return;
        var listings = loadedData.listings;
        // Collect unique areas and types
        var areaSet = {};
        var typeSet = {};
        for (var i = 0; i < listings.length; i++) {
            var l = listings[i] || {};
            if (l.area) areaSet[l.area] = true;
            if (l.type) typeSet[l.type] = true;
        }
        var areas = Object.keys(areaSet);
        var types = Object.keys(typeSet);

        // Compose title and description
        var titleBase = 'Nelson County Adventures';
        var title = titleBase + ' - ' + listings.length + ' listings across ' + (areas.length || 1) + ' areas';
        var typePreview = types.slice(0, 3).join(', ');
        var areaPreview = areas.slice(0, 3).join(', ');
        var description = 'Explore ' + listings.length + ' adventures in Nelson County, VA  including ' + (typePreview || 'local attractions') + (areaPreview ? ('  in ' + areaPreview) : '') + '. Find your perfect brewery, winery, hike, and more.';

        // Helpers to set or create meta tags
        function setMetaByName(name, content) {
            if (!content) return;
            var el = document.querySelector('meta[name="' + name + '"]');
            if (!el) {
                el = document.createElement('meta');
                el.setAttribute('name', name);
                document.head.appendChild(el);
            }
            el.setAttribute('content', content);
        }
        function setMetaByProperty(prop, content) {
            if (!content) return;
            var el = document.querySelector('meta[property="' + prop + '"]');
            if (!el) {
                el = document.createElement('meta');
                el.setAttribute('property', prop);
                document.head.appendChild(el);
            }
            el.setAttribute('content', content);
        }

        // Apply updates
        if (document && document.title) { document.title = title; }
        setMetaByName('title', title);
        setMetaByName('description', description);
        setMetaByProperty('og:title', title);
        setMetaByProperty('og:description', description);
        setMetaByProperty('twitter:title', title);
        setMetaByProperty('twitter:description', description);
        
        // Update structured data (JSON-LD)
        updateStructuredData(listings);
    } catch (e) {
        console.warn(' Failed to update head metadata from data:', e);
    }
}

// Update structured data (Schema.org JSON-LD) from loaded listings
function updateStructuredData(listings) {
    try {
        if (!listings || listings.length === 0) return;
        
        // Map types to Schema.org types
        function getSchemaType(listing) {
            var type = (listing.type || '').toLowerCase();
            if (type.includes('brewery') || type === 'beer') return 'Brewery';
            if (type.includes('winery') || type === 'wine') return 'Winery';
            if (type.includes('distillery') || type === 'spirits') return 'Distillery';
            if (type.includes('hiking') || type.includes('trail') || type.includes('outdoor')) return 'TouristAttraction';
            if (type.includes('restaurant') || type.includes('dining')) return 'Restaurant';
            if (type.includes('resort') || type.includes('lodging')) return 'Resort';
            if (type.includes('spa')) return 'Spa';
            if (type.includes('market')) return 'LocalBusiness';
            return 'TouristAttraction';
        }
        
        // Parse address components
        function parseAddress(addressStr) {
            if (!addressStr) return null;
            var parts = addressStr.split(',');
            var streetAddress = parts[0] ? parts[0].trim() : '';
            var locality = parts.length > 1 ? parts[parts.length - 2].trim() : '';
            var stateZip = parts.length > 0 ? parts[parts.length - 1].trim() : '';
            var stateMatch = stateZip.match(/([A-Z]{2})\s*(\d{5})/);
            var state = stateMatch ? stateMatch[1] : 'VA';
            var postalCode = stateMatch ? stateMatch[2] : '';
            
            return {
                '@type': 'PostalAddress',
                streetAddress: streetAddress,
                addressLocality: locality || '',
                addressRegion: state,
                postalCode: postalCode
            };
        }
        
        // Build containsPlace array (limit to first 50 for performance)
        var containsPlace = listings.slice(0, 50).map(function(listing) {
            var place = {
                '@type': getSchemaType(listing),
                name: listing.name || 'Unnamed'
            };
            
            if (listing.description) {
                place.description = listing.description;
            }
            
            var addr = parseAddress(listing.address);
            if (addr && addr.streetAddress) {
                place.address = addr;
            }
            
            if (listing.phone) {
                place.telephone = listing.phone;
            }
            
            if (listing.website) {
                place.url = listing.website;
            }
            
            return place;
        });
        
        // Build the full structured data object
        var structuredData = {
            '@context': 'https://schema.org',
            '@type': 'TouristDestination',
            name: 'Nelson County',
            description: 'Explore ' + listings.length + ' adventures in Nelson County, Virginia including breweries, wineries, hiking trails, and outdoor activities in the Blue Ridge Mountains.',
            url: 'https://nelsoncounty-va.gov/',
            geo: {
                '@type': 'GeoCoordinates',
                latitude: '37.8',
                longitude: '-79.0'
            },
            containsPlace: containsPlace
        };
        
        // Update or create the script tag
        var scriptEl = document.getElementById('schemaOrgData');
        if (scriptEl) {
            scriptEl.textContent = JSON.stringify(structuredData, null, 2);
        } else {
            scriptEl = document.createElement('script');
            scriptEl.type = 'application/ld+json';
            scriptEl.id = 'schemaOrgData';
            scriptEl.textContent = JSON.stringify(structuredData, null, 2);
            document.head.appendChild(scriptEl);
        }
        
        console.log(' Updated structured data with', containsPlace.length, 'places');
    } catch (e) {
        console.warn(' Failed to update structured data:', e);
    }
}

// Icon mapping function - uses shared icon mappings from localStorage
// Changes made in admin will sync here automatically
function getIconClass(type, listing) {
    if (!type) return 'icon-default';
    
    // Get the category for this type
    const categoryKey = getCategoryForType(type, listing);
    if (categoryKey && TYPE_CATEGORIES[categoryKey] && TYPE_CATEGORIES[categoryKey].icon) {
        return TYPE_CATEGORIES[categoryKey].icon;
    }
    
    // Fallback to default icon
    return 'icon-default';
}

// Fallback placeholder image (SVG data URI) - forest green background with white camera icon
const FALLBACK_IMG = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='600' viewBox='0 0 800 600'%3E%3Crect width='800' height='600' fill='%232d6a4f'/%3E%3Cg transform='translate(400, 300) scale(1)'%3E%3Cpath d='M208,60H178.13477l-14.8125-22.21875A3.99853,3.99853,0,0,0,159.99414,36h-64A3.9985,3.9985,0,0,0,92.666,37.78125L77.85352,60H48A20.02229,20.02229,0,0,0,28,80V192a20.02229,20.02229,0,0,0,20,20H208a20.02229,20.02229,0,0,0,20-20V80A20.02229,20.02229,0,0,0,208,60Zm12,132a12.01312,12.01312,0,0,1-12,12H48a12.01312,12.01312,0,0,1-12-12V80A12.01312,12.01312,0,0,1,48,68H79.99414a3.99853,3.99853,0,0,0,3.32813-1.78125L98.13477,44h59.71875L172.666,66.21875A3.9985,3.9985,0,0,0,175.99414,68H208a12.01312,12.01312,0,0,1,12,12ZM128,92a40,40,0,1,0,40,40A40.04584,40.04584,0,0,0,128,92Zm0,72a32,32,0,1,1,32-32A32.03667,32.03667,0,0,1,128,164Z' fill='white' transform='translate(-128, -128)'/%3E%3C/g%3E%3C/svg%3E";
const CARD_IMAGE_TRANSFORM = { width: 500, height: 500, cropMode: 'at_least', quality: 95, format: 'auto' };
const MAP_POPUP_IMAGE_TRANSFORM = { width: 200, cropMode: 'at_least', quality: 85, format: 'auto' };

// Helper function to normalize image URLs - prepends CMS base URL if needed
function normalizeImageUrl(url, transformOptions) {
    if (!url) return url;
    
    let finalUrl = url;
    
    // If already a full URL (starts with http:// or https://) or data URI, keep as-is
    if (!(url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:'))) {
        // Remove leading slash if present to avoid double slashes
        const cleanUrl = url.startsWith('/') ? url.substring(1) : url;
        // Prepend CMS base URL
        finalUrl = CMS_BASE_URL + '/' + cleanUrl;
    }
    
    return applyImageKitTransform(finalUrl, transformOptions);
}

function applyImageKitTransform(url, transformOptions) {
    if (!url) return url;
    
    const isImageKit = url.startsWith('https://ik.imagekit.io/');
    const hasTransform = url.includes('tr=');
    
    if (!isImageKit || hasTransform) {
        return url;
    }
    
    const defaults = {
        width: 800,
        height: 800,
        cropMode: 'at_least',
        format: 'auto',
        quality: 80
    };
    
    const options = Object.assign({}, defaults, transformOptions || {});
    const parts = [];
    
    if (options.width) parts.push('w-' + options.width);
    if (options.height) parts.push('h-' + options.height);
    if (options.cropMode) parts.push('cm-' + options.cropMode);
    if (options.format) parts.push('f-' + options.format);
    if (options.quality) parts.push('q-' + options.quality);
    
    const transformParams = 'tr=' + parts.join(',');
    return url.includes('?') ? url + '&' + transformParams : url + '?' + transformParams;
}

// Handle image error - try image2, then fallback
function handleImageError(img, image1Src, image2Src, fallbackSrc) {
    if (!img.dataset.triedImage2 && image2Src) {
        img.dataset.triedImage2 = 'true';
        img.src = normalizeImageUrl(image2Src);
    } else {
        img.src = fallbackSrc;
    }
}

// Sort listings function
function sortListings() {
    const sortDropdown = document.getElementById('sortDropdown');
    if (!sortDropdown) return; // Exit if dropdown doesn't exist
    
    // Get sort value, defaulting to default if empty or invalid
    let sortValue = sortDropdown.value;
    if (!sortValue || sortValue === '') {
        sortValue = 'default';
        sortDropdown.value = 'default'; // Set it explicitly
    }
    
    const grid = document.getElementById('previewGrid');
    if (!grid) return; // Exit if grid doesn't exist
    
    const cards = Array.from(grid.querySelectorAll('.flip-card'));
    if (cards.length === 0) return; // Exit if no cards to sort
    
    // Use the sort value (defaults to default)
    const sort = sortValue || 'default';
    
    cards.sort(function(a, b) {
        // Get listing data from the cards
        const aName = a.querySelector('.flip-card-front h3').textContent.trim().toLowerCase();
        const bName = b.querySelector('.flip-card-front h3').textContent.trim().toLowerCase();
        const aArea = (a.querySelector('.flip-card-front .badge-area')?.textContent || '').trim().toLowerCase();
        const bArea = (b.querySelector('.flip-card-front .badge-area')?.textContent || '').trim().toLowerCase();
        const aType = (a.querySelector('.flip-card-front .badge-type')?.textContent || '').trim().toLowerCase();
        const bType = (b.querySelector('.flip-card-front .badge-type')?.textContent || '').trim().toLowerCase();
        // Get category from data attribute
        const aCategory = (a.dataset.category || '').trim().toLowerCase();
        const bCategory = (b.dataset.category || '').trim().toLowerCase();
        
        switch(sort) {
            case 'default':
                // Default sort: Area  Type  Name (all A-Z)
                const areaCompare = aArea.localeCompare(bArea);
                if (areaCompare !== 0) return areaCompare;
                const typeCompare = aType.localeCompare(bType);
                if (typeCompare !== 0) return typeCompare;
                return aName.localeCompare(bName);
            case 'name-asc':
                return aName.localeCompare(bName);
            case 'name-desc':
                return bName.localeCompare(aName);
            case 'area-asc':
                return aArea.localeCompare(bArea);
            case 'type-asc':
                return aType.localeCompare(bType);
            default:
                // Fallback to default sort: Area  Type  Name
                const areaCompareDefault = aArea.localeCompare(bArea);
                if (areaCompareDefault !== 0) return areaCompareDefault;
                const typeCompareDefault = aType.localeCompare(bType);
                if (typeCompareDefault !== 0) return typeCompareDefault;
                return aName.localeCompare(bName);
        }
    });
    
    // Clear and re-append sorted cards
    grid.innerHTML = '';
    cards.forEach(function(card) {
        grid.appendChild(card);
    });
}

// Close all flipped cards
function closeAllFlippedCards() {
    document.querySelectorAll('.flip-card.flipped').forEach(function(card) {
        card.classList.remove('flipped');
    });
    const overlay = document.getElementById('flipOverlay');
    if (overlay) {
        overlay.classList.remove('active');
    }
    document.body.style.overflow = '';
}

// Helper function to add option to dropdown if it doesn't exist
function ensureDropdownOption(selectElement, value, text) {
    if (!selectElement || !value) return;
    
    // Check if option already exists by checking all options
    const options = selectElement.querySelectorAll('option');
    let optionExists = false;
    for (let i = 0; i < options.length; i++) {
        if (options[i].value === value) {
            optionExists = true;
            break;
        }
    }
    
    if (!optionExists) {
        // Create and add new option
        const option = document.createElement('option');
        option.value = value;
        option.textContent = text || value;
        selectElement.appendChild(option);
    }
}

// Filter by badge click
function filterByBadge(event, filterType, value) {
    event.preventDefault();
    event.stopPropagation();
    
    // User is explicitly setting a filter - clear the "explicitly cleared" flag
    filtersExplicitlyCleared = false;
    try {
        sessionStorage.removeItem('filtersExplicitlyCleared');
    } catch (e) {
        // sessionStorage might not be available
    }
    
    if (filterType === 'type') {
        // For badge clicks, set single type (replaces current selection)
        // Do NOT set category filter - let type filter work independently
        currentTypeFilter = [value];
        currentCategoryFilter = null; // Clear category filter so type filter works independently
        
        const typeFilter = document.getElementById('previewTypeFilter');
        const mobileTypeFilter = document.getElementById('mobileTypeFilter');
        if (typeFilter) {
            ensureDropdownOption(typeFilter, value, value);
            typeFilter.value = value;
        }
        if (mobileTypeFilter) {
            ensureDropdownOption(mobileTypeFilter, value, value);
            mobileTypeFilter.value = value;
        }
        // Update type filter buttons - deactivate all category buttons, keep "All Types" active
        document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
            btn.classList.remove('active');
            if (btn.dataset.type === '' && !btn.dataset.category) {
                btn.classList.add('active');
            }
        });
    } else if (filterType === 'area') {
        const areaFilter = document.getElementById('previewAreaFilter');
        const mobileAreaFilter = document.getElementById('mobileAreaFilter');
        if (areaFilter) {
            ensureDropdownOption(areaFilter, value, value);
            areaFilter.value = value;
        }
        if (mobileAreaFilter) {
            ensureDropdownOption(mobileAreaFilter, value, value);
            mobileAreaFilter.value = value;
        }
    } else if (filterType === 'featured') {
        currentFeaturedOnly = true;
    }
    
    filterPreview();
}

// Filter by amenity click
function filterByAmenity(event, amenity) {
    event.stopPropagation();
    
    // User is explicitly setting a filter - clear the "explicitly cleared" flag
    filtersExplicitlyCleared = false;
    try {
        sessionStorage.removeItem('filtersExplicitlyCleared');
    } catch (e) {
        // sessionStorage might not be available
    }
    
    const amenityFilter = document.getElementById('previewAmenityFilter');
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    if (amenityFilter) {
        ensureDropdownOption(amenityFilter, amenity, amenity);
        amenityFilter.value = amenity;
    }
    if (mobileAmenityFilter) {
        ensureDropdownOption(mobileAmenityFilter, amenity, amenity);
        mobileAmenityFilter.value = amenity;
    }
    
    filterPreview();
}

// Main filter function
function filterPreview() {
    if (!data) return;
    
    const searchInput = document.getElementById('previewSearchInput');
    const mobileSearchInput = document.getElementById('previewSearchInputMobile');
    const areaFilter = document.getElementById('previewAreaFilter');
    const amenityFilter = document.getElementById('previewAmenityFilter');
    const mobileAreaFilter = document.getElementById('mobileAreaFilter');
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    
    // Get search term from either input (prefer desktop, fallback to mobile)
    const searchTerm = (searchInput ? searchInput.value : (mobileSearchInput ? mobileSearchInput.value : '')).toLowerCase();
    
    // Sync mobile and desktop search inputs
    if (searchInput && mobileSearchInput) {
        if (document.activeElement === searchInput) {
            mobileSearchInput.value = searchInput.value;
        } else if (document.activeElement === mobileSearchInput) {
            searchInput.value = mobileSearchInput.value;
        }
    }
        const selectedArea = (areaFilter ? areaFilter.value : '') || (mobileAreaFilter ? mobileAreaFilter.value : '');
        const selectedAmenity = (amenityFilter ? amenityFilter.value : '') || (mobileAmenityFilter ? mobileAmenityFilter.value : '');
    
    const filtered = data.listings.filter(function(listing) {
        const amenitiesText = Array.isArray(listing.amenities) ? listing.amenities.join(' ').toLowerCase() : '';
        const addressText = (listing.address || '').toLowerCase();
        const phoneText = (listing.phone || '').toLowerCase();
        const websiteText = (listing.website || '').toLowerCase();
        const matchesSearch = !searchTerm || 
            listing.name.toLowerCase().includes(searchTerm) ||
            listing.type.toLowerCase().includes(searchTerm) ||
            listing.area.toLowerCase().includes(searchTerm) ||
            listing.description.toLowerCase().includes(searchTerm) ||
            addressText.includes(searchTerm) ||
            phoneText.includes(searchTerm) ||
            websiteText.includes(searchTerm) ||
            amenitiesText.includes(searchTerm);
        
        // Handle type matching
        // Priority 1: If a category filter is active (user clicked a category button), filter by category
        // Priority 2: If only individual types are selected (user clicked a type badge/button), filter by exact type match
        let matchesType = true;
        if (currentCategoryFilter) {
            // Category filter mode: User clicked a category button
            // Use category from Google Sheets directly (no auto-assignment)
            let listingCategory = null;
            if (listing.category && listing.category.trim() !== '') {
                // Use category directly from Google Sheets
                listingCategory = listing.category.trim();
            } else if (listing.type) {
                // Only use auto-assignment as fallback if no category in Google Sheets
                listingCategory = getCategoryForType(listing.type, listing);
            }
            matchesType = listingCategory === currentCategoryFilter;
        } else if (currentTypeFilter.length > 0) {
            // Individual type filter mode: User selected specific type(s) via badge, URL param, mobile filter, or individual type button
            // Filter by exact type match (case-insensitive)
            matchesType = currentTypeFilter.some(function(filterType) {
                // Case-insensitive comparison
                if (filterType.toLowerCase() === listing.type.toLowerCase()) return true;
                // Handle Activity/Outdoor equivalence
                const filterLower = filterType.toLowerCase();
                const listingLower = listing.type.toLowerCase();
                if ((filterLower === 'activity' || filterLower === 'outdoor') && 
                    (listingLower === 'activity' || listingLower === 'outdoor')) {
                    return true;
                }
                return false;
            });
        }
        // Area filter: case-insensitive match with trimmed whitespace
        let matchesArea = true;
        if (selectedArea) {
            const selectedAreaNormalized = selectedArea.trim().toLowerCase();
            const listingAreaNormalized = (listing.area || '').trim().toLowerCase();
            matchesArea = listingAreaNormalized === selectedAreaNormalized;
        }
        // Amenity filter: case-insensitive match against amenities array
        let matchesAmenity = true;
        if (selectedAmenity) {
            if (listing.amenities && Array.isArray(listing.amenities)) {
                // Case-insensitive comparison
                matchesAmenity = listing.amenities.some(function(amenity) {
                    return amenity && amenity.toLowerCase() === selectedAmenity.toLowerCase();
                });
            } else {
                matchesAmenity = false;
            }
        }
        const matchesFeatured = !currentFeaturedOnly || !!listing.featured;
        
        return matchesSearch && matchesType && matchesArea && matchesAmenity && matchesFeatured;
    });
    
    // Store all filtered listings for pagination
    allFilteredListings = filtered;
    // Reset pagination when filters change
    currentPage = 1;
    hasMoreItems = filtered.length > ITEMS_PER_PAGE;
    
    // Debug logging for filtering
    if (currentCategoryFilter) {
        // Category filter mode
        console.log(' Filtering by category:', currentCategoryFilter, '| Filtered results:', filtered.length, 'of', data.listings.length);
        if (filtered.length === 0) {
            console.log(' No listings found for category:', currentCategoryFilter);
            console.log(' Sample listing types in data:', data.listings.slice(0, 5).map(function(l) {
                return l.type + ' -> ' + getCategoryForType(l.type, l);
            }).join(', '));
        }
    } else if (currentTypeFilter.length > 0) {
        // Individual type filter mode
        console.log(' Filtering by type(s):', currentTypeFilter.join(', '), '| Filtered results:', filtered.length, 'of', data.listings.length);
    }
    
    // Show/hide clear button based on whether any filters are active
    // Normalize selectedArea and selectedAmenity - treat empty string as no filter
    const normalizedArea = selectedArea ? selectedArea.trim() : '';
    const normalizedAmenity = selectedAmenity ? selectedAmenity.trim() : '';
    const hasActiveFilters = searchTerm || currentCategoryFilter || currentTypeFilter.length > 0 || normalizedArea || normalizedAmenity || currentFeaturedOnly;
    
    const clearBtn = document.getElementById('clearFiltersBtn');
    const mobileClearBtn = document.getElementById('mobileClearFiltersBtn');
    if (clearBtn) {
        clearBtn.style.display = hasActiveFilters ? 'block' : 'none';
    }
    if (mobileClearBtn) {
        mobileClearBtn.style.display = hasActiveFilters ? 'block' : 'none';
    }
    
    // Ensure sort dropdown is set to default if not already set
    const sortDropdown = document.getElementById('sortDropdown');
    if (sortDropdown && !sortDropdown.value) {
        sortDropdown.value = 'default';
    }
    
    renderPreview(); // renderPreview will use allFilteredListings and pagination
    
    // Send scroll-to-top message to parent (Framer component)
    // Use postMessage directly without checking window.parent/top to avoid CORS errors
    setTimeout(function() {
        try {
            // postMessage is safe to call even cross-origin - it just won't be received if no listener
            window.parent.postMessage({ type: 'scrollToTop', source: 'adventure-directory' }, '*');
        } catch (e) {
            // Silently fail - cross-origin restriction
        }
        try {
            window.top.postMessage({ type: 'scrollToTop', source: 'adventure-directory' }, '*');
        } catch (e) {
            // Silently fail - cross-origin restriction
        }
    }, 100);
    
    // Report height after filtering - wait longer for layout to settle
    setTimeout(function() {
        reportContentHeight();
        // Re-apply sticky positioning after render - call multiple times to ensure it sticks
        if (typeof handleStickyInIframe === 'function') {
            setTimeout(function() {
                handleStickyInIframe();
            }, 10);
        }
        // Also report again after a bit more delay to catch any late-rendering elements
        setTimeout(function() {
            reportContentHeight();
        }, 300);
    }, 200);
}

// Clear all filters
function clearPreviewFilters() {
    const searchInput = document.getElementById('previewSearchInput');
    const mobileSearchInput = document.getElementById('previewSearchInputMobile');
    const typeFilter = document.getElementById('previewTypeFilter');
    const areaFilter = document.getElementById('previewAreaFilter');
    const amenityFilter = document.getElementById('previewAmenityFilter');
    const clearBtn = document.getElementById('clearFiltersBtn');
    
    const mobileTypeFilter = document.getElementById('mobileTypeFilter');
    const mobileAreaFilter = document.getElementById('mobileAreaFilter');
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    
    // Clear all search inputs
    if (searchInput) searchInput.value = '';
    if (mobileSearchInput) mobileSearchInput.value = '';
    
    // Reset dropdowns to first option (usually "All" or empty)
    // Use selectedIndex = 0 to ensure first option is selected, then set value to empty
    if (typeFilter && typeFilter.options.length > 0) {
        typeFilter.selectedIndex = 0;
        typeFilter.value = typeFilter.options[0].value || '';
    }
    if (areaFilter && areaFilter.options.length > 0) {
        areaFilter.selectedIndex = 0;
        areaFilter.value = areaFilter.options[0].value || '';
    }
    if (amenityFilter && amenityFilter.options.length > 0) {
        amenityFilter.selectedIndex = 0;
        amenityFilter.value = amenityFilter.options[0].value || '';
    }
    const mobileCategoryFilter = document.getElementById('mobileCategoryFilter');
    if (mobileCategoryFilter && mobileCategoryFilter.options.length > 0) {
        mobileCategoryFilter.selectedIndex = 0;
        mobileCategoryFilter.value = mobileCategoryFilter.options[0].value || '';
        updateMobileCategoryIcon('');
    }
    if (mobileTypeFilter && mobileTypeFilter.options.length > 0) {
        mobileTypeFilter.selectedIndex = 0;
        mobileTypeFilter.value = mobileTypeFilter.options[0].value || '';
    }
    if (mobileAreaFilter && mobileAreaFilter.options.length > 0) {
        mobileAreaFilter.selectedIndex = 0;
        mobileAreaFilter.value = mobileAreaFilter.options[0].value || '';
    }
    if (mobileAmenityFilter && mobileAmenityFilter.options.length > 0) {
        mobileAmenityFilter.selectedIndex = 0;
        mobileAmenityFilter.value = mobileAmenityFilter.options[0].value || '';
    }
    
    // Clear filter state variables
    currentTypeFilter = [];
    currentCategoryFilter = null;
    currentFeaturedOnly = false;
    
    // Clear received URL parameters to prevent them from being re-applied
    receivedUrlParams = {};
    lastProcessedParamsHash = null;
    
    // Set flag to ignore all URL parameters until user explicitly sets a filter
    filtersExplicitlyCleared = true;
    try {
        sessionStorage.setItem('filtersExplicitlyCleared', 'true');
    } catch (e) {
        // sessionStorage might not be available
    }
    
    // Reset pagination
    currentPage = 1;
    
    // Reset ALL filter buttons (type and category) - activate "All Types" button
    // Clear all type filter buttons (including category buttons which have both classes)
    document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
        btn.classList.remove('active');
    });
    // Also clear any category filter buttons explicitly (they have .category-filter-btn class)
    document.querySelectorAll('.category-filter-btn').forEach(function(btn) {
        btn.classList.remove('active');
    });
    // Activate the "All Types" button (no category attribute, empty type)
    document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
        if (btn.dataset.type === '' && !btn.dataset.category) {
            btn.classList.add('active');
        }
    });
    
    // Clear filters locally first (without navigation) to show all listings immediately
    if (data) {
        filterPreview(); // This will show all listings since all filters are cleared
    }
    
    // Hide clear button
    if (clearBtn) clearBtn.style.display = 'none';
    const mobileClearBtn = document.getElementById('mobileClearFiltersBtn');
    if (mobileClearBtn) mobileClearBtn.style.display = 'none';
    
    // Now try to clear the parent window URL (for Framer)
    // This prevents the filter from being re-applied on next page load
    try {
        // Check if we're in an iframe
        var isInIframe = false;
        try {
            isInIframe = window.self !== window.top;
        } catch (e) {
            // Cross-origin - can't access window.top, assume iframe
            isInIframe = true;
        }
        
        if (!isInIframe) {
            // NOT in an iframe - clear URL directly (full page access)
            var cleanUrl = window.location.pathname + (window.location.hash || '');
            window.history.replaceState({}, '', cleanUrl);
            console.log(' Cleared URL parameters directly (not in iframe):', cleanUrl);
            // Reset receivedUrlParams since we cleared the URL
            receivedUrlParams = {};
            lastProcessedParamsHash = null;
            return; // Done - URL is cleared
        }
        
        // We're in an iframe - try to clear parent URL
        try {
            if (window.parent && window.parent !== window) {
                // Same-origin iframe - can access parent directly
                const parentUrl = new URL(window.parent.location.href);
                const parentBaseUrl = parentUrl.origin + parentUrl.pathname + (parentUrl.hash || '');
                console.log(' Navigating parent window to:', parentBaseUrl);
                window.parent.location.href = parentBaseUrl;
                return; // Exit early - navigation will reload page
            }
        } catch (e) {
            // Cross-origin - can't access parent, send postMessage to clear parent URL
            console.log(' Cross-origin detected - sending postMessage to clear parent URL');
            try {
                // Get parent path from referrer or construct it
                const referrer = document.referrer;
                let parentPath = '/find-your-adventure'; // Default Framer page path
                if (referrer) {
                    try {
                        const referrerUrl = new URL(referrer);
                        parentPath = referrerUrl.pathname + (referrerUrl.hash || '');
                    } catch (e) {
                        // Use default
                    }
                }
                
                // Send postMessage to parent to clear URL
                // Don't navigate iframe - filters are already cleared locally
                window.parent.postMessage({
                    type: 'setUrlParams',
                    clearAll: true,
                    navigateTo: parentPath
                }, '*');
                
                // Ignore URL parameters for 5 seconds to prevent re-applying filters
                // This gives the parent time to clear its URL before the next poll (polls every 2 seconds)
                ignoreUrlParamsUntil = Date.now() + 5000;
                console.log(' Sent clearAll message to parent - filters cleared locally, ignoring URL params for 5 seconds');
                
                // Also send a second message after a delay to ensure parent gets it
                setTimeout(function() {
                    window.parent.postMessage({
                        type: 'setUrlParams',
                        clearAll: true,
                        navigateTo: parentPath
                    }, '*');
                    console.log(' Sent second clearAll message to parent (backup)');
                }, 500);
                
                // Don't navigate iframe - filters are already cleared, just wait for parent to clear URL
                return;
            } catch (e2) {
                console.warn(' Could not send postMessage:', e2);
            }
        }
        
        // If not in iframe, navigate to base path
        const url = new URL(window.location.href);
        const basePath = url.pathname + (url.hash || '');
        const fullBaseUrl = url.origin + basePath;
        console.log(' Navigating to:', fullBaseUrl);
        window.location.href = fullBaseUrl;
    } catch (e) {
        console.warn(' Error navigating:', e);
        // Filters are already cleared locally, so at least the UI is updated
    }
}

// Apply breadcrumb filter directly (no URL params)
function applyBreadcrumbFilter(filterParams) {
    if (!data) {
        console.warn(' Cannot apply breadcrumb filter - data not loaded');
        return;
    }
    
    console.log(' Applying breadcrumb filter:', filterParams);
    
    // Clear all existing filters first
    currentCategoryFilter = null;
    currentTypeFilter = [];
    currentFeaturedOnly = false;
    
    // Clear all filter inputs
    const searchInput = document.getElementById('previewSearchInput');
    const mobileSearchInput = document.getElementById('previewSearchInputMobile');
    const areaFilter = document.getElementById('previewAreaFilter');
    const amenityFilter = document.getElementById('previewAmenityFilter');
    const mobileAreaFilter = document.getElementById('mobileAreaFilter');
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    
    if (searchInput) searchInput.value = '';
    if (mobileSearchInput) mobileSearchInput.value = '';
    if (areaFilter) areaFilter.value = '';
    if (amenityFilter) amenityFilter.value = '';
    if (mobileAreaFilter) mobileAreaFilter.value = '';
    if (mobileAmenityFilter) mobileAmenityFilter.value = '';
    
    // Clear all filter buttons
    document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
        btn.classList.remove('active');
    });
    
    // Set filter state based on params
    if (filterParams.category) {
        currentCategoryFilter = filterParams.category.toLowerCase();
        console.log(' Setting category filter:', currentCategoryFilter);
        
        // Get types for this category
        const categoryData = TYPE_CATEGORIES[currentCategoryFilter];
        if (categoryData && categoryData.types) {
            currentTypeFilter = categoryData.types.slice();
            console.log(' Category has types:', currentTypeFilter);
        } else {
            currentTypeFilter = [];
            console.log(' Category has no types defined');
        }
        
        // Update category button state
        document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
            if (btn.dataset.category === currentCategoryFilter) {
                btn.classList.add('active');
                console.log(' Activated category button:', currentCategoryFilter);
            }
        });
        
        // Update mobile category dropdown
        const mobileCategoryFilter = document.getElementById('mobileCategoryFilter');
        if (mobileCategoryFilter) {
            mobileCategoryFilter.value = currentCategoryFilter;
            updateMobileCategoryIcon(currentCategoryFilter);
        }
    }
    
    if (filterParams.type) {
        currentTypeFilter = [filterParams.type];
        currentCategoryFilter = null; // Clear category when filtering by type
        console.log(' Setting type filter:', currentTypeFilter);
        
        // Clear mobile category dropdown
        const mobileCategoryFilter = document.getElementById('mobileCategoryFilter');
        if (mobileCategoryFilter) {
            mobileCategoryFilter.value = '';
            updateMobileCategoryIcon('');
        }
        
        // Update type filter dropdowns
        const typeFilter = document.getElementById('previewTypeFilter');
        const mobileTypeFilter = document.getElementById('mobileTypeFilter');
        if (typeFilter) {
            ensureDropdownOption(typeFilter, filterParams.type, filterParams.type);
            typeFilter.value = filterParams.type;
        }
        if (mobileTypeFilter) {
            ensureDropdownOption(mobileTypeFilter, filterParams.type, filterParams.type);
            mobileTypeFilter.value = filterParams.type;
        }
        
        // Update type filter buttons - deactivate all category buttons, keep "All Types" active
        document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
            btn.classList.remove('active');
            if (btn.dataset.type === '' && !btn.dataset.category) {
                btn.classList.add('active');
            }
        });
    }
    
    // Set area filter
    if (filterParams.area) {
        if (areaFilter) {
            ensureDropdownOption(areaFilter, filterParams.area, filterParams.area);
            areaFilter.value = filterParams.area;
            console.log(' Setting area filter:', filterParams.area);
        }
        if (mobileAreaFilter) {
            ensureDropdownOption(mobileAreaFilter, filterParams.area, filterParams.area);
            mobileAreaFilter.value = filterParams.area;
        }
    }
    
    // Set amenity filter
    if (filterParams.amenity) {
        if (amenityFilter) {
            amenityFilter.value = filterParams.amenity;
            console.log(' Setting amenity filter:', filterParams.amenity);
        }
        if (mobileAmenityFilter) mobileAmenityFilter.value = filterParams.amenity;
    }
    
    // Set search
    if (filterParams.search) {
        if (searchInput) {
            searchInput.value = filterParams.search;
            console.log(' Setting search filter:', filterParams.search);
        }
        if (mobileSearchInput) mobileSearchInput.value = filterParams.search;
    }
    
    // Set featured filter
    if (filterParams.featured === 'true') {
        currentFeaturedOnly = true;
        console.log(' Setting featured filter: true');
    } else {
        currentFeaturedOnly = false;
    }
    
    // Apply filters
    console.log(' Calling filterPreview() with filters:', {
        category: currentCategoryFilter,
        type: currentTypeFilter,
        area: filterParams.area,
        amenity: filterParams.amenity,
        search: filterParams.search,
        featured: currentFeaturedOnly
    });
    
    // Small delay to ensure DOM is updated before filtering
    // This prevents race conditions where dropdowns aren't ready yet
    setTimeout(function() {
        // Double-check that filter values are set correctly
        if (filterParams.area && areaFilter && areaFilter.value !== filterParams.area) {
            ensureDropdownOption(areaFilter, filterParams.area, filterParams.area);
            areaFilter.value = filterParams.area;
            console.log(' Re-verified area filter:', areaFilter.value);
        }
        if (filterParams.amenity && amenityFilter && amenityFilter.value !== filterParams.amenity) {
            ensureDropdownOption(amenityFilter, filterParams.amenity, filterParams.amenity);
            amenityFilter.value = filterParams.amenity;
            console.log(' Re-verified amenity filter:', amenityFilter.value);
        }
        if (filterParams.type) {
            const typeFilter = document.getElementById('previewTypeFilter');
            const mobileTypeFilter = document.getElementById('mobileTypeFilter');
            if (typeFilter && typeFilter.value !== filterParams.type) {
                ensureDropdownOption(typeFilter, filterParams.type, filterParams.type);
                typeFilter.value = filterParams.type;
                console.log(' Re-verified type filter:', typeFilter.value);
            }
            if (mobileTypeFilter && mobileTypeFilter.value !== filterParams.type) {
                ensureDropdownOption(mobileTypeFilter, filterParams.type, filterParams.type);
                mobileTypeFilter.value = filterParams.type;
            }
        }
        
        // Verify filter state before applying
        console.log(' Filter state before filterPreview():', {
            currentCategoryFilter: currentCategoryFilter,
            currentTypeFilter: currentTypeFilter,
            areaFilterValue: areaFilter ? areaFilter.value : 'N/A',
            amenityFilterValue: amenityFilter ? amenityFilter.value : 'N/A',
            currentFeaturedOnly: currentFeaturedOnly
        });
        
        // Now apply filters - this will call renderPreview() internally
        filterPreview();
        
        // Verify after filtering
        setTimeout(function() {
            console.log(' After filterPreview() - allFilteredListings count:', allFilteredListings.length);
        }, 100);
    }, 50); // Small delay to ensure DOM updates are complete
}

// Filter to show only a specific listing (from map popup)
function filterByListingName(listingName) {
    if (!data) return;
    
    // Clear all other filters (both desktop and mobile)
    const searchInput = document.getElementById('previewSearchInput');
    const mobileSearchInput = document.getElementById('previewSearchInputMobile');
    const areaFilter = document.getElementById('previewAreaFilter');
    const amenityFilter = document.getElementById('previewAmenityFilter');
    const mobileTypeFilter = document.getElementById('mobileTypeFilter');
    const mobileAreaFilter = document.getElementById('mobileAreaFilter');
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    
    if (searchInput) searchInput.value = '';
    if (mobileSearchInput) mobileSearchInput.value = '';
    if (areaFilter) areaFilter.value = '';
    if (amenityFilter) amenityFilter.value = '';
    if (mobileTypeFilter) mobileTypeFilter.value = '';
    if (mobileAreaFilter) mobileAreaFilter.value = '';
    if (mobileAmenityFilter) mobileAmenityFilter.value = '';
    currentTypeFilter = [];
    currentCategoryFilter = null;
    currentFeaturedOnly = false;
    
    // Reset type filter buttons - activate "All Types" button
    document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
        btn.classList.remove('active');
        if (btn.dataset.type === '' && !btn.dataset.category) {
            btn.classList.add('active');
        }
    });
    
    // Filter to show only the clicked listing
    const filtered = data.listings.filter(function(listing) {
        return listing.name === listingName;
    });
    
    // Show clear button (both desktop and mobile)
    const clearBtn = document.getElementById('clearFiltersBtn');
    const mobileClearBtn = document.getElementById('mobileClearFiltersBtn');
    if (clearBtn) clearBtn.style.display = 'block';
    if (mobileClearBtn) mobileClearBtn.style.display = 'block';
    
    // Ensure sort dropdown is set to default if not already set
    // renderPreview will handle sorting automatically
    const sortDropdown = document.getElementById('sortDropdown');
    if (sortDropdown && !sortDropdown.value) {
        sortDropdown.value = 'default';
    }
    
    renderPreview(filtered); // Sorting is now handled inside renderPreview
    
    // Notify parent that filters were applied (for aggressive URL clearing)
    // This happens after renderPreview completes, so filters are definitely applied
    setTimeout(function() {
        try {
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'filtersApplied',
                    source: 'find-your-adventure'
                }, '*');
                console.log(' Notified parent that filters were applied');
            }
        } catch (e) {
            // Cross-origin restriction - silently fail
        }
    }, 100); // Small delay to ensure renderPreview has completed
    
    // Report height after filtering to specific listing
    setTimeout(function() {
        reportContentHeight();
    }, 150);
    
    // Scroll to the specific card after a brief delay to let it render
    setTimeout(function() {
        const previewGrid = document.getElementById('previewGrid');
        if (previewGrid && filtered.length > 0) {
            // Find the card for this listing
            const cards = previewGrid.querySelectorAll('.flip-card');
            if (cards.length > 0) {
                cards[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                cards[0].classList.remove('flipped');
            } else {
                previewGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
    }, 200);
}

// Main render function
// Debounce and guard for reportContentHeight to prevent infinite loops
let heightReportTimeout = null;
let lastReportedHeight = 0;
let isReportingHeight = false;
let isInIframe = false;

// Check if we're in an iframe on load
try {
    isInIframe = window.self !== window.top;
} catch (e) {
    // Cross-origin iframe - assume we are in one
    isInIframe = true;
}

// Function to report content height to parent window (for Framer embed)
function reportContentHeight() {
    // Don't report height if not in iframe (no parent to report to)
    if (!isInIframe) {
        return;
    }
    
    // Prevent infinite loops - don't report if already reporting
    if (isReportingHeight) {
        return;
    }
    
    // Clear any pending height reports
    if (heightReportTimeout) {
        clearTimeout(heightReportTimeout);
    }
    
    // Debounce height reporting (longer delay in iframe to prevent loops)
    heightReportTimeout = setTimeout(function() {
        isReportingHeight = true;
        
        try {
            // Measure from top of document to bottom of last visible element
            const previewGrid = document.getElementById('previewGrid');
            const previewHeader = document.querySelector('.preview-header');
            const previewMain = document.querySelector('.preview-main');
            
            let height = 0;
            
            if (previewGrid) {
                // Get all visible cards in the grid (not display:none)
                const cards = Array.from(previewGrid.querySelectorAll('.flip-card')).filter(function(card) {
                    const style = window.getComputedStyle(card);
                    return style.display !== 'none' && style.visibility !== 'hidden';
                });
                
                if (cards.length > 0) {
                    // Get the bottom of the last visible card
                    const lastCard = cards[cards.length - 1];
                    const lastCardRect = lastCard.getBoundingClientRect();
                    
                    // Get the top of the document
                    const scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
                    
                    // Calculate height from top of document to bottom of last card
                    height = lastCardRect.bottom + scrollTop;
                    
                    // Add header height if it exists and is above the grid
                    if (previewHeader) {
                        const headerRect = previewHeader.getBoundingClientRect();
                        if (headerRect.top < previewGrid.getBoundingClientRect().top) {
                            // Header is above grid, already included in calculation
                        } else {
                            // Header might be separate, add it
                            height = Math.max(height, headerRect.bottom + scrollTop);
                        }
                    }
                } else {
                    // No cards visible - measure grid container itself
                    const gridRect = previewGrid.getBoundingClientRect();
                    const scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
                    height = gridRect.bottom + scrollTop;
                    
                    if (previewHeader) {
                        const headerRect = previewHeader.getBoundingClientRect();
                        height = Math.max(height, headerRect.bottom + scrollTop);
                    }
                }
            } else if (previewMain) {
                // Fallback: measure main container
                const mainRect = previewMain.getBoundingClientRect();
                const scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
                height = mainRect.bottom + scrollTop;
            } else {
                // Ultimate fallback - use body/document height
                const body = document.body;
                const html = document.documentElement;
                height = Math.max(
                    body.scrollHeight,
                    body.offsetHeight,
                    html.scrollHeight,
                    html.offsetHeight
                );
            }
            
            // Add a buffer (30px) for safety
            const heightWithBuffer = Math.ceil(height) + 30;
            
            // Only report if height actually changed (prevent unnecessary updates)
            if (Math.abs(heightWithBuffer - lastReportedHeight) < 5) {
                isReportingHeight = false;
                return;
            }
            
            lastReportedHeight = heightWithBuffer;
            
            console.log(' Reporting height:', heightWithBuffer, 'px', '(visible cards:', document.querySelectorAll('.flip-card:not([style*="display: none"])').length, ')');
            
            // Send height to parent window via postMessage
            // Don't check window.parent/top properties - just call postMessage directly to avoid CORS errors
            const message = {
                type: 'resize',
                height: heightWithBuffer,
                source: 'find-your-adventure'
            };
            
            try {
                window.parent.postMessage(message, '*');
            } catch (e) {
                // Cross-origin restriction - silently fail
            }
            
            try {
                window.top.postMessage(message, '*');
            } catch (e) {
                // Cross-origin restriction - silently fail
            }
            
            // Reset flag after a short delay
            setTimeout(function() {
                isReportingHeight = false;
            }, 100);
        } catch (e) {
            // Silently fail if postMessage is blocked or parent is not accessible
            console.log('Could not report height to parent:', e);
            isReportingHeight = false;
        }
    }, 150);
}

// Guard to prevent render loops
let isRendering = false;
let renderTimeout = null;

function renderPreview(filteredListings, appendMode) {
    if (!data) {
        console.error(' renderPreview called but data is null/undefined');
        return;
    }
    
    // Debounce rapid render calls (especially important in iframe)
    if (renderTimeout) {
        clearTimeout(renderTimeout);
    }
    
    renderTimeout = setTimeout(function() {
        // Prevent concurrent renders (unless appending)
        if (isRendering && !appendMode) {
            console.log(' Render already in progress, skipping duplicate call...');
            return;
        }
        
        isRendering = true;
        
        try {
            // Use allFilteredListings if available (from filterPreview), otherwise use passed filteredListings or all data
            const listingsToRender = allFilteredListings.length > 0 ? allFilteredListings : (filteredListings || data.listings);
            
            // Calculate pagination
            const startIndex = appendMode ? (currentPage - 1) * ITEMS_PER_PAGE : 0;
            const endIndex = appendMode ? currentPage * ITEMS_PER_PAGE : ITEMS_PER_PAGE;
            const listings = listingsToRender.slice(startIndex, endIndex);
            
            console.log(' renderPreview called:', {
                'total listings': listingsToRender.length,
                'showing': listings.length,
                'page': currentPage,
                'appendMode': appendMode || false
            });
            
            const grid = document.getElementById('previewGrid');
            if (!grid) {
                console.error(' previewGrid element not found');
                isRendering = false;
                return;
            }
            
            // Clear grid only if not appending (new filter/search)
            let needsDelayedRender = false;
            if (!appendMode) {
                const existingCards = grid.querySelectorAll('.flip-card');
                if (existingCards.length > 0) {
                    grid.classList.remove('grid-loaded');
                    existingCards.forEach(function(card) {
                        card.style.opacity = '0';
                        card.style.transform = 'translateY(-20px)';
                    });
                    // Wait for fade-out, then clear and render
                    needsDelayedRender = true;
                    setTimeout(function() {
                        grid.innerHTML = '';
                        grid.classList.add('grid-loaded');
                        // Now render cards after grid is cleared
                        renderCardsAfterGridClear();
                    }, 300);
                } else {
                    grid.innerHTML = '';
                    grid.classList.add('grid-loaded');
                }
            } else {
                // Append mode - just ensure grid is visible
                grid.classList.add('grid-loaded');
            }
            
            // If we delayed rendering, return early (cards will render in setTimeout)
            if (needsDelayedRender) {
                return;
            }
            
            // Normal path: render cards immediately
            renderCardsAfterGridClear();
            
            function renderCardsAfterGridClear() {
    // Populate filters on first render
    // Helper function to ensure an option exists in a dropdown
    function ensureDropdownOption(select, value, text) {
        if (!select || !value) return;
        // Check if option already exists
        const existingOption = Array.from(select.options).find(opt => opt.value === value);
        if (!existingOption) {
            const option = document.createElement('option');
            option.value = value;
            option.textContent = text || value;
            select.appendChild(option);
        }
    }
    
    // Populate filter dropdowns - always refresh from data.filterOptions
    const typeFilter = document.getElementById('previewTypeFilter');
    if (typeFilter && data.filterOptions && data.filterOptions.types) {
        const currentValue = typeFilter.value; // Preserve current selection
        // Clear all options except the first "All" option
        while (typeFilter.options.length > 1) {
            typeFilter.remove(1);
        }
        // Add all types from filterOptions
        data.filterOptions.types.forEach(function(type) {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            typeFilter.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentValue && Array.from(typeFilter.options).some(opt => opt.value === currentValue)) {
            typeFilter.value = currentValue;
        }
    }
    
    const areaFilter = document.getElementById('previewAreaFilter');
    if (areaFilter && data.filterOptions && data.filterOptions.areas) {
        const currentValue = areaFilter.value; // Preserve current selection
        // Clear all options except the first "All" option
        while (areaFilter.options.length > 1) {
            areaFilter.remove(1);
        }
        // Add all areas from filterOptions
        data.filterOptions.areas.forEach(function(area) {
            const option = document.createElement('option');
            option.value = area;
            option.textContent = area;
            areaFilter.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentValue && Array.from(areaFilter.options).some(opt => opt.value === currentValue)) {
            areaFilter.value = currentValue;
        }
    }
    
    const amenityFilter = document.getElementById('previewAmenityFilter');
    if (amenityFilter && data.filterOptions && data.filterOptions.amenities) {
        const currentValue = amenityFilter.value; // Preserve current selection
        // Clear all options except the first "All" option
        while (amenityFilter.options.length > 1) {
            amenityFilter.remove(1);
        }
        // Add all amenities from filterOptions
        data.filterOptions.amenities.forEach(function(amenity) {
            const option = document.createElement('option');
            option.value = amenity;
            option.textContent = amenity;
            amenityFilter.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentValue && Array.from(amenityFilter.options).some(opt => opt.value === currentValue)) {
            amenityFilter.value = currentValue;
        }
    }
    
    // Populate mobile filter dropdowns - always refresh from data.filterOptions
    const mobileTypeFilter = document.getElementById('mobileTypeFilter');
    if (mobileTypeFilter && data.filterOptions && data.filterOptions.types) {
        const currentValue = mobileTypeFilter.value; // Preserve current selection
        // Clear all options except the first "All" option
        while (mobileTypeFilter.options.length > 1) {
            mobileTypeFilter.remove(1);
        }
        // Add all types from filterOptions
        data.filterOptions.types.forEach(function(type) {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            mobileTypeFilter.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentValue && Array.from(mobileTypeFilter.options).some(opt => opt.value === currentValue)) {
            mobileTypeFilter.value = currentValue;
        }
    }
    
    const mobileAreaFilter = document.getElementById('mobileAreaFilter');
    if (mobileAreaFilter && data.filterOptions && data.filterOptions.areas) {
        const currentValue = mobileAreaFilter.value; // Preserve current selection
        // Clear all options except the first "All" option
        while (mobileAreaFilter.options.length > 1) {
            mobileAreaFilter.remove(1);
        }
        // Add all areas from filterOptions
        data.filterOptions.areas.forEach(function(area) {
            const option = document.createElement('option');
            option.value = area;
            option.textContent = area;
            mobileAreaFilter.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentValue && Array.from(mobileAreaFilter.options).some(opt => opt.value === currentValue)) {
            mobileAreaFilter.value = currentValue;
        }
    }
    
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    if (mobileAmenityFilter && data.filterOptions && data.filterOptions.amenities) {
        const currentValue = mobileAmenityFilter.value; // Preserve current selection
        // Clear all options except the first "All" option
        while (mobileAmenityFilter.options.length > 1) {
            mobileAmenityFilter.remove(1);
        }
        // Add all amenities from filterOptions
        data.filterOptions.amenities.forEach(function(amenity) {
            const option = document.createElement('option');
            option.value = amenity;
            option.textContent = amenity;
            mobileAmenityFilter.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentValue && Array.from(mobileAmenityFilter.options).some(opt => opt.value === currentValue)) {
            mobileAmenityFilter.value = currentValue;
        }
    }
    
    // Sort listings before rendering (default: Area  Type  Name, all A-Z)
    const sortDropdown = document.getElementById('sortDropdown');
    let sortValue = 'default'; // Default to Area  Type  Name
    if (sortDropdown && sortDropdown.value) {
        sortValue = sortDropdown.value;
    } else if (sortDropdown) {
        // If dropdown exists but no value, set it to default
        sortDropdown.value = 'default';
    }
    
    // Sort the listings array based on current sort value
    const sortedListings = listings.slice().sort(function(a, b) {
        const aName = (a.name || '').trim().toLowerCase();
        const bName = (b.name || '').trim().toLowerCase();
        const aArea = (a.area || '').trim().toLowerCase();
        const bArea = (b.area || '').trim().toLowerCase();
        const aType = (a.type || '').trim().toLowerCase();
        const bType = (b.type || '').trim().toLowerCase();
        
        switch(sortValue) {
            case 'default':
                // Default sort: Area  Type  Name (all A-Z)
                const areaCompare = aArea.localeCompare(bArea);
                if (areaCompare !== 0) return areaCompare;
                const typeCompare = aType.localeCompare(bType);
                if (typeCompare !== 0) return typeCompare;
                return aName.localeCompare(bName);
            case 'name-asc':
                return aName.localeCompare(bName);
            case 'name-desc':
                return bName.localeCompare(aName);
            case 'area-asc':
                return aArea.localeCompare(bArea);
            case 'type-asc':
                return aType.localeCompare(bType);
            default:
                // Fallback to default sort: Area  Type  Name
                const areaCompareDefault = aArea.localeCompare(bArea);
                if (areaCompareDefault !== 0) return areaCompareDefault;
                const typeCompareDefault = aType.localeCompare(bType);
                if (typeCompareDefault !== 0) return typeCompareDefault;
                return aName.localeCompare(bName);
        }
    });
    
    // Update results count (show total filtered listings)
    const countEl = document.getElementById('previewResultsCount');
    if (countEl) {
        const totalCount = listingsToRender.length;
        countEl.textContent = totalCount + ' listing' + (totalCount !== 1 ? 's' : '');
    }
    
    // Update map markers (use all filtered listings for map, not just current page)
    updateMapMarkers(listingsToRender);
    
    // Render cards (using sorted listings)
    // Adjust index for pagination offset
    const indexOffset = appendMode ? (currentPage - 1) * ITEMS_PER_PAGE : 0;
    console.log(' About to render', sortedListings.length, 'cards', appendMode ? '(appending)' : '(new)');
    sortedListings.forEach(function(listing, localIndex) {
        const index = localIndex + indexOffset; // Use global index for animation stagger
        if (index < 3 || index >= sortedListings.length - 3) {
            console.log(` Rendering card ${index + 1}/${sortedListings.length}:`, listing.name);
        }
        // Use listing.slug if it exists and is not empty, otherwise generate from name
        const slug = (listing.slug && listing.slug.trim() !== '') 
            ? listing.slug.trim() 
            : listing.name.toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
        
        // Create card as a div (not a link) for flip functionality
        const card = document.createElement('div');
        card.className = 'flip-card';
        card.setAttribute('data-listing-id', listing.id);
        if (listing.category) {
            card.setAttribute('data-category', listing.category);
        }
        card.style.display = 'block';
        
        // Create inner wrapper for flip animation
        const inner = document.createElement('div');
        inner.className = 'flip-card-inner';
        
        // Handle card click to flip (not navigate)
        card.addEventListener('click', function(e) {
            // Don't flip if clicking on:
            // - Badge elements (type, area, featured)
            // - Scroll arrows
            // - Any element with onclick that filters
            // - Any element with data-type, data-area attributes
            // - Links or buttons in the back
            // - Address, phone, or website content areas
            const target = e.target;
            const isBadge = target.closest('.badge-type, .badge-area, .badge-featured, .badge');
            const isScrollArrow = target.closest('.scroll-arrow');
            const hasFilterOnClick = target.closest('[onclick*="filter"], [onclick*="Filter"]');
            const hasFilterData = target.closest('[data-type], [data-area]');
            const isLink = target.closest('a') || target.tagName === 'A';
            const isButton = target.closest('button') || target.tagName === 'BUTTON';
            const isCardInfo = target.closest('.card-info-item') || target.closest('.card-info-icon');
            
            if (isBadge || isScrollArrow || hasFilterOnClick || hasFilterData || isLink || isButton || isCardInfo) {
                // Let these elements handle their own clicks
                return;
            }
            
            // Prevent flip if clicking inside scrollable back content
            const backCard = target.closest('.flip-card-back');
            if (backCard && backCard.scrollHeight > backCard.clientHeight) {
                const scrollableContent = backCard.querySelector('div[style*="overflow-y: auto"]');
                if (scrollableContent && (target === scrollableContent || scrollableContent.contains(target))) {
                    return;
                }
            }
            
            // Close other flipped cards
            document.querySelectorAll('.flip-card.flipped').forEach(function(otherCard) {
                if (otherCard !== card) {
                    otherCard.classList.remove('flipped');
                }
            });
            
            // Toggle flip state
            const wasFlipped = card.classList.contains('flipped');
            card.classList.toggle('flipped');
            const isNowFlipped = card.classList.contains('flipped');
            
            // On mobile, scroll card into view when flipped
            if (isNowFlipped && !wasFlipped && window.innerWidth < 969) {
                setTimeout(function() {
                    card.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center',
                        inline: 'nearest'
                    });
                }, 100); // Small delay to allow flip animation to start
            }
        });
        
        const front = document.createElement('div');
        front.className = 'flip-card-front';
        
        // Create scrollable image container
        const imgContainer = document.createElement('div');
        imgContainer.className = 'card-front-image-scroll';
        imgContainer.style.cssText = 'position: relative; width: 100%; height: 0; padding-bottom: 100%; overflow-x: auto; overflow-y: hidden; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; scrollbar-width: none;';
        imgContainer.style.setProperty('-ms-overflow-style', 'none');
        if (listing.featured) {
            const featuredTag = document.createElement('span');
            featuredTag.className = 'badge-featured card-featured-tag';
            featuredTag.textContent = 'Featured';
            featuredTag.addEventListener('click', function(e) {
                filterByBadge(e, 'featured', 'true');
            });
            imgContainer.appendChild(featuredTag);
        }
        
        const imgWrapper = document.createElement('div');
        imgWrapper.style.cssText = 'position: absolute; top: 0; left: 0; width: auto; height: 100%; display: flex;';
        
        // Helper function to generate alt text for images
        const getImageAltText = function(imageDesc, listingName, imageNumber) {
            // Use image description if available (from ImageKit metadata)
            if (imageDesc && imageDesc.trim()) {
                return imageDesc.trim();
            }
            // Fall back to descriptive alt text using listing name
            return (listingName || 'Listing') + ' - Image ' + imageNumber;
        };
        
        // Add image1 if it exists
        if (listing.image1) {
            const img1 = document.createElement('img');
            img1.src = normalizeImageUrl(listing.image1, CARD_IMAGE_TRANSFORM);
            img1.loading = 'lazy';
            img1.decoding = 'async';
            img1.alt = getImageAltText(listing.image1Desc, listing.name, 1);
            img1.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 100%; aspect-ratio: 1 / 1; object-fit: cover; display: block; border-radius: 24px; flex-shrink: 0; scroll-snap-align: start;';
            img1.onerror = function() {
                this.src = FALLBACK_IMG;
            };
            imgWrapper.appendChild(img1);
        }
        
        // Add image2 if it exists
        if (listing.image2) {
            const img2 = document.createElement('img');
            img2.src = normalizeImageUrl(listing.image2, CARD_IMAGE_TRANSFORM);
            img2.loading = 'lazy';
            img2.decoding = 'async';
            img2.alt = getImageAltText(listing.image2Desc, listing.name, 2);
            img2.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 100%; aspect-ratio: 1 / 1; object-fit: cover; display: block; border-radius: 24px; flex-shrink: 0; scroll-snap-align: start;';
            img2.onerror = function() {
                this.src = FALLBACK_IMG;
            };
            imgWrapper.appendChild(img2);
        }
        if (listing.image3) {
            const img3 = document.createElement('img');
            img3.src = normalizeImageUrl(listing.image3, CARD_IMAGE_TRANSFORM);
            img3.loading = 'lazy';
            img3.decoding = 'async';
            img3.alt = getImageAltText(listing.image3Desc, listing.name, 3);
            img3.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 100%; aspect-ratio: 1 / 1; object-fit: cover; display: block; border-radius: 24px; flex-shrink: 0; scroll-snap-align: start;';
            img3.onerror = function() {
                this.src = FALLBACK_IMG;
            };
            imgWrapper.appendChild(img3);
        }
        
        // If no images, add fallback
        if (!listing.image1 && !listing.image2 && !listing.image3) {
            const img = document.createElement('img');
            img.src = FALLBACK_IMG;
            img.alt = (listing.name || 'Listing') + ' - No image available';
            img.style.cssText = 'position: relative; width: 100%; min-width: 100%; max-width: 100%; height: 100%; aspect-ratio: 1 / 1; object-fit: cover; display: block; border-radius: 24px; flex-shrink: 0; scroll-snap-align: start;';
            imgWrapper.appendChild(img);
        }
        
        // Set wrapper and image widths to accommodate all images side by side
        const imageCount = (listing.image1 ? 1 : 0) + (listing.image2 ? 1 : 0) + (listing.image3 ? 1 : 0);
        if (imageCount > 1) {
            // Wait for container to have dimensions, then set wrapper and image widths
            setTimeout(function() {
                const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                if (containerWidth > 0) {
                    imgWrapper.style.width = (containerWidth * imageCount) + 'px';
                    // Set each image to be exactly the container width
                    const images = imgWrapper.querySelectorAll('img');
                    images.forEach(function(img) {
                        img.style.width = containerWidth + 'px';
                        img.style.minWidth = containerWidth + 'px';
                        img.style.maxWidth = containerWidth + 'px';
                    });
                }
            }, 10);
        }
        
        imgContainer.appendChild(imgWrapper);
        front.appendChild(imgContainer);
        
        // Add scroll arrow if there are multiple images (append to front, position dynamically)
        if (imageCount > 1) {
            let currentIndex = 0;
            const totalImages = imageCount;
            
            // Right arrow (loops infinitely)
            const rightArrow = document.createElement('div');
            rightArrow.className = 'scroll-arrow scroll-arrow-right';
            
            rightArrow.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                currentIndex = (currentIndex + 1) % totalImages;
                // Get the container width at click time
                const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                imgContainer.scrollTo({ left: currentIndex * containerWidth, behavior: 'smooth' });
            });
            
            // Position arrow at center of image (which is square, so height = width)
            setTimeout(function() {
                const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
                if (containerWidth > 0) {
                    // Center vertically in the square image (half the width)
                    rightArrow.style.top = (containerWidth / 2) + 'px';
                    rightArrow.style.transform = 'translateY(-50%)';
                }
            }, 10);
            
            front.appendChild(rightArrow);
        }
        
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = 'padding: 20px 20px 20px 0; margin: 0;';
        // Fix encoding issues before displaying
        const fixedName = fixEncoding(listing.name);
        const fixedType = fixEncoding(listing.type);
        const fixedArea = fixEncoding(listing.area);
        const fixedDescription = fixEncoding(listing.description);
        // Use detailedDescription on back if available and not empty, otherwise fall back to description
        const hasDetailedDescription = listing.detailedDescription && listing.detailedDescription.trim().length > 0;
        // Remove line breaks from description for card back display (but keep them in raw data for Framer CMS)
        const removeLineBreaksForDisplay = (text) => {
            if (!text) return '';
            // Replace all types of line breaks with spaces, then collapse multiple spaces
            return text.replace(/\r\n/g, ' ').replace(/\n/g, ' ').replace(/\r/g, ' ').replace(/\s+/g, ' ').trim();
        };
        const backDescriptionText = hasDetailedDescription 
            ? removeLineBreaksForDisplay(fixEncoding(listing.detailedDescription))
            : removeLineBreaksForDisplay(fixedDescription);
        
        let badgesHtml = 
            '<span class="badge-type ' + getIconClass(listing.type, listing) + '" data-type="' + escapeHtml(listing.type) + '" onclick="event.preventDefault(); event.stopPropagation(); filterByBadge(event, \'type\', \'' + escapeHtml(listing.type) + '\'); return false;">' + escapeHtml(fixedType) + '</span>' +
            '<span class="badge-area" data-area="' + escapeHtml(listing.area) + '" onclick="event.preventDefault(); event.stopPropagation(); filterByBadge(event, \'area\', \'' + escapeHtml(listing.area) + '\'); return false;">' + escapeHtml(fixedArea) + '</span>';
        contentDiv.innerHTML = 
            '<h3 style="font-size: 18px; font-weight: 700; margin-bottom: 10px; color: var(--text-primary); line-height: 1.2;">' + escapeHtml(fixedName) + '</h3>' +
            '<div style="display: flex; gap: 8px; margin-bottom: 10px; align-items: center;">' +
            badgesHtml +
            '</div>' +
            '<p style="font-size: 14px; color: var(--text-secondary); line-height: 1.5;">' + escapeHtml(fixedDescription) + '</p>';
        front.appendChild(contentDiv);
        
        // Create card back with full details
        const back = document.createElement('div');
        back.className = 'flip-card-back';
        
        // Add close button (X icon) in top right corner
        const closeBtn = document.createElement('button');
        closeBtn.className = 'card-close-btn';
        closeBtn.style.cssText = 'position: absolute; top: 12px; right: 12px; width: 28px; height: 28px; border: none; background: rgba(255, 255, 255, 0.9); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 10; transition: background 0.2s ease; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);';
        closeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="color: #6b7280;"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
        closeBtn.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            card.classList.remove('flipped');
        };
        closeBtn.onmouseenter = function() {
            this.style.background = 'rgba(255, 255, 255, 1)';
        };
        closeBtn.onmouseleave = function() {
            this.style.background = 'rgba(255, 255, 255, 0.9)';
        };
        
        // Build back content
        const backContent = document.createElement('div');
        backContent.style.cssText = 'padding: 20px; height: 100%; display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; position: relative;';
        
        // Title only (no badges on back) - clickable link
        const backTitle = document.createElement('a');
        backTitle.href = CMS_BASE_URL + '/explore/' + slug;
        backTitle.target = '_parent';
        backTitle.style.cssText = 'font-size: 13px; font-weight: 500; margin-bottom: 15px; color: #a1a1aa; line-height: 1.2; text-transform: uppercase; letter-spacing: 1px; orphans: 2; widows: 2; text-align: left; text-decoration: none; display: block; cursor: pointer; max-width: 90%;';
        backTitle.textContent = fixedName;
        backTitle.onclick = function(e) {
            e.stopPropagation(); // Prevent card flip
        };
        backContent.appendChild(backTitle);
        
        // Full description with fade-out gradient (use detailedDescription if available and not empty, otherwise fall back to description)
        if (backDescriptionText) {
            const descWrapper = document.createElement('div');
            descWrapper.className = 'desc-wrapper';
            descWrapper.style.cssText = 'position: relative; margin-bottom: 15px;';
            
            const backDesc = document.createElement('a');
            backDesc.className = 'back-description';
            backDesc.href = CMS_BASE_URL + '/explore/' + slug;
            backDesc.target = '_parent';
            backDesc.style.cssText = 'font-size: 14px; color: #000000; line-height: 1.4; margin: 0; display: -webkit-box; -webkit-line-clamp: 7; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; text-decoration: none; cursor: pointer;';
            // Use plain text (line breaks already removed in backDescriptionText)
            backDesc.textContent = backDescriptionText;
            backDesc.onclick = function(e) {
                e.stopPropagation(); // Prevent card flip
            };
            
            // Add gradient fade overlay (will be shown only if text is truncated)
            const descFade = document.createElement('div');
            descFade.className = 'desc-fade-overlay';
            descFade.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; height: 20px; background: linear-gradient(to bottom, transparent, var(--card-bg, #ffffff)); pointer-events: none; z-index: 1; display: none;';
            
            descWrapper.appendChild(backDesc);
            descWrapper.appendChild(descFade);
            backContent.appendChild(descWrapper);
            
            // Check if description is truncated and show fade if needed
            setTimeout(function() {
                if (backDesc.scrollHeight > backDesc.offsetHeight) {
                    descFade.style.display = 'block';
                }
            }, 100);
        }
        
        // Contributor and created/updated metadata are intentionally hidden on card backs as of November 2025.
        // If needed again, restore the author and date info blocks that previously rendered here.
        
        // Address
        if (listing.address) {
            const addressDiv = document.createElement('div');
            addressDiv.className = 'card-info-item';
            addressDiv.style.cssText = 'display: flex; align-items: flex-start; gap: 10px; margin-bottom: 1px;';
            addressDiv.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card flip
            });
            const googleMapsUrl = 'https://www.google.com/maps/search/?api=1&query=' + encodeURIComponent(listing.address);
            addressDiv.innerHTML = 
                '<div class="card-info-icon" style="width: 32px; height: 32px; flex-shrink: 0; display: flex; align-items: flex-start; justify-content: center; padding-top: 6px;">' +
                '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px; stroke: #D65052;">' +
                '<path stroke-linecap="round" stroke-linejoin="round" d="M15 10.5a3 3 0 11-6 0 3 3 0 016 0z" />' +
                '<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z" />' +
                '</svg>' +
                '</div>' +
                '<div style="flex: 1; padding-top: 6px; line-height: 0.85;">' +
                '<a href="' + googleMapsUrl + '" style="font-size: 12px; color: var(--text-primary); text-decoration: none; line-height: 0.85;" target="_blank" rel="noopener noreferrer">' + escapeHtml(fixEncoding(listing.address)) + '</a>' +
                '</div>';
            backContent.appendChild(addressDiv);
        }
        
        // Phone
        if (listing.phone) {
            const phoneDiv = document.createElement('div');
            phoneDiv.className = 'card-info-item';
            phoneDiv.style.cssText = 'display: flex; align-items: flex-start; gap: 10px; margin-bottom: 1px;';
            phoneDiv.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card flip
            });
            phoneDiv.innerHTML = 
                '<div class="card-info-icon" style="width: 32px; height: 32px; flex-shrink: 0; display: flex; align-items: flex-start; justify-content: center; padding-top: 6px;">' +
                '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px; stroke: var(--theme-primary);">' +
                '<path stroke-linecap="round" stroke-linejoin="round" d="M2.25 6.75c0 8.284 6.716 15 15 15h2.25a2.25 2.25 0 002.25-2.25v-1.372c0-.516-.351-.966-.852-1.091l-4.423-1.106c-.44-.11-.902.055-1.173.417l-.97 1.293c-.282.376-.769.542-1.21.38a12.035 12.035 0 01-7.143-7.143c-.162-.441.004-.928.38-1.21l1.293-.97c.363-.271.527-.734.417-1.173L6.963 3.102a1.125 1.125 0 00-1.091-.852H4.5A2.25 2.25 0 002.25 4.5v2.25z" />' +
                '</svg>' +
                '</div>' +
                '<div style="flex: 1; padding-top: 6px; line-height: 0.85;">' +
                '<a href="tel:' + escapeHtml(listing.phone) + '" style="font-size: 12px; color: var(--text-primary); text-decoration: none; line-height: 0.85;" target="_parent">' + escapeHtml(fixEncoding(listing.phone)) + '</a>' +
                '</div>';
            backContent.appendChild(phoneDiv);
        }
        
        // Website
        if (listing.website) {
            // Clean website URL for display (remove http://, https://, and www.)
            let displayWebsite = listing.website;
            displayWebsite = displayWebsite.replace(/^https?:\/\//i, ''); // Remove http:// or https://
            displayWebsite = displayWebsite.replace(/^www\./i, ''); // Remove www.
            
            const websiteDiv = document.createElement('div');
            websiteDiv.className = 'card-info-item';
            websiteDiv.style.cssText = 'display: flex; align-items: flex-start; gap: 10px; margin-bottom: 1px;';
            websiteDiv.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card flip
            });
            websiteDiv.innerHTML = 
                '<div class="card-info-icon" style="width: 32px; height: 32px; flex-shrink: 0; display: flex; align-items: flex-start; justify-content: center; padding-top: 6px;">' +
                '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px; stroke: #3b82f6;">' +
                '<path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 008.716-6.747M12 21a9.004 9.004 0 01-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 017.843 4.582M12 3a8.997 8.997 0 00-7.843 4.582m15.686 0A11.953 11.953 0 0112 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0121 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0112 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 013 12c0-1.605.42-3.113 1.157-4.418" />' +
                '</svg>' +
                '</div>' +
                '<div style="flex: 1; padding-top: 6px; line-height: 0.85;">' +
                '<a href="' + escapeHtml(listing.website) + '" style="font-size: 12px; color: var(--text-primary); text-decoration: none; word-break: break-all; line-height: 0.85;" target="_blank" rel="noopener noreferrer">' + escapeHtml(fixEncoding(displayWebsite)) + '</a>' +
                '</div>';
            backContent.appendChild(websiteDiv);
        }
        
        // Amenities
        if (listing.amenities && listing.amenities.length > 0) {
            const amenitiesDiv = document.createElement('div');
            amenitiesDiv.style.cssText = 'margin-top: 12px; margin-bottom: 15px;';
            
            // Calculate approximate height for 3 full rows, then 4th row shows "more"
            // Each row is approximately: font-size 12px * line-height 1.2 + padding 4px = ~18px
            // 3 full rows = ~54px, 4th row (partial) = ~72px, add buffer = 80px
            const maxHeight = 80;
            
            const amenitiesWrapper = document.createElement('div');
            amenitiesWrapper.className = 'amenities-wrapper';
            amenitiesWrapper.style.cssText = 'position: relative;';
            
            const amenitiesContainer = document.createElement('div');
            amenitiesContainer.className = 'amenities-container';
            amenitiesContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 6px; position: relative; z-index: 2;';
            
            // Add gradient fade overlay for amenities (will be shown when truncated)
            const amenitiesFade = document.createElement('div');
            amenitiesFade.className = 'amenities-fade-overlay';
            amenitiesFade.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; height: 20px; background: linear-gradient(to bottom, transparent, var(--card-bg, #ffffff)); pointer-events: none; z-index: 3; display: none;';
            
            // Add all amenities
            listing.amenities.forEach(function(amenity) {
                const amenitySpan = document.createElement('span');
                amenitySpan.className = 'amenity';
                amenitySpan.style.cssText = 'font-size: 12px; padding: 2px 6px; background: #f3f4f6; color: var(--text-primary); border-radius: 6px; display: inline-block; margin: 0; line-height: 1.2; cursor: pointer;';
                amenitySpan.textContent = fixEncoding(amenity);
                amenitySpan.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    filterByAmenity(e, amenity);
                    return false;
                };
                amenitiesContainer.appendChild(amenitySpan);
            });
            
            // Check if content actually overflows and apply max-height only if needed
            setTimeout(function() {
                // First check if content naturally exceeds 3 full rows plus 4th row for "more" (80px)
                const naturalHeight = amenitiesContainer.scrollHeight;
                // Allow 3 full rows (~54px) plus partial 4th row for "more" text
                const threeRowsHeight = 54;
                if (naturalHeight > threeRowsHeight) {
                    // Apply max-height to allow 3 full rows plus 4th row for "more"
                    amenitiesContainer.style.maxHeight = maxHeight + 'px';
                    amenitiesContainer.style.overflow = 'hidden';
                    
                    // Count visible amenities - allow 3 full rows, then show "more" on 4th
                    const amenitySpans = amenitiesContainer.querySelectorAll('.amenity');
                    let hiddenCount = 0;
                    
                    // Check each amenity to see if it fits within 3 full rows
                    amenitySpans.forEach(function(span) {
                        const rect = span.getBoundingClientRect();
                        const containerRect = amenitiesContainer.getBoundingClientRect();
                        const relativeTop = rect.top - containerRect.top;
                        
                        // If amenity starts below 3 full rows (~54px), hide it
                        if (relativeTop >= threeRowsHeight) {
                            span.style.display = 'none';
                            hiddenCount++;
                        }
                    });
                    
                    // Add "more" indicator if there are hidden amenities
                    if (hiddenCount > 0) {
                        const moreSpan = document.createElement('a');
                        moreSpan.className = 'amenity amenity-more';
                        moreSpan.href = CMS_BASE_URL + '/explore/' + slug;
                        moreSpan.target = '_parent';
                        moreSpan.style.cssText = 'font-size: 12px; padding: 2px 6px; background: #f3f4f6; color: var(--text-primary); border-radius: 6px; display: inline-block; margin: 0; line-height: 1.2; cursor: pointer; font-weight: 600; text-decoration: none;';
                        moreSpan.textContent = '+ ' + hiddenCount + ' more';
                        moreSpan.onclick = function(e) {
                            e.stopPropagation(); // Prevent card flip, but allow navigation
                            // Don't prevent default - let the link navigate
                        };
                        amenitiesContainer.appendChild(moreSpan);
                    }
                    
                    // Show fade overlay only when content is actually truncated
                    if (hiddenCount > 0) {
                        amenitiesFade.style.display = 'block';
                    } else {
                        // No hidden amenities, hide fade
                        amenitiesFade.style.display = 'none';
                    }
                } else {
                    // Content fits naturally, no need for max-height or fade
                    amenitiesFade.style.display = 'none';
                }
            }, 50);
            
            amenitiesWrapper.appendChild(amenitiesContainer);
            amenitiesWrapper.appendChild(amenitiesFade);
            amenitiesDiv.appendChild(amenitiesWrapper);
            backContent.appendChild(amenitiesDiv);
        }
        
        // Remove any contributor or created/updated info rows if they slipped through from cached markup
        Array.from(backContent.querySelectorAll('.card-info-item')).forEach(function(item) {
            const text = (item.textContent || '').toLowerCase();
            if (text.includes('contributed by') || text.includes('created ') || text.includes('updated ')) {
                item.style.display = 'none';
            }
        });
        
        // Link to full page
        const viewLink = document.createElement('a');
        viewLink.href = CMS_BASE_URL + '/explore/' + slug;
        viewLink.target = '_parent';
        viewLink.style.cssText = 'display: inline-block; margin-top: auto; padding: 12px 20px; background: #BBC236; color: white; text-decoration: none; border-radius: 50px; text-align: center; font-size: 14px; font-weight: 500; position: relative; z-index: 1;';
        viewLink.textContent = 'View Details';
        backContent.appendChild(viewLink);
        
        back.appendChild(backContent);
        back.appendChild(closeBtn);
        
        // Add front and back to inner, then inner to card
        inner.appendChild(front);
        inner.appendChild(back);
        card.appendChild(inner);
        grid.appendChild(card);
        
        // Add staggered fade-in animation for smooth loading
        // Use requestAnimationFrame to ensure DOM is ready
        requestAnimationFrame(function() {
            setTimeout(function() {
                card.classList.add('card-loaded');
            }, (index % 20) * 30); // Stagger by 30ms per card, max 20 cards at a time
        });
        
        // Adjust description line-clamp on back based on title height and card size
        setTimeout(function() {
            // Title is now an anchor tag, not h3
            const backTitle = backContent.querySelector('a[href*="/explore/"]');
            const backDesc = backContent.querySelector('.back-description');
            if (backTitle && backDesc && backTitle === backContent.firstElementChild) {
                const titleHeight = backTitle.offsetHeight;
                const titleLineHeight = parseFloat(window.getComputedStyle(backTitle).lineHeight) || 1.2 * 18;
                const isTitleSingleLine = titleHeight <= titleLineHeight * 1.5;
                
                // Get card width to adjust for smaller cards
                const cardWidth = card.offsetWidth;
                let maxLines = isTitleSingleLine ? 7 : 6;
                
                // Reduce lines for smaller cards
                if (cardWidth < 200) {
                    maxLines = isTitleSingleLine ? 4 : 3;
                } else if (cardWidth < 250) {
                    maxLines = isTitleSingleLine ? 5 : 4;
                } else if (cardWidth < 300) {
                    maxLines = isTitleSingleLine ? 6 : 5;
                }
                
                backDesc.style.webkitLineClamp = maxLines;
            }
        }, 100);
    });
    
            // Set up Intersection Observer for smooth scroll animations and infinite scroll
            if (typeof IntersectionObserver !== 'undefined') {
                const observerOptions = {
                    root: null,
                    rootMargin: '50px',
                    threshold: 0.1
                };
                
                const cardObserver = new IntersectionObserver(function(entries) {
                    entries.forEach(function(entry) {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('card-visible');
                            cardObserver.unobserve(entry.target);
                        }
                    });
                }, observerOptions);
                
                // Observe all cards for scroll animations
                const allCards = grid.querySelectorAll('.flip-card');
                allCards.forEach(function(card) {
                    cardObserver.observe(card);
                });
                
                // Infinite scroll: detect when user scrolls near bottom
                if (!appendMode && hasMoreItems && !isLoadingMore) {
                    // Remove existing sentinel if any
                    const existingSentinel = document.getElementById('infinite-scroll-sentinel');
                    if (existingSentinel) {
                        existingSentinel.remove();
                    }
                    
                    // Create a sentinel element at the bottom to detect when user scrolls to it
                    const sentinel = document.createElement('div');
                    sentinel.id = 'infinite-scroll-sentinel';
                    sentinel.style.cssText = 'height: 100px; width: 100%;';
                    grid.appendChild(sentinel);
                    
                    const scrollObserver = new IntersectionObserver(function(entries) {
                        entries.forEach(function(entry) {
                            if (entry.isIntersecting && hasMoreItems && !isLoadingMore) {
                                isLoadingMore = true;
                                currentPage++;
                                console.log(' Loading more items, page:', currentPage);
                                renderPreview(null, true); // Append mode
                            }
                        });
                    }, { root: null, rootMargin: '200px', threshold: 0.1 });
                    
                    scrollObserver.observe(sentinel);
                }
            }
            
            // Update hasMoreItems flag
            const totalRendered = (currentPage * ITEMS_PER_PAGE);
            hasMoreItems = listingsToRender.length > totalRendered;
            isLoadingMore = false;
    
            // Report content height to parent (for Framer embed)
            // Wait for images and layout to settle
            setTimeout(function() {
                reportContentHeight();
                // Report again after images load (only once, not multiple times)
                setTimeout(function() {
                    reportContentHeight();
                    // Reset render flag after height is reported
                    isRendering = false;
                }, 500);
            }, 200);
            } // End renderCardsAfterGridClear function
    
    // Adjust title sizes based on actual card width
    function adjustTitleSizes() {
        const cards = document.querySelectorAll('.flip-card');
        cards.forEach(function(card) {
            const title = card.querySelector('.flip-card-front h3');
            if (title) {
                const cardWidth = card.offsetWidth;
                let fontSize = 16; // Base size for smallest cards
                
                if (cardWidth >= 350) {
                    fontSize = 22;
                } else if (cardWidth >= 300) {
                    fontSize = 20;
                } else if (cardWidth >= 260) {
                    fontSize = 18;
                } else if (cardWidth >= 200) {
                    fontSize = 17;
                }
                
                title.style.fontSize = fontSize + 'px';
                
                // Check if title is single line and add class for description line count
                setTimeout(function() {
                    const titleHeight = title.offsetHeight;
                    const lineHeight = parseFloat(window.getComputedStyle(title).lineHeight) || 1.2 * fontSize;
                    const isSingleLine = titleHeight <= lineHeight * 1.5; // Allow small margin for rounding
                    
                    if (isSingleLine) {
                        card.classList.add('title-single-line');
                    } else {
                        card.classList.remove('title-single-line');
                    }
                }, 10);
            }
        });
    }
    
    // Adjust description line-clamp on card backs based on title height and card size
    function adjustBackDescriptions() {
        const cards = document.querySelectorAll('.flip-card');
        cards.forEach(function(card) {
            const back = card.querySelector('.flip-card-back');
            if (back) {
                const backContent = back.querySelector('div[style*="display: flex"]');
                if (backContent) {
                    // Title is now an anchor tag, not h3
                    const backTitle = backContent.querySelector('a[href*="/explore/"]');
                    const backDesc = backContent.querySelector('.back-description');
                    const descFade = backContent.querySelector('.desc-fade-overlay');
                    if (backTitle && backDesc && backTitle === backContent.firstElementChild) {
                        const titleHeight = backTitle.offsetHeight;
                        const titleLineHeight = parseFloat(window.getComputedStyle(backTitle).lineHeight) || 1.2 * 18;
                        const isTitleSingleLine = titleHeight <= titleLineHeight * 1.5;
                        
                        // Get card width to adjust for smaller cards
                        const cardWidth = card.offsetWidth;
                        let maxLines = isTitleSingleLine ? 7 : 6;
                        
                        // Reduce lines for smaller cards
                        if (cardWidth < 200) {
                            maxLines = isTitleSingleLine ? 4 : 3;
                        } else if (cardWidth < 250) {
                            maxLines = isTitleSingleLine ? 5 : 4;
                        } else if (cardWidth < 300) {
                            maxLines = isTitleSingleLine ? 6 : 5;
                        }
                        
                        backDesc.style.webkitLineClamp = maxLines;
                        
                        // Show/hide fade overlay based on whether text is truncated
                        if (descFade) {
                            setTimeout(function() {
                                if (backDesc.scrollHeight > backDesc.offsetHeight) {
                                    descFade.style.display = 'block';
                                } else {
                                    descFade.style.display = 'none';
                                }
                            }, 50);
                        }
                    }
                }
            }
        });
    }
    
    // Adjust all back text sizes based on card width
    function adjustBackTextSizes() {
        const cards = document.querySelectorAll('.flip-card');
        cards.forEach(function(card) {
            const back = card.querySelector('.flip-card-back');
            if (back) {
                const backContent = back.querySelector('div[style*="display: flex"]');
                if (backContent) {
                    const cardWidth = card.offsetWidth;
                    
                    // Calculate scale factor based on card width
                    // Base sizes for smallest cards (< 200px)
                    let titleSize = 13;
                    let descSize = 12;
                    let infoSize = 11;
                    let amenitySize = 12;
                    let buttonSize = 14;
                    
                    // Scale up for larger cards
                    if (cardWidth >= 350) {
                        titleSize = 17;
                        descSize = 15;
                        infoSize = 14;
                        amenitySize = 16;
                        buttonSize = 16;
                    } else if (cardWidth >= 300) {
                        titleSize = 16;
                        descSize = 14;
                        infoSize = 13;
                        amenitySize = 15;
                        buttonSize = 15;
                    } else if (cardWidth >= 260) {
                        titleSize = 15;
                        descSize = 13;
                        infoSize = 12;
                        amenitySize = 14;
                        buttonSize = 15;
                    } else if (cardWidth >= 200) {
                        titleSize = 14;
                        descSize = 12.5;
                        infoSize = 11.5;
                        amenitySize = 13;
                        buttonSize = 14;
                    }
                    
                    // Calculate proportional line heights based on font sizes
                    const titleLineHeight = 1.2; // Keep consistent for title
                    const descLineHeight = 1.4; // Proportional to description size
                    const infoLineHeight = 0.85; // Keep tight for address/phone/web
                    const amenityLineHeight = 1.2; // Keep consistent for amenities
                    
                    // Apply sizes to back elements
                    const backTitle = backContent.querySelector('a[href*="/explore/"]:first-child');
                    if (backTitle) {
                        backTitle.style.fontSize = titleSize + 'px';
                        backTitle.style.lineHeight = titleLineHeight;
                    }
                    
                    const backDesc = backContent.querySelector('.back-description');
                    if (backDesc) {
                        backDesc.style.fontSize = descSize + 'px';
                        backDesc.style.lineHeight = descLineHeight;
                    }
                    
                    // Address, phone, website
                    const infoItems = backContent.querySelectorAll('.card-info-item a');
                    infoItems.forEach(function(item) {
                        item.style.fontSize = infoSize + 'px';
                        item.style.lineHeight = infoLineHeight;
                    });
                    
                    // Amenities
                    const amenities = backContent.querySelectorAll('.amenity');
                    amenities.forEach(function(amenity) {
                        amenity.style.fontSize = amenitySize + 'px';
                        amenity.style.lineHeight = amenityLineHeight;
                    });
                    
                    // View Details button
                    const viewButton = backContent.querySelector('a[href*="/explore/"]:last-child');
                    if (viewButton && viewButton.textContent === 'View Details') {
                        viewButton.style.fontSize = buttonSize + 'px';
                    }
                }
            }
        });
    }
    
    // Adjust sizes after render
    setTimeout(function() {
        adjustTitleSizes();
        adjustBackDescriptions();
        adjustBackTextSizes();
    }, 100);
    
    // Recalculate on window resize (debounced) - only trigger on actual resize, not scroll
    if (!window.titleSizeResizeHandler) {
        let resizeTimeout;
        let lastWindowWidth = window.innerWidth;
        let lastWindowHeight = window.innerHeight;
        window.titleSizeResizeHandler = function() {
            // Only recalculate if window dimensions actually changed
            const currentWidth = window.innerWidth;
            const currentHeight = window.innerHeight;
            if (currentWidth === lastWindowWidth && currentHeight === lastWindowHeight) {
                return; // No actual resize, skip recalculation
            }
            lastWindowWidth = currentWidth;
            lastWindowHeight = currentHeight;
            
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                adjustTitleSizes();
                adjustImageWidths();
                adjustBackDescriptions();
                adjustBackTextSizes();
            }, 200);
        };
        window.addEventListener('resize', window.titleSizeResizeHandler);
        // Store references to allow forcing recalculation
        window._forceResizeRecalc = function() {
            // Temporarily modify lastWindowWidth/Height to force handler to run
            lastWindowWidth = window.innerWidth - 1;
            lastWindowHeight = window.innerHeight - 1;
            window.titleSizeResizeHandler();
        };
        }
    } catch (e) {
        console.error('Error in renderPreview:', e);
        isRendering = false;
    }
    }, isInIframe ? 100 : 0); // Longer debounce in iframe to prevent loops
}

// Recalculate image widths for all cards with multiple images
function adjustImageWidths(force) {
    const allCards = document.querySelectorAll('.flip-card');
    
    allCards.forEach(function(card) {
        const imgContainer = card.querySelector('.card-front-image-scroll');
        if (!imgContainer) return;
        
        const imgWrapper = imgContainer.querySelector('div');
        if (!imgWrapper) return;
        
        const images = imgWrapper.querySelectorAll('img');
        const imageCount = images.length;
        
        if (imageCount > 1) {
            const containerWidth = imgContainer.offsetWidth || imgContainer.clientWidth;
            if (containerWidth > 0) {
                const expectedWrapperWidth = containerWidth * imageCount;
                const expectedImageWidth = containerWidth;
                
                // Only update if dimensions have actually changed, or if forced
                const currentWrapperWidth = parseFloat(imgWrapper.style.width) || 0;
                const firstImg = images[0];
                const currentImageWidth = parseFloat(firstImg.style.width) || 0;
                
                if (force || Math.abs(currentWrapperWidth - expectedWrapperWidth) > 1 || 
                    Math.abs(currentImageWidth - expectedImageWidth) > 1) {
                    // Update wrapper width
                    imgWrapper.style.width = expectedWrapperWidth + 'px';
                    
                    // Update each image width
                    images.forEach(function(img) {
                        img.style.width = expectedImageWidth + 'px';
                        img.style.minWidth = expectedImageWidth + 'px';
                        img.style.maxWidth = expectedImageWidth + 'px';
                    });
                    
                    // Update arrow position
                    const arrow = card.querySelector('.scroll-arrow');
                    if (arrow) {
                        arrow.style.top = (containerWidth / 2) + 'px';
                        arrow.style.transform = 'translateY(-50%)';
                    }
                }
            }
        }
    });
}

// Mobile filter handlers
function handleMobileCategoryFilter() {
    // Clear the "explicitly cleared" flag FIRST, before any filter logic
    filtersExplicitlyCleared = false;
    try {
        sessionStorage.removeItem('filtersExplicitlyCleared');
    } catch (e) {
        // sessionStorage might not be available
    }
    
    const mobileCategoryFilter = document.getElementById('mobileCategoryFilter');
    const value = mobileCategoryFilter ? mobileCategoryFilter.value : '';
    
    // Update icon based on selected category
    updateMobileCategoryIcon(value);
    
    if (value) {
        // Set category filter
        currentCategoryFilter = value.toLowerCase();
        currentTypeFilter = []; // Clear type filter when category is selected
        
        // Get types for this category
        const categoryData = TYPE_CATEGORIES[currentCategoryFilter];
        if (categoryData && categoryData.types) {
            currentTypeFilter = categoryData.types.slice();
        }
    } else {
        // Clear category filter
        currentCategoryFilter = null;
        currentTypeFilter = [];
    }
    
    // Clear type filter dropdown
    const mobileTypeFilter = document.getElementById('mobileTypeFilter');
    if (mobileTypeFilter) {
        mobileTypeFilter.value = '';
    }
    
    // Update sidebar buttons
    document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
        btn.classList.remove('active');
        if (value && btn.dataset.category === currentCategoryFilter) {
            btn.classList.add('active');
        } else if (!value && btn.dataset.type === '' && !btn.dataset.category) {
            btn.classList.add('active');
        }
    });
    
    filterPreview();
}

function populateMobileCategoryFilter() {
    const mobileCategoryFilter = document.getElementById('mobileCategoryFilter');
    if (!mobileCategoryFilter) return;
    
    // Clear existing options except "All"
    mobileCategoryFilter.innerHTML = '<option value="">All</option>';
    
    // Get categories from TYPE_CATEGORIES, sorted by name
    const categories = Object.keys(TYPE_CATEGORIES)
        .map(function(key) {
            return {
                key: key,
                name: TYPE_CATEGORIES[key].name || key
            };
        })
        .sort(function(a, b) {
            return a.name.localeCompare(b.name);
        });
    
    // Add each category as an option
    categories.forEach(function(category) {
        const option = document.createElement('option');
        option.value = category.key;
        option.textContent = category.name;
        mobileCategoryFilter.appendChild(option);
    });
    
    // Update icon if a category is already selected
    if (currentCategoryFilter) {
        mobileCategoryFilter.value = currentCategoryFilter;
        updateMobileCategoryIcon(currentCategoryFilter);
    } else {
        updateMobileCategoryIcon('');
    }
}

function updateMobileCategoryIcon(categoryKey) {
    const categoryGroup = document.querySelector('.mobile-category-filter-group');
    const categorySelect = document.getElementById('mobileCategoryFilter');
    if (!categoryGroup || !categorySelect) return;
    
    const iconUrl = categoryKey ? `icons/${categoryKey.toLowerCase()}.svg` : 'icons/all-types.svg';
    
    // Remove all category classes from both select and group
    categorySelect.classList.remove('category-outdoor', 'category-stay', 'category-taste', 'category-culture', 'category-experience', 'category-community');
    categoryGroup.classList.remove('category-outdoor', 'category-stay', 'category-taste', 'category-culture', 'category-experience', 'category-community');
    
    // Add class based on selected category to both elements
    if (categoryKey) {
        const categoryClass = 'category-' + categoryKey.toLowerCase();
        categorySelect.classList.add(categoryClass);
        categoryGroup.classList.add(categoryClass);
    }
    
    // Update ::before pseudo-element background using a style tag
    let style = document.getElementById('mobile-category-icon-style');
    if (!style) {
        style = document.createElement('style');
        style.id = 'mobile-category-icon-style';
        document.head.appendChild(style);
    }
    style.textContent = `.mobile-filter-bar > .mobile-category-filter-group::before { background-image: url('${iconUrl}'); }`;
}

function handleMobileTypeFilter() {
    // Clear the "explicitly cleared" flag FIRST, before any filter logic
    filtersExplicitlyCleared = false;
    try {
        sessionStorage.removeItem('filtersExplicitlyCleared');
    } catch (e) {
        // sessionStorage might not be available
    }
    
    const mobileTypeFilter = document.getElementById('mobileTypeFilter');
    const value = mobileTypeFilter ? mobileTypeFilter.value : '';
    // Mobile dropdown is single-select, so set as single-item array or empty
    currentTypeFilter = value ? [value] : [];
    
    // Determine which category this type belongs to
    if (value) {
        const categoryForType = getCategoryForType(value, null);
        currentCategoryFilter = categoryForType;
        
        // Update category dropdown to match
        const mobileCategoryFilter = document.getElementById('mobileCategoryFilter');
        if (mobileCategoryFilter && currentCategoryFilter) {
            mobileCategoryFilter.value = currentCategoryFilter;
            updateMobileCategoryIcon(currentCategoryFilter);
        }
    } else {
        currentCategoryFilter = null;
        // Clear category dropdown
        const mobileCategoryFilter = document.getElementById('mobileCategoryFilter');
        if (mobileCategoryFilter) {
            mobileCategoryFilter.value = '';
            updateMobileCategoryIcon('');
        }
    }
    
    // Update sidebar buttons - activate the category button if it exists, or "All Types" if no category
    document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
        btn.classList.remove('active');
        if (value && currentCategoryFilter && btn.dataset.category === currentCategoryFilter) {
            btn.classList.add('active');
        } else if (!value && btn.dataset.type === '' && !btn.dataset.category) {
            btn.classList.add('active');
        }
    });
    
    filterPreview();
}

function handleTypeFilter() {
    // Clear the "explicitly cleared" flag FIRST, before any filter logic
    filtersExplicitlyCleared = false;
    try {
        sessionStorage.removeItem('filtersExplicitlyCleared');
    } catch (e) {
        // sessionStorage might not be available
    }
    
    // Get selected type from dropdown
    const typeFilter = document.getElementById('previewTypeFilter');
    const mobileTypeFilter = document.getElementById('mobileTypeFilter');
    const selectedType = (typeFilter ? typeFilter.value : '') || (mobileTypeFilter ? mobileTypeFilter.value : '');
    
    // Sync mobile and desktop dropdowns
    if (typeFilter && mobileTypeFilter) {
        if (document.activeElement === typeFilter) {
            mobileTypeFilter.value = typeFilter.value;
        } else if (document.activeElement === mobileTypeFilter) {
            typeFilter.value = mobileTypeFilter.value;
        }
    }
    
    if (selectedType) {
        // Set type filter - do NOT set category filter, let type filter work independently
        currentTypeFilter = [selectedType];
        currentCategoryFilter = null; // Clear category filter so type filter works independently
        
        // Update type filter buttons - deactivate all category buttons, keep "All Types" active
        document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
            btn.classList.remove('active');
            if (btn.dataset.type === '' && !btn.dataset.category) {
                btn.classList.add('active');
            }
        });
    } else {
        // No type selected - clear filters
        currentTypeFilter = [];
        currentCategoryFilter = null;
        
        // Activate "All Types" button
        document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
            btn.classList.remove('active');
            if (btn.dataset.type === '' && !btn.dataset.category) {
                btn.classList.add('active');
            }
        });
    }
    
    filterPreview();
}


function handleMobileAreaFilter() {
    const mobileAreaFilter = document.getElementById('mobileAreaFilter');
    const areaFilter = document.getElementById('previewAreaFilter');
    const value = mobileAreaFilter ? mobileAreaFilter.value : '';
    
    if (areaFilter) areaFilter.value = value;
    filterPreview();
}

function handleMobileAmenityFilter() {
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    const amenityFilter = document.getElementById('previewAmenityFilter');
    const value = mobileAmenityFilter ? mobileAmenityFilter.value : '';
    
    if (amenityFilter) amenityFilter.value = value;
    filterPreview();
}

// Sync mobile filters when sidebar filters change
function syncMobileFilters() {
    const mobileTypeFilter = document.getElementById('mobileTypeFilter');
    const mobileAreaFilter = document.getElementById('mobileAreaFilter');
    const mobileAmenityFilter = document.getElementById('mobileAmenityFilter');
    const typeFilter = document.getElementById('previewTypeFilter');
    const areaFilter = document.getElementById('previewAreaFilter');
    const amenityFilter = document.getElementById('previewAmenityFilter');
    
    // Sync type filters
    if (mobileTypeFilter && typeFilter) {
        mobileTypeFilter.value = typeFilter.value || '';
    } else if (mobileTypeFilter) {
        // For mobile dropdown, show first selected type or empty
        mobileTypeFilter.value = currentTypeFilter.length > 0 ? currentTypeFilter[0] : '';
    }
    if (mobileAreaFilter && areaFilter) mobileAreaFilter.value = areaFilter.value || '';
    if (mobileAmenityFilter && amenityFilter) mobileAmenityFilter.value = amenityFilter.value || '';
}

// Map functionality
let map = null;
let markers = [];
let markerCluster = null;
let mapVisible = true;
let infoWindow = null;

function initMap() {
    // Check if Google Maps API is loaded
    if (typeof google === 'undefined' || typeof google.maps === 'undefined' || typeof google.maps.Map === 'undefined') {
        console.log('Google Maps API not loaded yet, retrying...');
        // Retry after a short delay
        setTimeout(initMap, 100);
        return;
    }
    
    if (!map) {
        try {
            // Initialize Google Map centered on Nelson County, VA
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 37.8, lng: -79.0 },
                zoom: 10,
                mapTypeControl: false,
                zoomControl: true,
            zoomControlOptions: {
                position: google.maps.ControlPosition ? google.maps.ControlPosition.RIGHT_TOP : 1
            },
            streetViewControl: false,
            fullscreenControl: false,
            keyboardShortcuts: false,
            gestureHandling: 'cooperative',
            styles: [
                // Keep POI labels visible for context (but hide business icons to reduce clutter)
                {
                    featureType: "poi.business",
                    elementType: "labels.icon",
                    stylers: [{ visibility: "off" }]
                },
                {
                    featureType: "poi.attraction",
                    elementType: "labels.icon",
                    stylers: [{ visibility: "off" }]
                },
                // Hide transit stations but keep lines visible
                {
                    featureType: "transit.station",
                    stylers: [{ visibility: "off" }]
                },
                // Simplify administrative boundaries - keep labels but hide fine gray lines
                {
                    featureType: "administrative",
                    elementType: "geometry.stroke",
                    stylers: [{ visibility: "off" }]
                },
                {
                    featureType: "administrative.locality",
                    elementType: "labels",
                    stylers: [{ visibility: "on" }]
                },
                {
                    featureType: "administrative.neighborhood",
                    elementType: "labels",
                    stylers: [{ visibility: "on" }]
                },
                {
                    featureType: "administrative.land_parcel",
                    stylers: [{ visibility: "off" }]
                },
                // Show local roads and their labels when zoomed in
                {
                    featureType: "road.local",
                    elementType: "labels",
                    stylers: [{ visibility: "on" }]
                },
                {
                    featureType: "road.local",
                    stylers: [{ visibility: "on" }]
                },
                {
                    featureType: "road",
                    elementType: "labels.text.fill",
                    stylers: [{ visibility: "on" }]
                },
                // Show water labels for context
                {
                    featureType: "water",
                    elementType: "labels",
                    stylers: [{ visibility: "on" }]
                },
                {
                    featureType: "water",
                    elementType: "labels.text",
                    stylers: [{ visibility: "on" }]
                },
                // Natural features
                {
                    featureType: "landscape.natural",
                    stylers: [
                        { color: "#E1F3C9" }
                    ]
                },
                {
                    featureType: "water",
                    stylers: [
                        { color: "#CAE8F2" }
                    ]
                }
            ]
        });
        
        // Apply rounded corners to zoom controls after map loads
        setTimeout(() => {
            const mapContainer = document.getElementById('map');
            if (mapContainer) {
                // Find all buttons in the map (zoom controls)
                const buttons = mapContainer.querySelectorAll('button');
                buttons.forEach(button => {
                    if (button.getAttribute('aria-label') && button.getAttribute('aria-label').includes('Zoom')) {
                        button.style.borderRadius = '16px';
                        button.style.borderTopLeftRadius = '16px';
                        button.style.borderTopRightRadius = '16px';
                        button.style.borderBottomLeftRadius = '16px';
                        button.style.borderBottomRightRadius = '16px';
                    }
                });
                
                // Find the zoom control container and round it
                const zoomControls = mapContainer.querySelectorAll('[aria-label*="Zoom"]');
                zoomControls.forEach(control => {
                    const parent = control.closest('div[style*="position"]');
                    if (parent) {
                        parent.style.borderRadius = '16px';
                        parent.style.overflow = 'hidden';
                    }
                });
            }
        }, 500);
        
        // Update map styles based on zoom level - show more details when zoomed in
        function updateMapStylesForZoom() {
            const currentZoom = map.getZoom();
            // When zoomed in (zoom >= 14), show all details
            // When zoomed out (zoom < 14), show fewer details for cleaner look
            const isZoomedIn = currentZoom >= 14;
            
            const zoomedInStyles = [
                // Hide POI icons but show labels when zoomed in
                {
                    featureType: "poi.business",
                    elementType: "labels.icon",
                    stylers: [{ visibility: "off" }]
                },
                {
                    featureType: "poi.attraction",
                    elementType: "labels.icon",
                    stylers: [{ visibility: "off" }]
                },
                // Show POI labels when zoomed in
                {
                    featureType: "poi",
                    elementType: "labels",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                {
                    featureType: "transit.station",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                {
                    featureType: "transit",
                    elementType: "labels",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                {
                    featureType: "administrative",
                    elementType: "geometry.stroke",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                {
                    featureType: "administrative.locality",
                    elementType: "labels",
                    stylers: [{ visibility: "on" }]
                },
                {
                    featureType: "administrative.neighborhood",
                    elementType: "labels",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                {
                    featureType: "administrative.land_parcel",
                    stylers: [{ visibility: "off" }]
                },
                // Show all roads and labels when zoomed in
                {
                    featureType: "road.local",
                    elementType: "labels",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                {
                    featureType: "road.local",
                    stylers: [{ visibility: isZoomedIn ? "on" : "simplified" }]
                },
                {
                    featureType: "road",
                    elementType: "labels.text.fill",
                    stylers: [{ visibility: "on" }]
                },
                // Show water labels when zoomed in
                {
                    featureType: "water",
                    elementType: "labels",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                {
                    featureType: "water",
                    elementType: "labels.text",
                    stylers: [{ visibility: isZoomedIn ? "on" : "off" }]
                },
                // Natural features
                {
                    featureType: "landscape.natural",
                    stylers: [{ color: "#E1F3C9" }]
                },
                {
                    featureType: "water",
                    stylers: [{ color: "#CAE8F2" }]
                }
            ];
            
            map.setOptions({ styles: zoomedInStyles });
        }
        
        // Update styles when zoom changes
        map.addListener('zoom_changed', updateMapStylesForZoom);
        // Also update on initial load
        updateMapStylesForZoom();
        
        // Also apply on map idle event (when map is fully loaded)
        map.addListener('idle', () => {
            const mapContainer = document.getElementById('map');
            if (mapContainer) {
                const buttons = mapContainer.querySelectorAll('button');
                buttons.forEach(button => {
                    if (button.getAttribute('aria-label') && button.getAttribute('aria-label').includes('Zoom')) {
                        button.style.borderRadius = '16px';
                    }
                    // Round all map control buttons
                    const parent = button.parentElement;
                    if (parent && parent.style.position === 'absolute') {
                        parent.style.borderRadius = '16px';
                        parent.style.overflow = 'hidden';
                    }
                });
            }
        });
        
        // Create single info window to reuse
        infoWindow = new google.maps.InfoWindow();
        } catch (e) {
            console.error('Error initializing map:', e);
            // Retry after a delay if there was an error
            setTimeout(function() {
                if (!map) {
                    initMap();
                }
            }, 500);
        }
    }
}

// Guard to prevent multiple simultaneous map updates
let isUpdatingMapMarkers = false;

function updateMapMarkers(listings) {
    if (!map) return;
    
    // Prevent multiple simultaneous updates
    if (isUpdatingMapMarkers) {
        console.log(' Map markers update already in progress, skipping...');
        return;
    }
    
    isUpdatingMapMarkers = true;
    
    // Clear existing clusterer if it exists
    if (markerCluster) {
        try {
            markerCluster.clearMarkers();
        } catch (e) {
            console.warn('Error clearing marker cluster:', e);
        }
        markerCluster = null;
    }
    
    // Clear existing markers
    markers.forEach(function(marker) {
        try {
            marker.setMap(null);
        } catch (e) {
            console.warn('Error removing marker:', e);
        }
    });
    markers = [];
    
    // Create bounds
    var bounds = new google.maps.LatLngBounds();
    var markersToAdd = [];
    var geocodeCount = 0;
    var totalListings = listings.length;
    
    // Add markers for each listing
    listings.forEach(function(listing) {
        geocodeAddress(listing.address, function(lat, lng) {
            if (lat && lng) {
                var position = { lat: lat, lng: lng };
                
                // Create custom marker icon (SVG)
                var markerIcon = {
                    path: 'M 12,2 C 8.1340068,2 5,5.1340068 5,9 c 0,5.25 7,13 7,13 0,0 7,-7.75 7,-13 0,-3.8659932 -3.134007,-7 -7,-7 z',
                    fillColor: '#E3795C',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2,
                    scale: 1.5,
                    anchor: new google.maps.Point(12, 22)
                };
                
                // Create marker without adding to map (clusterer will handle that)
                var marker = new google.maps.Marker({
                    position: position,
                    icon: markerIcon,
                    title: fixEncoding(listing.name),
                    animation: google.maps.Animation.DROP
                });
                
                // Create popup content
                var imageHtml = (listing.image1)
                    ? '<img src="' + normalizeImageUrl(listing.image1, MAP_POPUP_IMAGE_TRANSFORM) + '" loading="lazy" decoding="async" onerror="this.onerror=null; this.src=FALLBACK_IMG;" style="width: 100%; height: 150px; object-fit: cover; border-radius: 12px; display: block; margin: 0; padding: 0;">'
                    : '<img src="' + FALLBACK_IMG + '" loading="lazy" decoding="async" style="width: 100%; height: 150px; object-fit: cover; border-radius: 12px; display: block; margin: 0; padding: 0;">';
                
                var popupContent = 
                    '<div style="padding: 20px 16px; margin: 0; line-height: normal;">' +
                    '<div class="map-popup-title">' + escapeHtml(fixEncoding(listing.name)) + '</div>' +
                    '<div class="map-popup-badges">' +
                    '<span class="badge badge-type ' + getIconClass(listing.type, listing) + '" onclick="filterByBadge(event, \'type\', \'' + listing.type.replace(/'/g, "\\'") + '\'); google.maps.event.trigger(map, \'click\');">' + listing.type + '</span>' +
                    '<span class="badge badge-area" onclick="filterByBadge(event, \'area\', \'' + listing.area.replace(/'/g, "\\'") + '\'); google.maps.event.trigger(map, \'click\');">' + listing.area + '</span>' +
                    '</div>' +
                    imageHtml +
                    '<div class="map-popup-desc" style="margin-top: 12px;">' + escapeHtml(fixEncoding(listing.description).substring(0, 100)) + '...</div>' +
                    '<button class="map-popup-btn" style="width: 100%; margin-top: 16px; background: #2d6a4f !important; color: white !important; border: none; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: visible; white-space: nowrap;" onclick="filterByListingName(\'' + escapeHtml(fixEncoding(listing.name)).replace(/'/g, "\\'") + '\'); google.maps.event.trigger(map, \'click\');">View Details</button>' +
                    '</div>';
                
                // Add click listener to show info window
                marker.addListener('click', function() {
                    // Use square card style for both mobile and desktop
                    var imageUrl = (listing.image1) ? normalizeImageUrl(listing.image1, CARD_IMAGE_TRANSFORM) : FALLBACK_IMG;
                    var cardWidth = (window.innerWidth < 969) ? 120 : 200;
                    var cardHeight = cardWidth; // Square
                    var fontSize = (window.innerWidth < 969) ? 12 : 14;
                    var gradientHeight = (window.innerWidth < 969) ? 50 : 60;
                    var simpleContent = '<div style="padding: 0 12px 16px 12px !important; margin: 0 !important; text-align: center; cursor: pointer; width: ' + cardWidth + 'px; height: ' + cardHeight + 'px; position: relative; overflow: hidden; border-radius: 12px; line-height: 0; font-size: 0; background-image: url(\'' + imageUrl + '\'); background-size: cover !important; background-position: center center !important; background-repeat: no-repeat !important; display: flex; flex-direction: column; justify-content: flex-end; border: 4px solid #ffffff; outline: 0; box-sizing: border-box; min-width: ' + cardWidth + 'px; min-height: ' + cardHeight + 'px;" onclick="filterByListingName(\'' + escapeHtml(fixEncoding(listing.name)).replace(/'/g, "\\'") + '\'); google.maps.event.trigger(map, \'click\');">' + 
                        '<div style="position: absolute; bottom: 0; left: 0; right: 0; height: ' + gradientHeight + 'px; background: linear-gradient(to top, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0)); pointer-events: none; z-index: 1; margin: 0; padding: 0;"></div>' +
                        '<div style="font-size: ' + fontSize + 'px; font-weight: 600; color: #ffffff; line-height: 1.1; padding: 0 10px 18px 10px; margin: 0; position: relative; z-index: 2; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">' + escapeHtml(fixEncoding(listing.name)) + '</div>' +
                        '</div>';
                    infoWindow.setContent(simpleContent);
                    infoWindow.open(map, marker);
                });
                
                markers.push(marker);
                markersToAdd.push(marker);
                bounds.extend(position);
            }
            
            geocodeCount++;
            // When all geocoding is done, create the clusterer
            if (geocodeCount === totalListings) {
                try {
                    // Check if MarkerClusterer library is available
                    if (typeof MarkerClusterer !== 'undefined') {
                        // Create marker clusterer with the @googlemaps/js-marker-clusterer library
                        // Configure to show more detail at higher zoom levels
                        var clusterOptions = {
                            map: map,
                            markers: markersToAdd
                        };
                        
                        // If gridAlgorithm is available, use it for better zoom-based clustering
                        if (typeof MarkerClusterer.gridAlgorithm !== 'undefined') {
                            clusterOptions.algorithm = new MarkerClusterer.gridAlgorithm({
                                gridSize: 60, // Smaller grid = more detail at same zoom
                                maxZoom: 15 // Only cluster up to zoom 15, show individual markers after
                            });
                        }
                        
                        markerCluster = new MarkerClusterer(clusterOptions);
                    } else {
                        // Fallback: add markers directly to map if clusterer not available
                        markersToAdd.forEach(function(marker) {
                            marker.setMap(map);
                        });
                    }
                    
                    // Fit bounds with animation if there are markers
                    if (markers.length > 0) {
                        setTimeout(function() {
                            try {
                                // Check if bounds are valid (not empty)
                                if (!bounds || (bounds.isEmpty && bounds.isEmpty())) {
                                    console.warn(' Invalid bounds, skipping fitBounds');
                                    isUpdatingMapMarkers = false;
                                    return;
                                }
                                
                                // Ensure bounds have minimum size to prevent excessive zoom-out
                                // If bounds are too small (e.g., single point or very close points), extend them
                                var ne = bounds.getNorthEast();
                                var sw = bounds.getSouthWest();
                                var latDiff = ne.lat() - sw.lat();
                                var lngDiff = ne.lng() - sw.lng();
                                
                                // Minimum bounds size: ~0.05 degrees (roughly 3-5 miles)
                                var minLatDiff = 0.05;
                                var minLngDiff = 0.05;
                                
                                if (latDiff < minLatDiff || lngDiff < minLngDiff) {
                                    // Extend bounds to ensure minimum size
                                    var centerLat = (ne.lat() + sw.lat()) / 2;
                                    var centerLng = (ne.lng() + sw.lng()) / 2;
                                    
                                    bounds.extend({
                                        lat: centerLat + minLatDiff / 2,
                                        lng: centerLng + minLngDiff / 2
                                    });
                                    bounds.extend({
                                        lat: centerLat - minLatDiff / 2,
                                        lng: centerLng - minLngDiff / 2
                                    });
                                }
                                
                                // Add padding to bounds to prevent excessive zoom when few listings are visible
                                // More padding = less zoom = wider view
                                var padding = 100; // pixels of padding on all sides
                                
                                // If there are very few listings, add much more padding to keep wider view
                                if (markers.length === 1) {
                                    padding = 400; // Maximum padding for single listing - keep very wide view
                                } else if (markers.length === 2) {
                                    padding = 300; // Large padding for two listings
                                } else if (markers.length <= 3) {
                                    padding = 250; // More padding for very few listings
                                } else if (markers.length <= 10) {
                                    padding = 150; // Medium padding for small number of listings
                                }
                                
                                map.fitBounds(bounds, {
                                    top: padding,
                                    right: padding,
                                    bottom: padding,
                                    left: padding
                                });
                                
                                // Also set a minimum and maximum zoom level to prevent excessive zoom
                                // Wait for fitBounds to complete, then check zoom
                                setTimeout(function() {
                                    var currentZoom = map.getZoom();
                                    
                                    // Set minimum zoom to prevent zooming out too far (showing entire US)
                                    var minZoom = 9; // Minimum zoom level (shows roughly county/region level)
                                    
                                    // Set maximum zoom based on number of listings
                                    var maxZoom = 14; // Default max zoom
                                    if (markers.length === 1) {
                                        maxZoom = 11; // Single listing: maximum zoom of 11 to show surrounding area
                                    } else if (markers.length === 2) {
                                        maxZoom = 12; // Two listings: maximum zoom of 12
                                    } else if (markers.length <= 5) {
                                        maxZoom = 13; // Few listings: maximum zoom of 13
                                    }
                                    
                                    // Apply zoom limits
                                    if (currentZoom < minZoom) {
                                        map.setZoom(minZoom);
                                    } else if (currentZoom > maxZoom) {
                                        map.setZoom(maxZoom);
                                    }
                                    
                                    isUpdatingMapMarkers = false;
                                }, 100);
                            } catch (e) {
                                console.warn('Error fitting map bounds:', e);
                                isUpdatingMapMarkers = false;
                            }
                        }, 500);
                    } else {
                        isUpdatingMapMarkers = false;
                    }
                } catch (e) {
                    console.error('Error creating marker cluster:', e);
                } finally {
                    // Reset flag after a delay to allow next update
                    setTimeout(function() {
                        isUpdatingMapMarkers = false;
                    }, 1000);
                }
            }
        });
    });
}

// Simple geocoding function (uses approximate coordinates for demo)
function geocodeAddress(address, callback) {
    // Approximate coordinates for Nelson County area locations
    var locations = {
        'Roseland': [37.8167, -79.0833],
        'Montebello': [37.8500, -79.1333],
        'Wintergreen': [37.9167, -79.0000],
        'Afton': [38.0333, -78.8333],
        'Lovingston': [37.7667, -78.8667],
        'Nellysford': [37.9000, -78.8833]
    };
    
    // Try to match address to known locations
    for (var loc in locations) {
        if (address.includes(loc)) {
            var coords = locations[loc];
            // Add small random offset for multiple locations in same area
            var lat = coords[0] + (Math.random() - 0.5) * 0.02;
            var lng = coords[1] + (Math.random() - 0.5) * 0.02;
            callback(lat, lng);
            return;
        }
    }
    
    // Default to center of Nelson County with random offset
    callback(37.8 + (Math.random() - 0.5) * 0.1, -79.0 + (Math.random() - 0.5) * 0.1);
}

function toggleMap() {
    var container = document.getElementById('mapContainer');
    var toggleIcon = document.getElementById('mapToggleIcon');
    
    if (mapVisible) {
        container.classList.add('map-collapsed');
        // Change to plus icon
        toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M12 5v14m7-7H5"></path>';
        mapVisible = false;
    } else {
        container.classList.remove('map-collapsed');
        // Change to X icon
        toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>';
        mapVisible = true;
        // Trigger resize to fix display issues
        setTimeout(function() {
            if (map) google.maps.event.trigger(map, 'resize');
        }, 100);
    }
}

var sidebarVisible = true;

function toggleTypeFilters() {
    const expanded = document.querySelector('.type-filters-expanded');
    const seeMoreText = document.querySelector('.see-more-text');
    const seeLessText = document.querySelector('.see-less-text');
    
    if (expanded.style.display === 'none' || !expanded.style.display) {
        expanded.style.display = 'block';
        seeMoreText.style.display = 'none';
        seeLessText.style.display = 'inline';
    } else {
        expanded.style.display = 'none';
        seeMoreText.style.display = 'inline';
        seeLessText.style.display = 'none';
    }
}

function toggleSidebar() {
    var sidebar = document.querySelector('.preview-sidebar');
    var toggleIcon = document.getElementById('sidebarToggleIcon');
    var showSidebarBtn = document.querySelector('.show-sidebar-btn');
    
    if (sidebarVisible) {
        sidebar.classList.add('collapsed');
        sidebarVisible = false;
        
        // Force show-sidebar button to be visible
        if (showSidebarBtn) {
            showSidebarBtn.style.display = 'flex';
            showSidebarBtn.style.visibility = 'visible';
            showSidebarBtn.style.opacity = '1';
            showSidebarBtn.style.zIndex = '2000';
        }
    } else {
        sidebar.classList.remove('collapsed');
        // Change back to X icon when opened
        if (toggleIcon) {
            toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>';
        }
        sidebarVisible = true;
        
        // Hide show-sidebar button when sidebar is visible
        if (showSidebarBtn) {
            showSidebarBtn.style.display = 'none';
        }
    }
    
    // Recalculate image widths after sidebar toggle to fit new card sizes
    // Use the same mechanism as window resize
    setTimeout(function() {
        requestAnimationFrame(function() {
            requestAnimationFrame(function() {
                // Use the force resize function if available, otherwise call directly
                if (window._forceResizeRecalc) {
                    window._forceResizeRecalc();
                } else {
                    // Fallback: call functions directly
                    if (typeof adjustImageWidths === 'function') {
                        adjustImageWidths(true);
                    }
                    if (typeof adjustTitleSizes === 'function') {
                        adjustTitleSizes();
                    }
                }
            });
        });
    }, 200);
}

// Detect if we're in an iframe (Framer embed) - already declared above, just update if needed
try {
    if (!isInIframe) {
        isInIframe = window.self !== window.top;
    }
} catch (e) {
    // Cross-origin - assume we're in an iframe if we can't check
    isInIframe = true;
}

// Listen for messages from parent (height requests and filter parameters)
window.addEventListener('message', function(event) {
    // Only log important messages (not empty setUrlParams/setFilters spam)
    if (event.data && typeof event.data === 'object') {
        const msgType = event.data.type
        // Skip logging empty setUrlParams/setFilters messages to reduce spam
        if (msgType === 'setUrlParams' || msgType === 'setFilters') {
            // Only log if there are actual params or it's a clearAll request
            if (event.data.clearAll === true || (event.data.params && Object.keys(event.data.params).length > 0) || (event.data.search && event.data.search.length > 1)) {
                console.log(' Received postMessage:', msgType, event.data);
            }
        } else if (msgType === 'applyFilter' || msgType === 'urlParamsResponse' || msgType === 'requestHeight') {
            // Always log important messages
            console.log(' Received postMessage:', msgType, event.data);
        }
        // Skip logging other messages to reduce console spam
    }
    
    if (event.data && event.data.type === 'requestHeight') {
        // Parent is requesting height update
        reportContentHeight();
    }
    
    // Handle URL parameters sent as query string from parent (preferred method)
    // Note: setFilters is deprecated - use setUrlParams instead to avoid duplicate processing
    if (event.data && event.data.type === 'setUrlParams') {
        // Check if this is a clearAll request - handle this FIRST before any other processing
        if (event.data.clearAll === true) {
            console.log(' Received clearAll request - clearing all URL parameters and filters');
            // Clear all received parameters
            receivedUrlParams = {};
            lastProcessedParamsHash = null;
            // Set flag to ignore all URL parameters until user explicitly sets a filter
            filtersExplicitlyCleared = true;
            try {
                sessionStorage.setItem('filtersExplicitlyCleared', 'true');
            } catch (e) {
                // sessionStorage might not be available
            }
            // Ignore URL parameters for 5 seconds to prevent re-applying filters (backup)
            ignoreUrlParamsUntil = Date.now() + 5000;
            // Clear filter state
            currentCategoryFilter = null;
            currentTypeFilter = [];
            currentFeaturedOnly = false;
            // Clear filter inputs
            const searchInput = document.getElementById('previewSearchInput');
            const mobileSearchInput = document.getElementById('previewSearchInputMobile');
            const typeFilter = document.getElementById('previewTypeFilter');
            const areaFilter = document.getElementById('previewAreaFilter');
            const amenityFilter = document.getElementById('previewAmenityFilter');
            if (searchInput) searchInput.value = '';
            if (mobileSearchInput) mobileSearchInput.value = '';
            if (typeFilter && typeFilter.options.length > 0) {
                typeFilter.selectedIndex = 0;
                typeFilter.value = '';
            }
            if (areaFilter && areaFilter.options.length > 0) {
                areaFilter.selectedIndex = 0;
                areaFilter.value = '';
            }
            if (amenityFilter && amenityFilter.options.length > 0) {
                amenityFilter.selectedIndex = 0;
                amenityFilter.value = '';
            }
            // Clear filter buttons
            document.querySelectorAll('.type-filter-btn, .category-filter-btn').forEach(function(btn) {
                btn.classList.remove('active');
            });
            // Activate "All Types" button
            document.querySelectorAll('.type-filter-btn').forEach(function(btn) {
                if (btn.dataset.type === '' && !btn.dataset.category) {
                    btn.classList.add('active');
                }
            });
            // Apply filters to show all listings (no filters active)
            if (data) {
                filterPreview();
            }
            // Hide clear button
            const clearBtn = document.getElementById('clearFiltersBtn');
            const mobileClearBtn = document.getElementById('mobileClearFiltersBtn');
            if (clearBtn) clearBtn.style.display = 'none';
            if (mobileClearBtn) mobileClearBtn.style.display = 'none';
            // Don't process URL parameters - they've been cleared
            return;
        }
        
        // Normal parameter update
        if (event.data.search) {
            // Check if we should ignore URL parameters (recently cleared filters)
            if (Date.now() < ignoreUrlParamsUntil) {
                const secondsLeft = Math.round((ignoreUrlParamsUntil - Date.now()) / 1000);
                console.log(' Ignoring URL parameters (recently cleared filters, ignoring for', secondsLeft, 'more seconds):', event.data.search);
                return;
            }
            
            // Parse the search string and store as parameters
            var params = {};
            var searchParams = new URLSearchParams(event.data.search);
            for (var pair of searchParams.entries()) {
                params[pair[0]] = pair[1];
            }
            
            // If we just cleared filters and parent is still sending filter params, ignore them
            // Keep ignoring until parent sends empty parameters (indicating URL was cleared)
            const hasFilterParams = !!(params.category || params.type || params.area || params.amenity || params.featured || params.search);
            if (hasFilterParams && ignoreUrlParamsUntil > 0) {
                // We're in ignore period - keep ignoring filter params until parent sends empty params
                // This prevents re-applying filters if parent URL hasn't been cleared yet
                const secondsSinceClear = Math.round((Date.now() - (ignoreUrlParamsUntil - 5000)) / 1000);
                console.log(' Ignoring filter parameters (parent URL may not be cleared yet, cleared', secondsSinceClear, 'seconds ago):', event.data.search);
                return;
            }
            
            // If we receive empty parameters (no filters), reset the ignore period
            if (!hasFilterParams && ignoreUrlParamsUntil > 0) {
                console.log(' Parent sent empty parameters - URL was cleared, resetting ignore period');
                ignoreUrlParamsUntil = 0; // Reset ignore period
            }
            
            // Merge with existing params (don't overwrite, merge)
            const mergedParams = Object.assign({}, receivedUrlParams, params);
            const newParamsHash = JSON.stringify(mergedParams);
            
            // Only process if parameters actually changed
            if (lastProcessedParamsHash !== newParamsHash) {
                console.log(' Received URL search string via postMessage:', event.data.search);
                // Merge received parameters with existing ones (preserve iframe URL params)
                receivedUrlParams = mergedParams;
                // Apply filters if data is loaded
                if (data) {
                    handleUrlParameters();
                }
            }
        }
    }
    
    // Handle response to getUrlParams request
    if (event.data && event.data.type === 'urlParamsResponse' && event.data.params) {
        // Reset pending flag since we got a response
        pendingGetUrlParamsRequest = false;
        
        const newParams = event.data.params;
        
        // Only process if there are actually params (don't spam when URL is clean)
        if (Object.keys(newParams).length === 0) {
            // Empty params response - don't log or process, just reset flag
            return;
        }
        
        // Merge with existing params (don't overwrite, merge)
        const mergedParams = Object.assign({}, receivedUrlParams, newParams);
        const newParamsHash = JSON.stringify(mergedParams);
        
        // Only process if parameters actually changed
        if (lastProcessedParamsHash !== newParamsHash) {
            console.log(' Received URL parameters response from parent:', newParams);
            // Merge received parameters with existing ones (preserve iframe URL params)
            receivedUrlParams = mergedParams;
            // Apply filters if data is loaded
            if (data) {
                handleUrlParameters();
            }
        }
    }
    
    // Handle direct filter application (from breadcrumbs - no URL params)
    if (event.data && event.data.type === 'applyFilter' && event.data.params) {
        // Check source to ensure it's from breadcrumb (or allow any source for now)
        const filterParams = event.data.params;
        console.log('  RECEIVED APPLYFILTER MESSAGE:', filterParams, 'source:', event.data.source);
        console.log(' Full event.data:', JSON.stringify(event.data));
        
        // Clear the "explicitly cleared" flag since user is setting a filter
        filtersExplicitlyCleared = false;
        try {
            sessionStorage.removeItem('filtersExplicitlyCleared');
        } catch (e) {
            // sessionStorage might not be available
        }
        
        // If data isn't loaded yet, store the filter params to apply later
        if (!data) {
            console.log(' Data not loaded yet, storing breadcrumb filter for later:', filterParams);
            pendingBreadcrumbFilter = filterParams;
            return;
        }
        
        // Apply filters directly without using URL parameters
        console.log('  Applying breadcrumb filter now with data loaded...');
        applyBreadcrumbFilter(filterParams);
        
        // Don't update URL - breadcrumbs use direct filtering
        return;
    }
    
    // Handle direct category setting (simpler API for Framer links)
    if (event.data && event.data.type === 'setCategory' && event.data.category !== undefined) {
        const newParams = { category: event.data.category };
        const newParamsHash = JSON.stringify(newParams);
        
        // Only process if parameters actually changed
        if (lastProcessedParamsHash !== newParamsHash) {
            console.log(' Received category via postMessage:', event.data.category);
            receivedUrlParams = newParams;
            // Apply filters if data is loaded
            if (data) {
                handleUrlParameters();
            }
        }
        // Also update URL if possible
        try {
            const url = new URL(window.location.href);
            if (event.data.category) {
                url.searchParams.set('category', event.data.category);
            } else {
                url.searchParams.delete('category');
            }
            window.history.pushState({ category: event.data.category }, '', url.toString());
        } catch (e) {
            // Can't update URL (cross-origin or other restriction)
        }
    }
});

// Make search bar fixed to top of browser window when scrolling
function handleStickyInIframe() {
    try {
        const searchContainer = document.querySelector('.top-search-container');
        if (!searchContainer) return;

        let scrollTimeout = null;
        const SCROLL_THRESHOLD = 100; // Start fixing after scrolling 100px

        const handleScroll = function() {
            const scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
            const rect = searchContainer.getBoundingClientRect();
            const sidebar = document.querySelector('.preview-sidebar');
            const sidebarWidth = sidebar && !sidebar.classList.contains('collapsed') ? 280 : 0;
            
            // Calculate if search bar should be fixed based on scroll position
            // Fixed when scrolled past threshold OR when search bar would scroll out of view
            if (scrollTop > SCROLL_THRESHOLD || rect.top < 0) {
                // Make it fixed to top of window
                searchContainer.style.setProperty('position', 'fixed', 'important');
                searchContainer.style.setProperty('top', '0px', 'important');
                searchContainer.style.setProperty('left', sidebarWidth + 'px', 'important');
                searchContainer.style.setProperty('width', 'calc(100% - ' + sidebarWidth + 'px)', 'important');
                searchContainer.style.setProperty('z-index', '1000', 'important');
                
                // Ensure main content has padding to account for fixed search bar
                const mainContent = document.querySelector('.preview-main');
                if (mainContent) {
                    const searchHeight = searchContainer.offsetHeight || 80;
                    mainContent.style.setProperty('padding-top', searchHeight + 'px', 'important');
                }
            } else {
                // Use sticky positioning when near top
                searchContainer.style.removeProperty('position');
                searchContainer.style.removeProperty('top');
                searchContainer.style.removeProperty('left');
                searchContainer.style.removeProperty('width');
                searchContainer.style.setProperty('z-index', '1000', 'important');
                
                // Remove padding from main content
                const mainContent = document.querySelector('.preview-main');
                if (mainContent) {
                    mainContent.style.removeProperty('padding-top');
                }
            }
        };

        // Throttle scroll events
        const throttledScroll = function() {
            if (scrollTimeout) return;
            scrollTimeout = setTimeout(function() {
                handleScroll();
                scrollTimeout = null;
            }, 16); // ~60fps
        };

        window.addEventListener('scroll', throttledScroll, { passive: true });
        window.addEventListener('resize', handleScroll, { passive: true });
        
        // Initial check
        handleScroll();

        // Return cleanup (though function doesn't return in this context)
        return function() {
            window.removeEventListener('scroll', throttledScroll);
            window.removeEventListener('resize', handleScroll);
            if (scrollTimeout) clearTimeout(scrollTimeout);
        };
    } catch (e) {
        // Silently fail
    }
}

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', function() {
    // Disable browser scroll restoration to prevent unwanted scrolling on navigation
    if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
    
    // Global link click handler: preserve parameters only for /find-your-adventure links
    document.addEventListener('click', function(e) {
        // Find the closest anchor tag
        const link = e.target.closest('a');
        if (!link || !link.href) return;
        
        // Skip if link has target="_blank" (opens in new tab - don't interfere)
        if (link.target === '_blank') return;
        
        const href = link.href;
        
        // Check if link contains /find-your-adventure
        const containsFindYourAdventure = href.includes('/find-your-adventure');
        
        if (containsFindYourAdventure) {
            // Preserve parameters - use buildUrlWithConditionalParams to add current params
            const urlWithParams = buildUrlWithConditionalParams(href);
            if (urlWithParams !== href) {
                // Prevent default navigation, modify href, then navigate
                e.preventDefault();
                e.stopPropagation();
                link.href = urlWithParams;
                // Navigate to the modified URL
                if (link.target === '_parent' && window.parent && window.parent !== window) {
                    window.parent.location.href = urlWithParams;
                } else {
                    window.location.href = urlWithParams;
                }
                return false;
            }
        } else {
            // Remove parameters - ensure URL doesn't have query string
            try {
                const url = new URL(href);
                if (url.search) {
                    const cleanUrl = url.origin + url.pathname + (url.hash || '');
                    // Only modify if URL actually has parameters
                    e.preventDefault();
                    e.stopPropagation();
                    link.href = cleanUrl;
                    // Navigate to the clean URL
                    if (link.target === '_parent' && window.parent && window.parent !== window) {
                        window.parent.location.href = cleanUrl;
                    } else {
                        window.location.href = cleanUrl;
                    }
                    return false;
                }
            } catch (err) {
                // If URL parsing fails, try manual removal
                if (href.includes('?')) {
                    const urlWithoutParams = href.split('?')[0];
                    const hash = href.includes('#') ? href.substring(href.indexOf('#')) : '';
                    const cleanUrl = urlWithoutParams + hash;
                    e.preventDefault();
                    e.stopPropagation();
                    link.href = cleanUrl;
                    // Navigate to the clean URL
                    if (link.target === '_parent' && window.parent && window.parent !== window) {
                        window.parent.location.href = cleanUrl;
                    } else {
                        window.location.href = cleanUrl;
                    }
                    return false;
                }
            }
        }
    }, true); // Use capture phase to catch links before they navigate
    
    // Handle sticky positioning for iframe context
    handleStickyInIframe();
    
    // Initialize map - wait a bit to ensure Google Maps API is loaded
    setTimeout(function() {
        initMap();
    }, 200);
    
    // Report initial height after page loads
    setTimeout(function() {
        reportContentHeight();
    }, 500);
    
    // Type filter buttons - this handler is for legacy individual type buttons
    // Category buttons use attachCategoryFilterButtonHandler instead
    // Skip buttons that have data-category attribute (those are category buttons)
    document.querySelectorAll('.type-filter-btn:not([data-category])').forEach(function(btn) {
        // Only handle buttons without data-category (legacy individual type buttons)
        // Category buttons are handled by attachCategoryFilterButtonHandler
        if (btn.dataset.category) return; // Skip category buttons
        
        // Add clicking class on mousedown for visual feedback
        btn.addEventListener('mousedown', function() {
            this.classList.add('clicking');
        });
        // Remove clicking class on mouseup or mouseleave
        btn.addEventListener('mouseup', function() {
            this.classList.remove('clicking');
        });
        btn.addEventListener('mouseleave', function() {
            this.classList.remove('clicking');
        });
        btn.addEventListener('click', function() {
            // Remove clicking class after click
            this.classList.remove('clicking');
            const filterValue = this.dataset.type;
            
            // Special handling for "All Types" button (empty data-type and no data-category)
            if (filterValue === '' && !this.dataset.category) {
                // Clear all selections and activate only "All Types"
                currentTypeFilter = [];
                currentCategoryFilter = null;
                document.querySelectorAll('.type-filter-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                this.classList.add('active');
            } else if (filterValue && !this.dataset.category) {
                // Individual type button (not a category button)
                // Set single type and determine its category
                currentTypeFilter = [filterValue];
                const categoryForType = getCategoryForType(filterValue, null);
                currentCategoryFilter = categoryForType;
                
                // Clear all buttons and activate the appropriate category button
                document.querySelectorAll('.type-filter-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                
                // Activate the category button if it exists
                if (categoryForType) {
                    const categoryBtn = document.querySelector('.type-filter-btn[data-category="' + categoryForType + '"]');
                    if (categoryBtn) {
                        categoryBtn.classList.add('active');
                    }
                } else {
                    // No category found, activate "All Types"
                    const allTypesBtn = document.querySelector('.type-filter-btn[data-type=""]:not([data-category])');
                    if (allTypesBtn) {
                        allTypesBtn.classList.add('active');
                    }
                }
            }
            
            filterPreview();
        });
    });
    
    // Report height on window resize
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            reportContentHeight();
        }, 250);
    });
});

    </script>

</body>
</html>

